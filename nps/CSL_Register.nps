/**
 * @file CSL_Register.nps
 * @brief This NPS file implements BusinessComponents Register.
 *
 * @addtogroup 	CSL
 * @defgroup 	Register
 * @ingroup 	CSL
 *
 * Copyright (C) 2008 McDonalds Corp. All rights reserved.
 *
 * @author Pedro (of Creation)
 * @since NPS-4831 / date
 *
 * @version $Id: CSL_Register.nps 776 2009-08-06 13:46:38Z rcaram $
 * @remarks Include here all remarks related to this file!
 * @{
 */

/* Variable used for version control */
CSL_REGISTER_VERSION = "$WCURL$:$WCREV$";

/* Set the variable. */
SRC_BC_REGISTER='CSL_Register.nps';


/* calculator input */
var BCCALC_TYPE = {BC_CALC_DLG:0, BC_CALC_SCR:1, BC_CALC_BESTFIT:2};

/* Format for calculator input display */
var NPCALC_FMT = {NPUI_CALC_DEC:0, NPUI_CALC_INT:1, NPUI_CALC_DATE:2, NPUI_CALC_TIME:3, NPUI_CALC_PASSWD:4, NPUI_CALC_PERCENT:5, NPUI_CALC_HOUR:6};

/* Rounding modes */
var Rounding_Mode = {ROUND_UP:0, ROUND_DOWN:1, ROUND_CEILING:2, ROUND_FLOOR:3, ROUND_HALF_UP:4, ROUND_HALF_DOWN:5, ROUND_HALF_EVEN:6};

/* User info type */
var INFO_TYPE = {ID:0, NAME:1, SECURITY_LEVEL:2};


/**
 * @brief This function implements the BC,Business Component: <b>PosCheckTLOGWithWayStation</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosCheckTLOGWithWayStation is responsible for performing the register insert validation with the way station
 * In java script it should be called:<b>PosCheckTLOGWithWayStation()</b>
 * @since 1.21
 */
function PosCheckTLOGWithWayStation() {

	var cmd = "PosCheckTLOGWithWayStation";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosReload</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosReload is responsible reload configuration files: product-db.xml, names-db.xml, screen.xml and workflow.xml
 * In java script it should be called:<b>PosReload()</b>
 * @since 1.19
 */
function PosReload() {

	if(!PosNotATransactionInProgress(false)) {
		return true;
	}

	PosDisplayText("Reloading configuration", 1);

	var cmd = "PosReload";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosCheckSalesBeforeClose</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosCheckSalesBeforeClose is responsible for check if there is an order in progress before close register or change or drawer change.
 * In java script it should be called:<b>PosCheckSalesBeforeClose(mode)</b>
 * @param mode - String - can be "EOD" for close or "CDC" for drawer change.
 * @since 1.17-
 */
function PosCheckSalesBeforeClose(mode) {
	var cmd = "PosCheckSalesBeforeClose";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [mode]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosCheckState</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosCheckState is responsible for check the current status of the POS (Opened,Closed,Operator logged, blocked, operator blocked).
 * In java script it should be called:<b>PosCheckState(state)</b>
 * @param state - String - POS state to check, it can be:\n
 *		  				   "POS_Opened": to check if the POS is in an opened state\n
 *						   "POS_Closed": to check if the POS is in a closed state\n
 *		 				   "POS_OpLogged": to check if the POS is in an operator logged-in state\n
 *						   "POS_Blocked": to check if the POS is in a blocked state\n
 *		 				   "POS_OpBlocked": to check if the POS is in an operator blocked state\n
 * @success current POS state matches the state received as parameter.
 * @failure <i>Argument Missing</i> - state parameter is missing.
 * @failure <i>State do not Match</i> - given state do not match with the current POS state.
 * @since 1.17-
 */
function PosCheckState(state) {
	var cmd = "PosCheckState";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [state]);
}

/**
 * @brief This function implements the BC,Business Component: <b>cPosDayOpen</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC is responsible for opening the day. The POS status must be "closed" in order to successfully open the day. The date and the POS open
 * mode (storewide, offline or forced) must be informed.
 *
 * @param POSMode - string - POS open mode. The values can be:\n
 *							"storewide": open POS in Store Wide mode;\n
 *							"offline": open POS in Offline mode;\n
 *							"forced": open POS in Store Wide Forced mode.
 * @param date - string - Businessday to be opened. Must be in system date format (yyyyMMdd).
 * @success Business Day opened successfully.
 * @failure	<i>Invalid POSMode parameter</i> - The POSMode parameter must be "storewide", "offline" or "forced".
 * @failure	<i>Invalid date format</i> - The date format must be yyyyMMdd.\n
 * @failure	<i>Invalid date</i> - Only future date is valid, relative to the last closed BusinessDay or the day before the current system date,
 * in case of no previous BusinessDay.\n
 * @failure <i>POS is not closed</i> - The POS status must be closed for opening the day.
 * @sessioncontext <i>PosDoDayOpen_Failure</i> - Indicates the failure string with the message to be shown in a dialog window, in case of a
 * failure when trying to open a business day.
 * @sessioncontext <i>PosDoDayOpen_Result</i> -  Indicates the result string. Not used.
 * @remarks
 *
 * Property Messages:
 *	 MSG_BC_INVDATE: When the date is invalid.
 *	 MSG_BC_DAYOPENED: When the day is opened and the message is shown in the operator display.
 *	 MSG_BC_ALREADYOPEN: When the POS status is not closed.
 *
 * @since 1.17-
 */
function cPosDayOpen(POSMode,date) {
	var cmd = "cPosDayOpen";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [POSMode,date]);
}

/**
 * @brief This function implements the BC,Business Component: <b>cPosDayOpenVerify</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC is responsible for checking if it is possible to open a business day. In order to open a business day, the POS state must be "Closed".
 * The business day to be opened must be informed.
 *
 * @param date - string - Businessday to be verified. Must be in system date format (yyyyMMdd).
 * @success Business Day can be opened.
 * @failure	<i>Invalid date format</i> - The date format must be yyyyMMdd.\n
 * @failure	<i>Invalid date</i> - Only future date is valid, relative to the last closed BusinessDay or the day before the current system date,
 * in case of no previous BusinessDay.\n
 * @failure <i>POS is not closed</i> - The POS cannot be opened with state different than "Closed".
 * @sessioncontext <i>cPosDayOpenVerify_Failure</i> - Indicates the failure string with the message to be shown in a dialog window, in case of a
 * failure when verifying if it is possible to open a business day.
 * @sessioncontext <i>cPosDayOpenVerify_Result</i> -  Indicates the result string. Not used.
 * @remarks
 *
 * Property Messages:
 *	 MSG_BC_INVDATE: When the date format is invalid.
 *	 MSG_BC_INVBUSDATE: When the date is not valid. Only future date is valid.
 *	 MSG_BC_ALREADYOPEN: When the POS status is not closed.
 *
 * @since 1.17-
 */
function cPosDayOpenVerify(date) {
	var cmd = "cPosDayOpenVerify";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [date]);
}


/**
 * @brief This function implements the BC,Business Component: <b>PosDayOpen_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosDayOpen_CSL is responsible for perform the actions needed to open the day.\n
 * Before actually opening the day, the POS state is checked. It should be "closed" for opening the day.\n
 * If Session Context variable "dayOpenBusinessDay" is previously set, by a call to PosDoSWOpenDay for example,\n
 * it is used as the business day, otherwise a "calculator" window is opened for the user to enter the business day.\n
 * It is also possible to inform the necessary security level to perform the action.\n
 * If that's the case an authorization is requested from the user.\n
 * The action can be done in a verify mode, when only consistency is performed,\n
 * or in execution mode (default case) when the open day is actually performed.\n
 * The option "verify" is normally used to inform the POS state when a Store Wide Open is to be performed.\n
 * After completion, the POS state is updated in WAY Station.\n
 * In java script it should be called:<b>PosDayOpen_CSL(openMode, level)</b>
 * @param openMode - String - Optional, "verify" or "execute"(default).
 * @param level - String - Optional, "manager"(default),"supervisor","system" but also:"null","remote" and "forced",
 *        "null" indicates that no authorization is required and "remote" that the authorization was granted remotely.
 * @success The open day was performed or can be performed (in case of verify mode).
 * @failure <i>onDayOpen() failed</i> - hook returned false.
 * @failure <i>POS retrieve state Error</i> - Error trying to retrieve POS state.
 * @failure <I>POS is not closed</i> - POS is already open.
 * @failure <i>User Cancelled Date</i> - User cancelled calculator when asking for the date.
 * @failure <i>Invalid Business Day</i> - given business day is invalid.
 * @failure <i>Not Authorized</i> - operation not authorized.
 * @failure <i>onDayOpened() failed</i> - hook returned false.
 * @hook <i>onDayOpen(openMode, level)</i> - called before BC start.
 * @hook <i>onDayOpened(openMode, level)</i> - called if day was successfully opened.
 * @sessioncontext <i>"dayOpenBusinessDay"</i> - Read to check if already set, write to clear its data.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_DAYOPENCONF: Shown in the calculator when asking for the date.\n
 *	MSG_BC_INVBUSDATE: Shown if date is not valid.\n
 *	MSG_BC_DAYOPENED: Shown if day was correctly opened.\n
 *	MSG_BC_ALREADYOPEN: Shown if day is already opened.\n
 *
 * @since 1.18
 */
function PosDayOpen_CSL(openMode, level)
{
	var cmd = "PosDayOpen_CSL";
	var result = true;
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);

	switch(state) {
	case POS_STA_CLOSED:
		// Gets Date Format - Store-DB-Xml
		var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
		// Gets Business Day - "dayOpenBusinessDay"
		var ctx=new SessionContext;
		var dayOpen = ctx.get("dayOpenBusinessDay");

		// SDO-4619 - Offline Day Open fix (undone SDO-4447 fix)
		if (dayOpen == null) {
			// Gets Date System
			var wdate  = new Date();
			var wyear  = setZerosOnLeft(wdate.getFullYear(),4);
			var wmonth = setZerosOnLeft(wdate.getMonth() + 1,2);
			var wday   = setZerosOnLeft(wdate.getDate(),2);
			var sdate  = wyear + wmonth + wday;
			var sMsg=hlp.getSysMessage("MSG_BC_DAYOPENCONF",fmtDate);
			
			if(openMode != "S") {
				if (PosAskDate(sdate, sMsg, 2)) {
					dayOpen = getLastSuccess("PosAskDate");
				} else {
					result = false;
					break;
				}
			}
			else {
				dayOpen = sdate;
			}
		}
		else {
			ctx.set("dayOpenBusinessDay",null,false);
		}

		if (openMode == undefined) {
			var openMode = "execute";
		}
		if (level == undefined) {
			var level = "manager";
		}
		if (openMode == "verify") {
			result = cPosDayOpenVerify(dayOpen);
			if ((result == false)&&(level != "remote")) {	// SQC-1625 - do not show message for remote operation
				PosShowMessage(getLastFail("cPosDayOpenVerify"));
			}
		} else {
			var posMode = "offline";

			if ((level != "remote") && (level != "forced") && (level != "null") && (openMode != "S")) {
				//  Manager Autorization
				if(!PosGetAuthorization("manager")) {
					return(false);
				}
			}
			if (level == "remote") {
				posMode = "storewide";
			}
			if (level == "forced") {
				posMode = level;
			}
			result = cPosDayOpen(posMode, dayOpen);
			if ((result == false)&&(level != "remote")) {
				PosShowMessage(getLastFail("cPosDayOpen"));
			}
			else {
				// check automatic login
				if(false==PosVerifyAutoLogonJS()) {
					var opId=hlp.findParamInSectionConfig("AnonymousOperatorID","OperationMode");
					var opName=hlp.findParamInSectionConfig("AnonymousOperatorName","OperationMode");
					var initialFloat=new BigDecimal(0);

					if((null==opId)||(""==opId)||("0"==opId)) {
						// parameter error
						PosShowMessage("MSG_BC_INVOPERATORID");
					}
					else {
						if((null==opName)||(""==opName)) {
							// parameter error
							PosShowMessage("MSG_BC_INVOPERATORNAME");
						}
						else {
							cPosOperatorLogin(opId,initialFloat,"true",opName);
						}
					}
				}
			}
		}
		break;
	default:
		PosShowMessage("MSG_BC_ALREADYOPEN");
		result = false;
		break;
	}
 	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDetachKVS</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosDetachKVS is responsible for ask the WayStation to detach a KVS in the network.
 * In java script it should be called:<b>PosDetachKVS(nbrKVS)</b>
 * @param nbrKVS - String - KVS to detach.
 * @success Detach KVS command successfully sent to WayStation.
 * @failure <i>Command Send Error</i> - Error while sending detach KVS command to WayStation.
 * @todo Check return code if argument is missing.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_KVSDETACH_SUCCESS: Shown if KVS successfully detached.\n
 *	MSG_BC_KVSDETACH_WSUNAVAIABLE: Shown if WayStation is unavailable.\n
 *	MSG_BC_KVSDETACH_ERROR: Shown if could not detach KVS.\n
 * @since 1.17-
 */
function PosDetachKVS(nbrKVS) {
	var cmd = "PosDetachKVS";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [nbrKVS]);
}

/**
 * @brief This function implements the BC,Business Component: <b>cPosOperatorLogin</b>
 *
 * This BC performs operator login routine!\n
 * In a workflow sequence it is called:<b>cPosOperatorLogin $id &initialFloat &autoLogin</b>\n
 * In java script it should be called:<b>cPosOperatorLogin(id,initFloat,autoLogin)</b>\n
 * @param id - string - operator id
 * @param initFloat - string - initial float of the native currency
 * @param autoLogin - string - autologin set ("true"/"false") [1.20]
 * @param name - string - (optional) the operator name. This is required when the operator id is not under the security.data file [1.20]
 * Property Messages:\n
 *   MSG_PROMPTOP: Prompt message asking operator identification.\n
 *   MSG_BC_LOGINFLOAT: Prompt message asking initial float.\n
 *   MSG_BC_LOGINCONF: Prompt message confirming log-in.\n
 *   MSG_BC_OPERLOGIN: Message confirming log-in.\n
 *   MSG_BC_INVLOGINOP: Error message not opened log-in.\n
 *   MSG_BC_INVLOGINLG: Error message operator already logedd-in.\n
 *   MSG_BC_INVLOGINBK: Error message POS time blocked.\n
 * Hooks: no events
 * @return rval - True if the operator was logged in successfully.
 * @since 1.17-
 */
function cPosOperatorLogin(id,initFloat,autoLogin,name) {
	var cmd = "cPosOperatorLogin";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd,[id,initFloat,autoLogin,name]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosOperatorLogin</b>
 *
 * Persistence:<b>Persisted</b>\n
 * This BC performs operator login routine!
 * In a workflow sequence it is called:<b>PosOperatorLogin</b>
 * In java script it should be called:<b>PosOperatorLogin()</b>
 * @success operator was logged in successfully
 * @failure <i>Incorrect ID</i> - Invalid user id.
 * @failure <i>Initial float</i> - Initial float is greater than limit.
 * @failure <i>DT log-in</i> - DT tandem mode log-in error.
 * @failure <i>Not open</i> - POS not open.
 * @failure <i>Already logedd</i> - POS operator already logged.
 * @failure <i>Time block</i> - POS blocked by time.
 * @remarks
 *
 * Property Messages:\n
 *   MSG_PROMPTOP: Prompt message asking operator identification.\n
 *   MSG_BC_LOGINFLOAT: Prompt message asking initial float.\n
 *   MSG_BC_LOGINCONF: Prompt message confirming log-in.\n
 *   MSG_BC_OPERLOGIN: Message confirming log-in.\n
 *   MSG_INVPASSWD: Error message invalid user id.\n
 *   MSG_BC_INIT_FLOAT_LIMIT: Error message initial float out of limit\n
 *   MSG_DT_LOGIN_TANDEM_ERR:  Error message DT tandem mode log-in error\n
 *   MSG_BC_INVLOGINOP: Error message not opened log-in.\n
 *   MSG_BC_INVLOGINLG: Error message operator already logedd-in.\n
 *   MSG_BC_INVLOGINBK: Error message POS time blocked.\n
 * @since 1.17-
 */
function PosOperatorLogin() {
	var cmd = "cPosOperatorLogin";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var currency = "";
	var ret = false;

	var hlp=new BusinessObjectHelper;

	var xmlPOS = new XML(hlp.getPOSState());

	var state = Number(xmlPOS.@state);

	switch(state) {
	case POS_STA_CLOSED:
		PosShowMessage("MSG_BC_INVLOGINOP");
		break;
	case POS_STA_OPENED:
		// Gets user id
		var ctx=new SessionContext;
		// Asks working mode, in case of DT
		var workingMode=selectWorkMode("Login as Secondary Cashier");
		if((workingMode != null) && (workingMode[0] != null)) {
			ctx.set("workingMode",workingMode[0],true);
			if(workingMode[1] != null) {
				ctx.set("tandemBooth",workingMode[1],true);
			}
			else {
				var tdBooth=hlp.findParamInSectionConfig("tandemBooth","PosType");
				ctx.set("tandemBooth",tdBooth,true);
			}
		}
		var sId = PosShowCalculator("MSG_PROMPTOP", "", NPCALC_FMT.NPUI_CALC_INT, BCCALC_TYPE.BC_CALC_DLG);
		if(sId.length == 0) {
			break;
		}
		// Checks operator validity
		nOperSecurityLevel=hlp.getUserInfo(sId, INFO_TYPE.SECURITY_LEVEL);
		if(!hlp.validateUser(sId,null,0,true)) {
			// Reset needs at least a floor manager
			PosShowMessage("MSG_INVPASSWD");
			break;
		}

		var currencyDecimals = rootStoreDB.StoreDB.StoreProfile.Localization.CurrencyDecimals;
		var tdInitialFloat = new BigDecimal(0);

		var podMode = ctx.get("workingMode");
		if (podMode != "orderTaker") {
			// Gets user initFloat
			sFloatMsg = hlp.getSysMessage("MSG_BC_LOGINFLOAT", hlp.getUserInfo(sId, INFO_TYPE.NAME));
			var currencySymbol = rootStoreDB.StoreDB.StoreProfile.Localization.CurrencySymbol;
			sInitFloat = PosShowCalculator(sFloatMsg, currencySymbol, NPCALC_FMT.NPUI_CALC_DEC, BCCALC_TYPE.BC_CALC_BESTFIT, "");
			if(sInitFloat.length == 0) {
				break;
			}

			// calculate 10^currencyDecimals
			var p10 = Math.pow(10, currencyDecimals);

			tdInitialFloat.setValue(sInitFloat);
			tdInitialFloat = tdInitialFloat.setScale(currencyDecimals, Rounding_Mode.ROUND_HALF_EVEN);
			// divide to obtain decimals
			tdInitialFloat = tdInitialFloat.divide(p10, Rounding_Mode.ROUND_HALF_EVEN);

		    // Pickup Initial Float Limit
		    if(rootStoreDB != null) {
			    var tdInitialFloatLimit = new BigDecimal(rootStoreDB.StoreDB.StoreProfile.BusinessLimits.InitialFloatLimit);
				tdInitialFloatLimit = tdInitialFloatLimit.setScale(currencyDecimals, Rounding_Mode.ROUND_HALF_EVEN);

				// is init value great than limit?
				if (tdInitialFloat.compareTo(tdInitialFloatLimit) > 0) {
		  		    var sInitVlr1 = tdInitialFloatLimit.toStringFmt();
		  		    var sInitVlr2 = tdInitialFloat.toStringFmt();
					var sErrMsg=hlp.getSysMessage("MSG_BC_INIT_FLOAT_LIMIT",sInitVlr1,sInitVlr2);
				    PosShowMessage(sErrMsg);
					break;
				}
			}
		}

		// Confirms login
		var sInitAmt = tdInitialFloat.toStringFmt();

		var name = hlp.getUserInfo(sId, INFO_TYPE.NAME);
		var sConfMsg=hlp.getSysMessage("MSG_BC_LOGINCONF",name,currency,sInitAmt);

		if(PosShowConfirmationMessage(sConfMsg,"MSG_YES","MSG_NO")) {
			ret = executeBC(cmd, [sId, sInitAmt, "false"]);
		}

		// ***
		if(!auxValidDtMode()) {
			PosShowMessage("MSG_DT_LOGIN_TANDEM_ERR");
			return(false);
		}
		break;
	case POS_STA_OPLOGGED:
		PosShowMessage("MSG_BC_INVLOGINLG");
		break;
	default:
		PosShowMessage("MSG_BC_INVLOGINBK");
		break;
	}
	return(ret);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoOperatorLogin</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosDoOperatorLogin is responsible for perform operator login routine.
 * In java script it should be called:<b>PosDoOperatorLogin(remote, id, initFloat, simulator)</b>
 * @param autoLogin - String - Optional, "true" to indicate auto login (default:"false"). [1.20]
 * @param remote - String - Optional, "true" to indicate a remote login (default:"false").
 * @param id - String - Optional, operator id for remote login (used only if remote is "true", default:none).
 * @param initFloat - String - Optional, initial float (used only if remote is "true", default:0).
 * @param simulator - String - Optional, "true" to indicate that is in simulator mode (default:"false").
 * @success Operator was logged in successfully.
 * @failure <i>Register not Opened</i> - Cannot log into a closed register.
 * @failure <i>User Already logged</i> - Cannot log into a register that have an already logged user.
 * @failure <i>Blocked POS</i> - Cannot log in a blocked POS.
 * @failure <i>onLoginFinalize() failed</i> - hook returned false.
 * @failure <i>onLoginOperator() failed</i> - hook returned false.
 * @failure <i>User Cancelled</i> - User cancelled when calculator was shown.
 * @failure <i>onConfirmLogin() failed</i> - hook returned false.
 * @failure <i>Cannot set POS state</i> - failed while trying to set POS state.
 * @hook <i>onLoginOperator()</i> - called after open state confirmed, before any proper execution.
 * @hook <i>onInitialFloat()</i> - called to verify initial float.
 * @hook <i>onConfirmLogin()</i> - called to confirm log in.
 * @hook <i>onLoginFinalize()</i> - called when an error ocurred.
 * @sessioncontext <i>"workingMode"</i> - Read to get the working mode.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_LOGINFLOAT: Prompt message asking initial float.\n
 *	MSG_BC_INIT_FLOAT_LIMIT: Typed initial float amount is greater than defined limit.\n
 *	MSG_BC_OPERLOGIN: Message confirming log-in.\n
 *	MSG_BC_INVLOGINOP: Error message not opened log-in.\n
 *	MSG_BC_INVLOGINLG: Error message operator already logedd-in.\n
 *	MSG_BC_INVLOGINBK: Error message POS time blocked.\n
 * @since 1.17-
 */
function PosDoOperatorLogin(autoLogin, remote, id, initFloat, simulator) {
	var cmd = "PosDoOperatorLogin";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [autoLogin, remote, id, initFloat, simulator]);
}


/**
 * @brief This function implements the BC,Business Component: <b>PosOperatorLogout</b>.
 *
 * Persistence: <b>Persisted</b>\n
 * This BC is responsible for perform the operator logout.
 * @param autoLogout - bool - indicates if the operator will be logged out as part of an auto-logout/auto-login operation.
 * @param isSeamless - bool - indicates if the function is being called from within a Seamless (Automatic Change Business Day) operation.
 * @success Logout performed successfully.
 * @failure	<i>Invalid POS state</i> - In order to perform a logout the POS state must be either opened with a logged in operator or blocked with a logged in operator.\n
 * @sessioncontext <i>PosOperatorLogout_Failure</i> - Indicates the failure string with the message to be shown in a dialog window, in case of a invalid state of POS.
 * @sessioncontext <i>PosOperatorLogout_Result></i> - Indicates the result string. Not used.
 * @remarks
 *
 * Property Messages:\n
 *	 MSG_BC_INVLOGOUT: When the POS state does not allow a logout operation.\n
 *	 MSG_BC_OPERLOGOUT: When the status is changed. This message is shown in both Operator Display and Costumer Display.
 * @since 1.17-
 */
function cPosOperatorLogout(autoLogout, isSeamless) {
	var cmd = "cPosOperatorLogout";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [autoLogout, isSeamless]);
}


/**
 * @brief This function implements the BC,Business Component: <b>PosDoOperatorLogout_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosDoOperatorLogout_CSL is responsible for perform the operator logout routine, when it's in remote mode do not prompt for confirmation.
 * In java script it should be called:<b>PosDoOperatorLogout_CSL(remote)</b>
 * @param remote - String - Optional, "true" to indicate a remote logout (default:"false").
 * @success .
 * @failure <i>Transaction in progress</i> - Cannot logout operator when a transaction is in progress.
 * @failure <i>Cannot retrieve POS state</i> - Error getting POS state.
 * @failure <i>Operator not Logged</i> - There is no user logged.
 * @failure <i>onConfirmLogout() failed</i> - hook returned false.
 * @failure <i>Cannot set POS state</i> - Error setting POS state.
 * @failure <i>onLogoutFinalize() failed</i> - hook returned false.
 * @hook <i>onCheckFileForRemoteDelete()</i> - invoked before delete the file from the WayStation.
 * @sessioncontext <i>"workingMode"</i> - Read to get the working mode.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_OPERLOGOUT: Message confirming log-off.\n
 *	MSG_BC_INVLOGOUT: Error message invalid log-out.\n
 * @since 1.18
 */
function PosDoOperatorLogout_CSL(remote) {
	var cmd = "PosDoOperatorLogout_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	if(remote == undefined) {
		// Default value
		remote = "false";
	}

	var ret = false;
	var hlp	 = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  =  Number(xmlPOS.@state);

	var ctx = new SessionContext;
	// workingMode
	var podMode = ctx.get("workingMode");

	if ((podMode == "cashier") || (podMode == "both")) {
		var result = PosCheckSalesBeforeClose("CDC");
		if (result == false) {
			if(typeof(onConfirmProceed) == "function") {
				result = onConfirmProceed();
			}
			if (result == false) {
				return(result);
			}
		}
	}

	switch(state) {
	case POS_STA_OPLOGGED:
	case POS_STA_BLOCKOP:
		var name   = xmlPOS.Operator.@name;
		// Confirms logout
		var sConfMsg=hlp.getSysMessage("MSG_BC_LOGOUTCONF",name);
		// In remote mode is not necessary to prompt for confirmation.
		if(remote == "true" || PosShowConfirmationMessage(sConfMsg,"MSG_YES","MSG_NO")) {

			if (podMode != "orderTaker") {
			   ret = true;
			}

			// POD
			cmd = "cPosOperatorLogout";

			if (executeBC(cmd, ["false"])) {
				if(remote && PosCheckSessionProperty("POD","CSO")) {
					PosActivateScreenSaver(1);
				}
				if (ret && remote == "false") {
					PosOpenCashDrawer(false);
 			    }
				ret = true;
			} else {
				ret = false;
			}
		}
		break;
	default:
		PosShowMessage("MSG_BC_INVLOGOUT");
		break;
	}
	//if(("HOT" == pod) || (bRemote && (("CSO" == pod) || ("CK" == pod) || ("CKD" == pod))) || ((("DT" == pod) || ("WT" == pod)) && (ctx.get("workingMode") == "orderTaker"))) {
	//	return(false);
	//}
	return(ret);
}



/**
 * @brief This function implements the BC,Business Component: <b>PosDoRemoteDrawerChange</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosDoRemoteDrawerChange is responsible for perform the actions needed to remotely drawer change.
 * In java script it should be called:<b>PosDoRemoteDrawerChange(nbrPOS, timeout)</b>
 * @param nbrPOS - String - Number of POS to perform drawer change.
 * @param timeout - String - Optional, time to execute the command in miliseconds default is 10000ms.
 * @success Remotely drawer change request successfully sent.
 * @failure <i>Send Request Error</i> - Error sending drawer change request.
 * @sessioncontext <i>"reportRemDrwChg"</i> - Set as a XML formated parameter.
 * @sessioncontext <i>"remDrwrChgError"</i> - on error sets error code [1.18]
 * @todo Check return codes, when missing parameter.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_PROCESSING: Shown while processing the request.\n
 * @since 1.17-
 */
function PosDoRemoteDrawerChange(nbrPOS, timeout) {
	var cmd = "PosDoRemoteDrawerChange";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var result = executeBC(cmd, [nbrPOS, timeout]);
	if (!result) {
		var ctx = new SessionContext;
		var rsp = ctx.get('remDrwrChgError');
		switch (rsp) {
			case '0':
				// TLOGRSP_ACK
				return true;
			case '3':
				// TLOGRSP_INVALIDPOS
				ctx.set('remDrwrChgErrorMsg', 'MSG_BC_REMDRWRCHG_INVALIDPOS');
				return false;
			case '1':
				// TLOGRSP_TIMEOUT
				ctx.set('remDrwrChgErrorMsg', 'MSG_BC_REMDRWRCHG_TIMEOUT');
				return false;
			case '4':
				// TLOGRSP_INVALIDTLOG
				ctx.set('remDrwrChgErrorMsg', 'MSG_BC_REMDRWRCHG_INVALIDTLOG');
			case '17':
			default:
				// TLOGRSP_CANNOTDRAWERCHANGE
				ctx.set('remDrwrChgErrorMsg', 'MSG_BC_REMDRWRCHG_ERROR');
				return false;
		}
	}
	return result;
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoRemoteLogin</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosDoRemoteLogin is responsible for perform actions needed to remotely login in a register.
 * In java script it should be called:<b>PosDoRemoteLogin(nbrPOS, timeout)</b>
 * @param nbrPOS - String - Number of POS to perform the login.
 * @param timeout - String - Optional, time to execute the command in miliseconds default is 10000ms.
 * @success Login request successfully sent.
 * @failure <i>Send Request Error</i> - Error sending login request.
 * @failure <i>onLoginRemOperator() failed</i> - hook returned false.
 * @sessioncontext <i>"reportRemLogin"</i> - Set as a XML formated parameter.
 * @hook <i>onLoginRemOperator()</i> - Called before BC execution.
 * @todo Check return codes, when missing parameter.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_PROCESSING: Shown while processing the request.\n
 * @since 1.17-
 */
function PosDoRemoteLogin(nbrPOS, timeout) {
	var cmd = "PosDoRemoteLogin";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [nbrPOS, timeout]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoSWCloseDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosDoSWCloseDay_CSL is responsible for perform the actions needed to store widely close the day.\n
 * The action can be done in forced or non forced modes. In forced mode, all POS in the store are\n
 * commanded to close while in non forced mode, only when all POS are able to close the action is commanded.\n
 * In java script it should be called:<b>PosDoSWCloseDay_CSL(timeout, isForced)</b>
 * @param timeout - String - Optional, time to execute the command in miliseconds (default is 15000ms).
 * @param isForced - String - Optional, "true" or "false" (default).
 * @success store wide close day was performed.
 * @failure <i>onSWEndOfDay() failed</i> - hook returned false.
 * @failure <i>Cannot get POS state</i> - Error retrieving POS state.
 * @failure <i>User Cancelled</i> - User cancelled when confirming to close all registers.
 * @failure <i>User Logged</i> - Cannot close a register that has a user logged in.
 * @failure <i>Day Close confirmation</i> - User cancelled Day Close confirmation.
 * @failure <i>User not Authorized</i> - User not authorized to perform Store Wide Close Day.
 * @failure <i>WayStation not available</i> - WayStation not available or error calling adaptor.
 * @hook <i>onSWEndOfDay()</i> - called before BC start.
 * @sessioncontext <i>"dayCloseXML"</i> - set with the xml for day close.
 * @sessioncontext <i>"dayOpenBusinessDay"</i> - set as the business day being checked for opening.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_SWOPLOGGED: Shown when confirming to close all other registers except this one, cause there is a user logged in (forced mode).\n
 *	MSG_BC_OPLOGGED: Shown if trying to close a register that has a user logged in (non forced mode).\n
 *	MSG_BC_ENDDAYCONF: Shown in the close day confirmation.\n
 *	MSG_BC_SWCOMMUNIC: Shown when WayStation is not available for Store Wide Command.\n
 *	MSG_BC_ERRSWCLOSE: Shown when unable to close all registers in the store.\n
 * @since 1.18
 */
function PosDoSWCloseDay_CSL(timeout, isForced) {
	var ctx=new SessionContext;
	var cmd = "PosDoSWCloseDay_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	var localPOS = true;
  var dayOpen = null;
  // Parameters
	var	pisForced = "false";
  var	ptimeout = "15000";
  var localClose = true;
  if (timeout != undefined && timeout != "true" && timeout != "false") {
  	ptimeout = timeout;
  }
  if (isForced != undefined && (isForced == "true" || isForced == "false")) {
    	pisForced = isForced;
  }
  // Get Date Format - Store-DB-Xml
 	var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
  // Get Business Date
	var hlp = new BusinessObjectHelper;
 	var registerBusinessDay = "00000000";
 	var businessDay = new XML(hlp.getBusinessDate("false"));
  if (businessDay.@Register != "") {
    registerBusinessDay = businessDay.@Register;
  }
  // Get State POS
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);
	switch(state) {
	case POS_STA_OPENED:
	case POS_STA_BLOCKED:
 		result = true;
		break;
	case POS_STA_CLOSED:
 		localPOS = false;
		break;
	default:
	  if ((false==PosVerifyAutoLogonJS())||(pisForced == "true")) {
    	if (!PosShowConfirmationMessage("MSG_BC_SWOPLOGGED","MSG_YES","MSG_NO")) {
    		result = false;
    	} else {
			localClose = false;
		} 
    } else {
   		PosShowMessage("MSG_BC_OPLOGGED");
   		result = false;
   	}
		break;
	}
	if (result == true || (pisForced == "true" && result == true)) {
		//  Date Format
		var businessDate = API.formatDate(registerBusinessDay, fmtDate);
		var sConfMsg=hlp.getSysMessage("MSG_BC_ENDDAYCONF",businessDate);
		if(!PosShowConfirmationMessage(sConfMsg,"MSG_YES","MSG_NO")) {
			result = false;
		} else {
			if(!PosGetAuthorization("manager")) {
			result = false;
			}
		}
	}
	if (result) {
		var posMode = "updateStatus";
		result = cPosSWCloseDay(ptimeout, pisForced);
		if (result == false) {
			var failMessage=getLastFail("cPosSWCloseDay");
			if(null!=failMessage) {
				PosShowMessage(failMessage);
			}
			posMode = "updateStatus";
		}
		else {
			// Local Close Day
			if (localPOS == true) {
				if (pisForced == "true") {
					posMode = "forced";
				} else {
					posMode = "storewide";
				}
			}
		}
		if (localClose) {
			result = cPosEndOfDay(posMode);
			if (false==result){
				PosShowMessage(getLastFail("cPosEndOfDay"));
			}
		}
		result=true;	// SQC-1590 - must return true or the workflow engine stops the workflow execution
	}
	adjustView("dayCloseXML", ctx, String(xmlPOS.@ID));
	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoSWOpenDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC performs the actions needed to open the day for the store widely.\n
 * The action can be done in forced or non forced modes. In forced mode, all POS in the store are\n
 * commanded to open while in non forced mode, only when all POS are able to open the action is commanded.\n
 * This BC can be activated either locally, to start the process of opening the day for the store, or\n
 * remotelly, to locally perform the day opening.\n
 * In java script it should be called:<b>PosDoSWOpenDay_CSL(timeout, isForced)</b>
 * @param timeout - String - Optional, time to execute the command in miliseconds (default is 15000ms).
 * @param isForced - String - Optional, "true" or "false"(default).
 * @success Store wide open day was performed.
 * @failure <i>onSWDayOpen() failed</i> - hook returned false.
 * @failure <i>Cannot get POS state</i> - failed to retrieve POS state.
 * @failure <i>POS is not Closed</i> - Day is already open.
 * @failure <i>User Cancelled</i> - User cancelled calculator when asking for date to open the day.
 * @failure <i>User not Authorized</i> - User is not authorized to perform Store Wide Open day.
 * @failure <i>Communication Error</i> - WayStation is not available.
 * @hook <i>onSWDayOpen()</i> - called before BC start.
 * @sessioncontext <i>"dayOpenXML"</i> - set with the xml for day open.
 * @sessioncontext <i>"dayOpenBusinessDay"</i> - set as the business day being checked for opening.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_SWALREADYOPEN: Shown when confirming to open all other registers, except this one, cause its already opened (only in forced mode).\n
 *	MSG_BC_ALREADYOPEN: Shown if day is already opened (only when not in forced mode).\n
 *	MSG_BC_DAYOPENCONF: Shown when confirming to open day or type a new date.\n
 *	MSG_BC_INVBUSDATE: Shown when invalid business date entered (only for non forced mode).\n
 *	MSG_BC_SWINVDATE: Shown when invalid business date entered (forced mode, maybe the date is valid elsewhere).\n
 *	MSG_BC_SWCOMMUNIC: Way Station is not available for Store Wide Command.\n
 *	MSG_BC_ERRSWOPEN: Shown when unable to open all registers in the store.\n
 * @since 1.18
 */
function PosDoSWOpenDay_CSL(timeout, isForced) {
	var ctx=new SessionContext;
	var cmd = "PosDoSWOpenDay_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var result = true;
  var dayOpen = null;
  // Parameters
	var	pisForced = "false";
  var	ptimeout = "15000";
  if (timeout != undefined && timeout != "true" && timeout != "false") {
  	ptimeout = timeout;
  }
  if (isForced != undefined && (isForced == "true" || isForced == "false")) {
    	pisForced = isForced;
  }
  // Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);
	switch(state) {
	case POS_STA_CLOSED:
 		result = true;
		break;
	default:
	  if (pisForced == "true") {
    	if (!PosShowConfirmationMessage("MSG_BC_SWALREADYOPEN","MSG_YES","MSG_NO")) {
    		result = false;
    	}
    } else {
		// SQC-1625
  		//PosShowMessage("MSG_BC_ALREADYOPEN");
  		//result = false;
    }
		break;
	}
  if (result) {
    // Gets Date Format - Store-DB-Xml
   	var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
    // Gets Date System
  	var wdate  = new Date();
  	var wyear  = setZerosOnLeft(wdate.getFullYear(),4);
  	var wmonth = setZerosOnLeft(wdate.getMonth() + 1,2);
  	var wday   = setZerosOnLeft(wdate.getDate(),2);
  	var sdate  = wyear + wmonth + wday;
    var sMsg=hlp.getSysMessage("MSG_BC_DAYOPENCONF",fmtDate);
 		if (PosAskDate(sdate, sMsg, 2)) {
   		dayOpen = getLastSuccess("PosAskDate");
   		if(!PosGetAuthorization("manager")) {
    		result = false;
    	}
    } else {
		result = false;
  	}
	if (result) {
		result = cPosSWOpenDay(dayOpen, ptimeout, pisForced);
		if (result == false) {
			PosShowMessage(getLastFail("cPosSWOpenDay"));
		}
		CSL_dbglog(0, SRC_BC_REGISTER, cmd, "cPosSWOpenDay result : " + result + " state: " + state);
		CSL_dbglog(0, SRC_BC_REGISTER, cmd, "dayOpenXML: " + ctx.get("dayOpenXML"));
		switch(state) {
		case POS_STA_CLOSED:
			// SQC-1625 - check POS state of other POS (if at least one is opened then try to open local too
			var opendayxml = new XML(ctx.get("dayOpenXML"));
			if(pisForced=="true"){
				var rootPosList=opendayxml.params.param.value.struct.member.(name=="POSLIST").value.array.data;

				var result=false;
				for each (item in rootPosList.value) {
					var varState = item.struct.member.(name=="State").value.string;
					if(("Opened"==varState)||("Logged"==varState)) {
						result=true;	// at least one POS is opened -> try to open the local (even if opened POS is in incorrect BD)
					}
				}
			}
			else{
				var canOpenClose=opendayxml.params.param.value.struct.member.(name=="CanOpenClose").value.i4;
				CSL_dbglog(0, SRC_BC_REGISTER, cmd, "canOpenClose: " + canOpenClose);
				if(canOpenClose=="1"){
					result = true;
				}
				else{
					result = false;
				}
			}		
			break;
		default:
			// SQC-1625 - call cPosDayOpen only to update session variable
			//result=true;
			break;
		}
		var posMode;
		if (result == false) {
			posMode = "updateStatus";
		} else {
			// Local Open Day
			if (pisForced == "true") {
				posMode = "forced";
			} else {
				posMode = "storewide";
			}
		}
		result = cPosDayOpen(posMode, dayOpen);
		if (false==result){
			PosShowMessage(getLastFail("cPosDayOpen"));
		}
		else {
			// check automatic login
			if(false==PosVerifyAutoLogonJS()) {
				var opId=hlp.findParamInSectionConfig("AnonymousOperatorID","OperationMode");
				var opName=hlp.findParamInSectionConfig("AnonymousOperatorName","OperationMode");
				var initialFloat=new BigDecimal(0);
				if((null==opId)||(""==opId)||("0"==opId)) {
					// parameter error
					PosShowMessage("MSG_BC_INVOPERATORID");
				}
				else {
					if((null==opName)||(""==opName)) {
						// parameter error
						PosShowMessage("MSG_BC_INVOPERATORNAME");
					}
					else {
						cPosOperatorLogin(opId,initialFloat,"true",opName);
					}
				}
			}
		}
		adjustView("dayOpenXML", ctx, String(xmlPOS.@ID));
		result=true;
	}
  }
 	return(result);
}

/**
 * @brief This function updates open/close status of session variable content
 *
 * @param - sessionName - session variable name which content will be updated (dayOpenXML or dayCloseXML)
 * @return rval - if it's true the caller is allowed to continue
 * @since 1.19
 */
function adjustView(sessionName, ctx, POSval){
	//var POSval = String(xmlPOS.@ID);
	var ValueFlag = ctx.get("intValueFlag");
	var Amount = ctx.get("tdAmount");
	var Reason = ctx.get("intValueReason");
	var POSStates = ctx.get("intPOSStates");
	var xml = ctx.get(sessionName);
	var openxml = new XML(xml);

	var rootPosList 	= openxml.params.param.value.struct.member.(name=="POSLIST").value.array.data;

	for each (var item in rootPosList.value) {
		var varPosId  		= String(item.struct.member.(name=="PosId").value.string);
		var varState = "Unknown";
		if(POSval == varPosId){
			item.struct.member.(name=="Online").value.i4				 = POSStates;
			item.struct.member.(name=="CanOpenClose").value.i4			 = ValueFlag;
			item.struct.member.(name=="Reason").value.i4				 = Reason;
			switch(Number(POSStates)){
				case 0:
					varState = "Closed";
				break;
				case 1:
					varState = "Opened";
				break;
				case 2:
					varState = "Logged";
				break;
				case 3:
					varState = "Blocked";
				break;
				case 4:
					varState = "Blocked Operator";
				break;
				default:
					varState = "Unknown";
				break;
			}
			item.struct.member.(name=="State").value.string				 = varState;
			item.struct.member.(name=="OpeningReading").value.string	 = Amount;
		}
	}
	ctx.set(sessionName,openxml.toString(),false);
}

/**
 * @brief This function implements the BC,Business Component: <b>cPosEndOfDay</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC is responsible for execute the end of day routine. If the POS state is opened or blocked, the business day is ended.
 * Any other status will make this BC return false.
 *
 * @param closeMode - String - POS close mode. The values can be:\n
 *							"storewide": open POS in Store Wide mode;\n
 *							"offline": open POS in Offline mode;\n
 *							"forced": open POS in Store Wide Forced mode.
 * @success Business day ended successfully.
 * @failure <i>Invalid parameter</i> - The closeMode parameter must be one of the three strings: "storewide", "offline" or "forced".
 * @failure <i>Invalid POS state</i> - The POS state must be either Opened or Blocked.
 * @sessioncontext <i>KEY_CPOSENDOFDAY_FAIL</i> - Key to indicate the failure string with the message to be shown in a dialog window,
 * in case of a failure when trying to end a business day.
 * @sessioncontext <i>KEY_CPOSENDOFDAY_RESULT</i> - Key to indicate a string in case of success. Not used.
 * @remarks
 *
 * Property Messages:\n
 *	MSG_BC_NOTOPENED: Error message informing day already closed.\n
 *	MSG_BC_OPLOGGED: Error message informing there is a operator loged-in.\n
 * @since 1.19
 */
function cPosEndOfDay(closeMode) {
	var cmd = "cPosEndOfDay";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [closeMode]);
}

/**
 * @brief This function implements the BC,Business Component: <b>cPosEndOfDayVerify</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC verifies if it is possible to end a Business Day. If the POS state is opened or blocked, it is possible to end a Business Day.
 * Any other status will make this BC return false.
 *
 * @success Business Day can be ended.
 * @failure <i>Invalid POS state</i> - The POS state must be either Opened or Blocked for success.
 * @remarks
 *
 * This BC needs revision. It aways returns false, regardless of the POS state. It should return true when the POS state is "opened" or "blocked".
 * @since 1.17-
 */
function cPosEndOfDayVerify() {
	var cmd = "cPosEndOfDayVerify";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosEndOfDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosEndOfDay_CSL is responsible for execute the end of day routine!\n
 * The action can be done in a verify mode, when only consistency is performed,\n
 * or in a default execution mode when the end of day is actually performed.\n
 * It is also possible to inform the necessary security level to perform the action.\n
 * In java script it should be called:<b>PosEndOfDay_CSL(closeMode, level)</b>
 * @param closeMode - String - Optional, "verify" or "execute"(default).
 * @param level - String - Optional, "manager"(default),"supervisor","system","null" or "remote".\n
 *									 "null" indicates that no authorization is required and\n
 *									 "remote" that the authorization was granted remotely.\n
 * @success end of day was performed or can be performed (in case of verify mode).
 * @failure <i>onEndOfDay() failed</i> - hook returned false.
 * @failure <i>Failed to get POS state</i> - failure retrieving POS state.
 * @failure <i>Grand Total Request fail</i> - failed to get Grand Total value.
 * @failure <i>User Cancelled</i> - user cancelled calculator when asked to confirm close day.
 * @failure <i>Not Authorizerd</i> - user is not authorized to perform end of day.
 * @failure <i>Serialization Error</i> - Error serializating end of day data.
 * @hook <i>onEndOfDay(closeMode, level)</i> - called before BC start.
 * @hook <i>onDayClosed(closeMode, level)</i> - called if day was successfully closed. [1.18]
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_ENDDAYCONF: Prompt message to operator confirming closing date.\n
 *	MSG_BC_NOTOPENED: Error message informing day already closed.\n
 *	MSG_BC_OPLOGGED: Error message informing operator still loged-in.\n
 * @since 1.18
 */
function PosEndOfDay_CSL(closeMode, level) {
	var cmd = "PosEndOfDay_CSL";
	var result = false;
	var openMode;
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	
	if ((closeMode == "verify")|| ((level != "remote") && (level != "forced"))) {
		var ret = PosCheckSalesBeforeClose("EOD");
		if (ret == false) {
			swReason=SWREASON_OPENORDERS;

			// Sets adaptor tlog
			npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_FLAG,ret);
			npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_REASON,swReason);
			return(ret);
		}
	}

	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);
	var reason = SWREASON_OK;

	switch(state) {
		case POS_STA_CLOSED:
			if (level != "remote") {
				PosShowMessage("MSG_BC_NOTOPENED");
			}
			if (closeMode != "verify") {
				reason=SWREASON_ALREADYCLOSED;
			}
			result = false;
			// set the flag "can close"
			npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_FLAG,result);
			// set the reason
			npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_REASON,reason);
			break;
		case POS_STA_OPENED:
		case POS_STA_BLOCKED:
			// Parameters
			if (closeMode == undefined) {
				openMode = "execute";
			}
			if (level == undefined) {
				level = "manager";
			}

			if (closeMode == "verify") {
				// check only - ADPTLOG_INT_VALUE_FLAG and ADPTLOG_INT_VALUE_REASON are set by the cPosEndOfDayVerify function
				result = cPosEndOfDayVerify();
			} else {
				// close day
				if ((level != "remote") && (level != "forced") && (level != "null")) {
					// get date information
					var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
					var registerBusinessDay = "00000000";
					var businessDay = new XML(hlp.getBusinessDate("false"));
					if (businessDay.@Register != "") {
						registerBusinessDay = businessDay.@Register;
					}
					//  format date
					var businessDate	= API.formatDate(registerBusinessDay, fmtDate);
					var sConfMsg=hlp.getSysMessage("MSG_BC_ENDDAYCONF",businessDate);

					// confirmation
					if(PosShowConfirmationMessage(sConfMsg,"MSG_YES","MSG_NO")) {
						//  manager auth
						result = PosGetAuthorization("manager");
					} else {
						result = false;
					}
				} else {
						// remote or forced
						result = true;
				}

				if (result == true) {
					var posMode = "offline";
					if (level == "remote") {
						posMode = "storewide";
					}
					if (level == "forced") {
						posMode = level;
					}
					// ADPTLOG_INT_VALUE_FLAG and ADPTLOG_INT_VALUE_REASON are set by the cPosEndOfDay function
					result = cPosEndOfDay(posMode);
					if (result == false) {
						PosShowMessage(getLastFail("cPosEndOfDay"));
					}
				}
			}
			break;
		default:
			if(!PosNotATransactionInProgress(true)) {
				result = false;
				reason=SWREASON_SALEMODE;
				// set the flag "can close"
				npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_FLAG,result);
				// set the reason
				npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_REASON,reason);
			}
			else {
				if(false==PosVerifyAutoLogonJS()) {
					result = true;
					if (closeMode == "verify") {
						// set the flag "can close"
						npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_FLAG,1);
						// set the reason
						npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_REASON,reason);
					}
					else {
						var posMode = "offline";
						if (level == "remote") {
							posMode = "storewide";
						}
						if (level == "forced") {
							posMode = level;
						}
						// ADPTLOG_INT_VALUE_FLAG and ADPTLOG_INT_VALUE_REASON are set by the cPosEndOfDay function
						result = cPosEndOfDay(posMode);
						if (result == false) {
							PosShowMessage(getLastFail("cPosEndOfDay"));
						}
					}
				}
				else {
					result = false;
					reason=SWREASON_OPLOGGED;
					if (level != "remote") {
						PosShowMessage("MSG_BC_OPLOGGED");
					}
					// set the flag "can close"
					npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_FLAG,result);
					// set the reason
					npAdpTlog_RequestSrv(NPSRVTLOG_API_SET_STATE,ADPTLOG_INT_VALUE_REASON,reason);
				}
			}
			break;
	}

 	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosGetLoggedInPOS</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosGetLoggedInPOS is responsible for get a list of logged-in POS in the network.
 * In java script it should be called:<b>PosGetLoggedInPOS()</b>
 * @success information retrieved and found logged-in POS.
 * @failure <i>Can not retrieve POS list</i> - Can not retrieve POS list from WayStation.
 * @sessioncontext <i>"loginDTPosition"</i> - set with the value of found logged-in POS's.
 * @since 1.17-
 */
function PosGetLoggedInPOS() {
	var cmd = "PosGetLoggedInPOS";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosLogDuplicateSwipe</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosLogDuplicateSwipe is responsible for register an audith line in tlog files when a card is swiped more than once (logs a possible fraud).
 * In java script it should be called:<b>PosLogDuplicateSwipe(result)</b>
 * @param result - String - "true" if duplicate swipe approved or "false" if refused.
 * @success Duplicate card swipe successfully logged.
 * @failure <i>Log Error</i> - Error logging duplicate card swipe.
 * @failure <i>Argument Missing</i> - result parameter is missing.
 * @since 1.17-
 */
function PosLogDuplicateSwipe(result) {
	var cmd = "PosLogDuplicateSwipe";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [result]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRemoteDetach</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosRemoteDetach is responsible for ask the WayStation to detach a POS in the network.
 * In java script it should be called:<b>PosRemoteDetach(nbrPOS)</b>
 * @param nbrPOS - String - Optional, POS to detach, default is current POS.
 * @success POS successfully detached.
 * @failure <i>POS is not listed</i> - POS is not listed during detach.
 * @failure <i>POS is online</i> - POS is online during detach.
 * @failure <i>Need Drawer Change</i> - Need to perform a drawer change before detach.
 * @failure <i>Drawer Change failed</i> - Remote drawer change failed during detach.
 * @failure <i>Already Detached</i> - POS is already detached.
 * @failure <i>General failure</i> - General failure during detach.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_DETACHOK: Shown if POS successfully detached.\n
 *	MSG_BC_DETACHPOSNOTFOUND: Shown if POS is not listed during detach.\n
 *	MSG_BC_DETACHPOSONLINE: Shown if POS is online during detach.\n
 *	MSG_BC_LOGOUTOP: Shown if need to perform a drawer change before detach.\n
 *	MSG_BC_DETACHDRWCHGFAILED: Shown if remote drawer change failed during detach.\n
 *	MSG_BC_DETACHALREADY: Shown if POS is already detached.\n
 *	MSG_BC_DETACHFAILED: Shown if a general failure occurred during detach.\n
 * @since 1.17-
 */
function PosRemoteDetach(nbrPOS) {
	var cmd = "PosRemoteDetach";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd, [nbrPOS]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosSignalDayOpened</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosSignalDayOpened is responsible for send a multicast message, handled mainly by production, signalizing that the store is opened.\n
 * That is, production can receive orders.\n
 * In java script it should be called:<b>PosSignalDayOpened()</b>
 * @success Multicast message indicating that day is opened was sent.
 * @failure <i>POS state retrieve Error</i> - An error occurred while trying to retrieve POS state.
 * @failure <i>onSignalDayOpened() failed</i> - hook returned false.
 * @hook <i>onSignalDayOpened()</i> - invoked before send multicast message.
 * @since 1.17-
 */
function PosSignalDayOpened() {
	var cmd = "PosSignalDayOpened";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

/**
 * @brief This BC starts a special transaction (waste,refund)
 *
 * @return rval - true if allowed to continue
 * @since 1.17-
 */
function StartSpecialTrx_CSL(level,singleSignOn,kind,message,destination) {
	var cmd = "StartSpecialTrx_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	// Should be in Sale mode (operator logged and not alreday performing a transaction
	if(!PosIsInSaleMode() || !PosNotATransactionInProgress(false)) {
		return(false);
	}

	// Should not have a Wave in progress
	if(PosCheckTransactionKind(ACC_OT_TAB) && PosCheckTransactionSubKind(ACC_OT_WAVE)) {
		PosShowMessage("MSG_BC_TSS_WAVE_IN_PROGRESS");
		return(false);
	}
	
	if(PosCheckTransactionKind(ACC_OT_TAB) && PosCheckTransactionSubKind(ACC_OT_WAVE_ADJUSTMENT)) {
		PosShowMessage("MSG_BC_TSS_ADJ_IN_PROGRESS");
		return(false);
	}
	
	var ctx=new SessionContext;
	switch(Number(ctx.get("transactionSaleType"))) {
	case 1:
		PosShowMessage("MSG_BC_REFUND_IN_PROGRESS");
		break;
	case 2:
		PosShowMessage("MSG_BC_WASTE_IN_PROGRESS");
		break;
	default:
		if(!PosGetAuthorization(level,singleSignOn)) {
			return(false);
		}
	 	PosSetTransactionKind(kind);
		PosShowScreen(ctx.get("baseScreenId"));
		PosDisplayText(message,destination);
	}
	return(true);
}

/**
 * @brief This BC shows/changes the POD Filter used in reports
 *
 * @return rval - true if allowed to continue
 * @since 1.17-
 */
function PODFilter_CSL(change) {
	var cmd = "PODFilter_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	const reportType=["ALL","FC","DT","WT"];
	const reportButton=["bitmap|postypeall.png","bitmap|postypefc.png","bitmap|postypedt.png","bitmap|postypewt.png"];

	var i=0;
	// Loops up to length because the very first time reportPOD might not be set!
	for(;i < reportType.length;i++) {
		if(PosCheckSessionProperty("reportPOD",reportType[i])) {
			break;
		}
	}
	if("true"==change) { // Next
		i++;
	}
	if(i >=reportType.length) {
		i=0;
	}
	// either reportPOD was not set or changing from the last to the first...
	PosChangeButtonProperties(0,reportButton[i]);
	if("true"==change) { // Next
		PosSetReportScope("CONSOLIDATED",reportType[i]);
	}
	return(true);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoSkipCarJS</b>
 *
 * This BC put skip Car!\n
 * In a workflow sequence it is called:<b>PosDoSkipCarJS</b>\n
 * In java script it should be called:<b>PosDoSkipCarJS</b>\n
 * @return rval - true if possible
 * @since 1.17-
 */
function PosDoSkipCar_CSL() {
	var cmd = "PosDoSkipCar_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	if(!PosIsInSaleMode() || !PosNotATransactionInProgress(false)) {
		return(false);
	}
	// Sale not started as yet...
	if(!PosCheckCashDrawer()) {
		// Drawer open
		PosShowMessage("MSG_BC_DRAWER_OPENED");
		return(true);
	}
	if(PosCheckSessionProperty("POD","DRIVE_THRU")) {
		if(!PosShowConfirmationMessage("MSG_BC_DLG_SKIPCAR","MSG_OK","MSG_CANCEL")) {
			return(false);
		}
		/* NPS-9431 */       
		var ctx=new SessionContext;
		if(ctx.get("CODRouting") == null) {
			ctx.set("CODRouting","");
		}
		PosDoSkipCar();
	}
	var ctx=new SessionContext;
	PosShowScreen(ctx.get("baseScreenId"));

	return(true);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosChangeBusinessDay</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * This BC executes the change business day routine!\n.\n
 * In java script it should be called:<b>PosChangeBusinessDay()</b>
 * @success Business day changed.
 * @failure	<i>Unable to connect to way station</i> - Way station is offline, the MSG_CHGDAY_WAYOFFLINE could be retrieved by getLastFail.
 * @failure	<i>Wrong business day</i> - Business Day of the way station is different of the business day of the register, the MSG_CHGDAY_WRONGBUSINESSDAY could be retrieved by getLastFail.
 * @failure	<i>Operation not allowed</i> - The operator is logged, the MSG_CHGDAY_OPERATIONNOTALLOWED could be retrieved by getLastFail.
 * @failure	<i>Operation not allowed</i> - There is orders in progress, the MSG_CHGDAY_ORDERSINPROGRESS could be retrieved by getLastFail.
 * @since 1.18
 */
function PosChangeBusinessDay() {
	var cmd = "PosChangeBusinessDay";
	var retVal=true;
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	// NPS-12375 - verify if Way station is online
	var cmd = "PosWayOnline";
	if(!executeBC(cmd)) {
		return(false);
	}

	var hlp=new BusinessObjectHelper;
	var businessDay = new XML(hlp.getBusinessDate("false"));
	var registerBusinessDay = businessDay.@Register;

	if(registerBusinessDay.length() == 0) {
		return(false);
	}

	var year = registerBusinessDay.substr(0,4);
	var month = registerBusinessDay.substr(4,2) - 1;
	var day = registerBusinessDay.substr(6,2);

	var date = new Date(year, month, day);
	date.setDate(date.getDate()+1);

	var new_year = API.setZerosOnLeft(date.getFullYear(), 4);
	var new_month = API.setZerosOnLeft((date.getMonth() + 1), 2);
	var new_date = API.setZerosOnLeft(date.getDate(), 2);
	var string_date = new_year + new_month + new_date;

	if(!cPosEndOfDay("offline")) {
		return(false);
	}

	if(!cPosDayOpen("offline", string_date)) {
		return(false);
	}
	else {
		var cmd = "PosExecuteChangeDay";
		if(!executeBC(cmd)) {
			CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Failed");
			retVal=false;
		}
		
		// check automatic login
		if(false==PosVerifyAutoLogonJS()) {
			var opId=hlp.findParamInSectionConfig("AnonymousOperatorID","OperationMode");
			var opName=hlp.findParamInSectionConfig("AnonymousOperatorName","OperationMode");
			var initialFloat=new BigDecimal(0);
			if((null==opId)||(""==opId)||("0"==opId)) {
				// parameter error
				PosShowMessage("MSG_BC_INVOPERATORID");
			}
			else {
				if((null==opName)||(""==opName)) {
					// parameter error
					PosShowMessage("MSG_BC_INVOPERATORNAME");
				}
				else {
					cPosOperatorLogin(opId,initialFloat,"true",opName);
				}
			}
		}
	}

	return (retVal);
}

/**
 * @brief This function implements the Business Component: <b>cPosSWOpenDay</b>.
 *
 * This BC performs the actions needed to open the day for the store widely. It opens all POS except the local.\n
 * The action can be done in forced or non forced modes. In forced mode, all POS in the store are\n
 * commanded to open while in non forced mode, only when all POS are able to open the action is commanded.\n
 * In a workflow sequence it is called:<b>cPosSWOpenDay $date $timeout $isForded</b>\n
 * In java script it should be called:<b>cPosSWOpenDay(date,timeout,isForded)</b>\n
 *
 * @param date - string - (mandatory) - the business day to perform the store wide open day\n
 * @param timeout - string - (optional) - time to execute the command in miliseconds (default is 15000ms)\n
 * @param isForded - string - (optional) - Forced mode. "true" or "false"(default)\n
 * @success Business Day of all POS in the store (according to isForced parameter) opened successfully.
 * @failure	<i>POS local already open</i> - The POS local is already open and the mode is non forced.
 * @failure	<i>Waystation not available</i> - Way Station is not available for Store Wide Command.
 * @failure <i>Unable to open all registers in the store</i>
 * @sessioncontext <i>Failure</i> - returns one of the property messages:\n
 * MSG_BC_ERRSWOPEN, MSG_BC_ALREADYOPEN or MSG_BC_SWCOMMUNIC (see details below).\n
 * The message can be obtained through getLastFail("cPosSWOpenDay") in javascript, after calling this BC.
 * @sessioncontext <i>Success</i> - not used.
 * @remarks
 *
 * Property Messages:
 *	 MSG_BC_ALREADYOPEN: Shown when local POS is already opened and the mode is non forced.\n
 *   MSG_BC_SWCOMMUNIC: Way Station is not available for Store Wide Command.\n
 *   MSG_BC_ERRSWOPEN: Shown when unable to open all registers in the store.\n
 *
 * @since 1.18
 */
function cPosSWOpenDay(date, timeout, isForced) {
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var cmd = "cPosSWOpenDay";
	return executeBC(cmd,[date, timeout, isForced]);
}

/**
 *
 * @brief This function implements the Business Component: <b>cPosSWCloseDay</b>.
 *
 * This BC performs the actions needed to store widely close the day. It closes all open POS, except the local.\n
 * The action can be done in forced or non forced modes. In forced mode, all POS in the store (except the local) are\n
 * commanded to close while in non forced mode, only when all POS are able to close the action is commanded.\n
 *
 * @param timeout - string - (optional) - time to execute the command in milliseconds (default is 15000ms)\n
 * @param isForded - string - (optional) - Forced mode. "true" or "false" (default)\n
 * @success Business Day of all POS in the store (according to isForced parameter) closed successfully.
 * @failure	<i>Invalid POS state</i> - there is an operator logged, or operator blocked in local POS. It returns MSG_BC_OPLOGGED in Filure Session Context.
 * @failure	<i>Open order in remote POS</i> - there is a stored order a some POS. It returns MSG_ERR_OPEN_ORDERS in Filure Session Context.
 * @failure	<i>Communication Error</i> - the Way Station is not available. It returns MSG_BC_SWCOMMUNIC in Filure Session Context.
 * @failure	<i>Syncronize Error</i> - offline store not synchronized. It returns MSG_ERR_OFFLINE_SYNC in Filure Session Context.
 * @failure	<i>Unable to close all register in the store</i>  - It returns MSG_BC_ERRSWCLOSE in Filure Session Context.
 * @sessioncontext <i>Failure</i> - returns one of the messages detailed below
 * @sessioncontext <i>Success</i> - not used
 * @remarks
 *
 * Property Messages:
 *	 MSG_BC_OPLOGGED: there is an operator logged, or operator blocked in local POS.\n
 *   MSG_ERR_OPEN_ORDERS: there is an order in progress in a remote POS
 *	 MSG_BC_SWCOMMUNIC: the Way Station is not available
 *	 MSG_ERR_OFFLINE_SYNC: offline mini-store not synchronized
 *   MSG_BC_ERRSWCLOSE: unable to close all registers in the store
 * @since 1.18
 */
 function cPosSWCloseDay(timeout, isForced) {
 	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var cmd = "cPosSWCloseDay";
	return executeBC(cmd,[timeout, isForced]);
 }

/**
 * @brief This function implements the BC,Business Component: <b>PosCashoutLock</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosCashoutLock is responsible for locking the remote POS for cashout.\n
 * In java script it should be called:<b>PosCashoutLock(POSid)</b>
 * @param lock_control - String - 1-lock / 0-unlock
 * @param persist - BOOL - persistence flag
 * @success Lock the remote POS to avoid cashouts before the operation is complete.
 * @todo check return codes.
 * @remarks
 *
 * @since 1.18
 */
function PosCashoutLock(lock_control, persist) {
	var cmd = "PosCashoutLock";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	if(false==persist) {
		PosSetSessionProperty ("bLockCashout", lock_control, "false");
	}
	else {
		PosSetSessionProperty ("bLockCashout", lock_control, "true");
	}
	npAdpTlog_RequestSrv(NPSRVTLOG_CASHOUTLOCKTIMEOUT,ADPTLOG_INT_TIMEOUT_TYPE,lock_control);
    return (true);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRemoteCashoutLock</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosRemoteCashoutLock is responsible for locking the remote POS for cashout.\n
 * In java script it should be called:<b>PosRemoteCashoutLock(POSid)</b>
 * @param POSid - String - remote POS name
 * @param lock_control - String - 1-lock / 0-unlock
 * @success Lock the remote POS to avoid cashouts before the operation is complete.
 * @todo check return codes.
 * @remarks
 * @since 1.18
 */
function PosRemoteCashoutLock(POSid, lock_control) {
	var cmd = "PosRemoteCashoutLock";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
    return executeBC(cmd, [POSid, lock_control]);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoRemoteTransferOut</b>
 *
 * This BC do the remote transfer\n
 * In a workflow sequence it is called:<b>PosDoRemoteTransferOut</b>\n
 * In java script it should be called:<b>PosDoRemoteTransferOut</b>\n
 * @return rval - true if possible
 * @since 1.18
 */
function PosDoRemoteTransferOut() {
	var cmd = "PosDoRemoteTransferOut";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var ctx=new SessionContext;
	var podMode = ctx.get("workingMode");
	if (podMode != "orderTaker") {
		var hlp=new BusinessObjectHelper;
		var xmlPOS=new XML(hlp.getPOSState());
		var state=Number(xmlPOS.@state);
		var provision;
		if(!PosGetProvision()) {
			provision=getLastFail("PosGetProvision");
			PosShowMessage(provision);
		}
		else {
			provision=getLastSuccess("PosGetProvision");
			if(Number(provision)>0) {
				PosShowMessage("MSG_TRANSFER_ALREADY_IN_PROGRESS");
			}
			else
			{
				//Validate operator logged
				if(POS_STA_OPLOGGED!=state) {
					PosShowMessage("MSG_BC_OPERATOR_NOT_LOGGED_IN");
					return(false);
				}
				var allowExcessTransfer=hlp.findParamInSectionWide("allowExcessTransfer","Cash");
				// check amount in cash
				if(PosGetCashInDrawer(allowExcessTransfer)) {
					var drawerAmount=getLastSuccess("PosGetCashInDrawer");
				}
				else {
					if(Number(drawerAmount)<0) {
						PosShowMessage("MSG_ERROR_CASH_TRANSFER");
						// error - cant continue
						return(false);
					}
				}

				// get decimal factor
				var currencyDecimals=rootStoreDB.StoreDB.StoreProfile.Localization.CurrencyDecimals;
				var factor=Math.pow(10, currencyDecimals);					

				var bLoop=true;
				while(true==bLoop) {
					// Show dialog - request amount
					var currency=rootStoreDB.StoreDB.StoreProfile.Localization.CurrencySymbol;
					var sTrfMsg=hlp.getSysMessage("MSG_AMOUNT_CASH_TRANSFER_OUT", currency, drawerAmount);
					var sCalc = PosShowCalculator(sTrfMsg, "", 0, 1, drawerAmount * factor, drawerAmount * factor);
					if(sCalc.length == 0) {
						return(false);
					}

					var tdDrawer=new BigDecimal (drawerAmount);
					var tdCalc=new BigDecimal (sCalc/factor);
					var _mask = "0";
					
					//Adapt the mask to be the same size as the input number
					var digitCount = sCalc.length-currencyDecimals;
					var extraMask = digitCount - _mask.length;
					for(var i = 0; i < extraMask; i++) {
						_mask = '#' + _mask;
					}
					
					//Adjust decimal part of the mask
					if(currencyDecimals > 0) {
						_mask += ".";
						for(var i = 0;i < currencyDecimals;i++) {
							_mask += "0";
						}
					}
					
					if(tdCalc.compareTo(tdDrawer)>0) {
						var calcAmount = trim(API.formatNumber (Number(tdCalc), _mask));
						PosShowMessage("MSG_INVALID_AMOUNT_CASH_TRANSFER_OUT", calcAmount, tdDrawer.toString());
						//return(false);
					}
					else {
						bLoop=false;
					}
				}

				// get a list of POS
				if(!PosChooseRemotePOS("5","MSG_POS_CASH_TRANSFER_OUT","MSG_POS_CONFIRM_TRANSFER_OUT")) {
					PosShowMessage("MSG_ERROR_CASH_TRANSFER");
					return(false);
				}

				// Show dialog - select POS
				var POSid = ctx.get("SELECTED_REMPOS");
				if("NONE"!=POSid) {
					if(PosRemoteCashoutLock(POSid, 1)) {	// lock
						if(PosSetProvision(POSid, tdCalc)) {
							// Do the remote transfer in
							if(PosRemoteTransfer(17, 0, "", 0, "", POSid, sCalc)) {
								// Do the local transfer out
								if(PosTransfer(22, 0, "", 0, "", POSid.substring(3), sCalc)) {
									PosShowMessage("MSG_CONFIRM_CASH_TRANSFER");
								}
								else {
									PosShowMessage("MSG_ERROR_CASH_TRANSFER_OUT_INCOMPLETE");
								}
								// just reset the provision watch dog counter
								npAdpTlog_RequestSrv(NPSRVTLOG_PROVISIONTIMEOUT,ADPTLOG_INT_TIMEOUT_TYPE,0);
							}
							else {
								PosShowMessage("MSG_ERROR_CASH_TRANSFER");
								// clear the provision
								tdCalc=new BigDecimal (0);
								PosSetProvision("", tdCalc);
							}
						}
						else {
							PosShowMessage("MSG_ERROR_CASH_TRANSFER");
						}
						PosRemoteCashoutLock(POSid, 0);
					}
					else {
						PosShowMessage("MSG_ERROR_CASH_TRANSFER");
					}
				}
			}
		}
	}
	else {
		PosShowMessage("MSG_BC_OPERATOR_TYPE_NOT_PERMITED");
	}
	return(true);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosDoRemoteTransferIn</b>
 *
 * This BC do the remote transfer\n
 * In a workflow sequence it is called:<b>PosDoRemoteTransferIn</b>\n
 * In java script it should be called:<b>PosDoRemoteTransferIn</b>\n
 * @return rval - true if possible
 * @since 1.18
 */
function PosDoRemoteTransferIn() {
	var cmd = "PosDoRemoteTransferIn";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var ctx=new SessionContext;
	var podMode = ctx.get("workingMode");
	if (podMode != "orderTaker") {
		var hlp=new BusinessObjectHelper;
		var xmlPOS=new XML(hlp.getPOSState());
		var state=Number(xmlPOS.@state);

		//Validate operator logged
		if(POS_STA_OPLOGGED!=state) {
			// cant continue
			PosShowMessage("MSG_BC_OPERATOR_NOT_LOGGED_IN");
			return(false);
		}

		// get a list of POS
		if(!PosChooseRemotePOS("5","MSG_POS_CASH_TRANSFER_IN", "MSG_POS_CONFIRM_TRANSFER_IN")) {
			PosShowMessage("MSG_ERROR_CASH_TRANSFER");
			return(false);
		}

		// Show dialog - select POS
		var POSid = ctx.get("SELECTED_REMPOS");
		if("NONE"!=POSid) {
			if(!PosRemoteGetProvision(POSid)) {
				provision=getLastFail("PosRemoteGetProvision");
				PosShowMessage(provision);
			}
			else {
				provision=getLastSuccess("PosRemoteGetProvision");
				if(Number(provision)>0) {
					PosShowMessage("MSG_TRANSFER_ALREADY_IN_PROGRESS");
				}
				else
				{
					var allowExcessTransfer=hlp.findParamInSectionWide("allowExcessTransfer","Cash");
					if(PosGetRemoteCashInDrawer(POSid, allowExcessTransfer)) {
						var drawerAmount=getLastSuccess("PosGetRemoteCashInDrawer");
					}
					else {
						PosShowMessage("MSG_ERROR_CASH_TRANSFER");
						// error - cant continue
						return(false);
					}

					var bLoop=true;
					while(true==bLoop) {
						// Show dialog - request amount
						var currency=rootStoreDB.StoreDB.StoreProfile.Localization.CurrencySymbol;
						var sTrfMsg=hlp.getSysMessage("MSG_AMOUNT_CASH_TRANSFER_IN", currency, drawerAmount);
						var sCalc = PosShowCalculator(sTrfMsg, "", 0, 1, drawerAmount, drawerAmount);
						if((sCalc.length == 0)||(0==Number(sCalc))){
							return(false);
						}

						var tdDrawer=new BigDecimal (drawerAmount);
						var tdCalc=new BigDecimal (sCalc/100);
						if(tdCalc.compareTo(tdDrawer)>0) {
							var calcAmount = trim(API.formatNumber (Number(tdCalc), "#0.00"));
							PosShowMessage("MSG_INVALID_AMOUNT_CASH_TRANSFER_IN", calcAmount, tdDrawer.toString());
							//return(false);
						}
						else {
							bLoop=false;
						}
					}

					if(PosRemoteCashoutLock(POSid, 1)) {	// lock
						if(PosRemoteSetProvision(POSid, tdCalc)) {
							// Do the remote transfer out
							if(PosRemoteTransfer(22, 0, "", 0, "", POSid, sCalc)) {
								// Do the local transfer in
								if(PosTransfer(17, 0, "", 0, "", POSid.substring(3), sCalc, "true")) {
									PosShowMessage("MSG_CONFIRM_CASH_TRANSFER");
								}
								else {
									PosShowMessage("MSG_ERROR_CASH_TRANSFER_IN_INCOMPLETE");
								}
								// reset the remote provision will also reset the watch dog counter
								PosRemoteResetProvision(POSid, "false");
							}
							else {
								PosShowMessage("MSG_ERROR_CASH_TRANSFER");
								// clear the provision
								PosRemoteResetProvision(POSid);
							}
						}
						else {
							PosShowMessage("MSG_ERROR_CASH_TRANSFER");
						}
						PosRemoteCashoutLock(POSid, 0);
					}
					else {
						PosShowMessage("MSG_ERROR_CASH_TRANSFER");
					}
				}
			}
		}
	}
	else {
		PosShowMessage("MSG_BC_OPERATOR_TYPE_NOT_PERMITED");
	}
	return(true);
}

/********** AUXILIARY FUNCTIONS *********
 */
/**
 * @brief This auxiliary function ask for working mode if in DT mode
 *
 * @param - msgSecCashier - not used
 * @return array with the selected work mode
 * @since 1.17-
 */
function selectWorkMode(msgSecCashier) {

	var wkModeRet=new Array();
	wkModeRet[0]=null;
	wkModeRet[1]=null;
	var ctx=new SessionContext;
	var pod=ctx.get("POD");
	if(("DT" == pod) || ("WT" == pod)){
		var askWorkMode=true;
		if(("DT" == pod) && (ctx.get("tandemEnable").toString() == "true") && (Number(ctx.get("DTStoreMode")) == TANDEM_FACE)) {
			// Face-2-Face
			var hlp=new BusinessObjectHelper;
			var test=hlp.findParamInSectionConfig("tandemBooth","PosType");
			if((Number(test) == 1) || (Number(test) == 2)) {
				PosItemSelection("icnoperatorcs.png|icnoperatorotcs.png","cashier|both","RES_DT_LOGIN_TITLE","MSG_DT_LOGIN_MESSAGE");
				wkModeRet[0]=ctx.get("SelectedButtonValue");
				wkModeRet[1]=test;
				askWorkMode=false;
			}
		}
		if(askWorkMode) {
			PosItemSelection("icnoperatorot.png|icnoperatorcs.png|icnoperatorotcs.png","orderTaker|cashier|both","RES_DT_LOGIN_TITLE","MSG_DT_LOGIN_MESSAGE");
			wkModeRet[0]=ctx.get("SelectedButtonValue");
		}
	}
	return(wkModeRet);
}

/**
 * @brief This function validates DT Mode
 *
 * @return rval - if it's true the caller is allowed to continue
 * @since 1.17-
 */
function auxValidDtMode() {

	// Validates FacexFace DT tandem mode...
	var ctx=new SessionContext;
	var pod=ctx.get("POD");
	if(("DT" == pod) && (ctx.get("tandemEnable").toString() == "true") && (Number(ctx.get("DTStoreMode")) == 1)) {
		var test=0;
		if(PosGetLoggedInPOS()) {
			var loggedin=ctx.get("loginDTPosition");
			if(loggedin != null) {
				if(loggedin.indexOf("1") > 0) {
					test|=1;
				}
				if(loggedin.indexOf("2") > 0) {
					test|=2;
				}
			}
		}
		switch(test) {
			case 1:
				// Primary already logged-in
				if(Number(ctx.get("tandemBooth")) != 1) {
					test=0;
				}
				break;
			case 2:
				// Secondary already logged-in
				if(Number(ctx.get("tandemBooth")) != 2) {
					test=0;
				}
				break;
			case 3:
				if((Number(ctx.get("tandemBooth")) != 1) && (Number(ctx.get("tandemBooth")) != 2)) {
					test=0;
				}
				break;
		}
		if(test != 0) {
			return(false);
		}
	}
	return(true);
}

/**
 *
 * @brief This function implements the Business Component: <b>cPosRPSOpenDay</b>.
 *
 * This BC performs the actions needed to open the RPS Service business day.
 *
 * @param mode - int - POS Mode: 0 - offline, 1 - store-wide, 2 - store-wide forced\n
 * @param date - string - business date to open\n
 *
 * @success <i>BC_RPS_OPEN_DAY_SUCCESS</i> - RPS Service business day opened successfully.
 * @failure	<i>BC_RPS_OPEN_DAY_RPSCLIENT</i> - RPS Service business day failed to open: RPS Client failed.
 * @failure	<i>BC_RPS_OPEN_DAY_INVBUSDAY</i> - RPS Service business day failed to open: invalid business day.
 * @failure	<i>BC_RPS_OPEN_DAY_ALREADYOPEN</i> - RPS Service business day failed to open: business day already open.
 * @failure	<i>BC_RPS_OPEN_DAY_NOTCLOSED</i> - RPS Service business day failed to open: business day not closed.
 * @failure	<i>BC_RPS_OPEN_DAY_OPLOGGED</i> - RPS Service business day failed to open: operator logged.
 * @failure	<i>BC_RPS_OPEN_DAY_ERROR</i> - RPS Service business day failed to open: RPS Service failed.
 * @failure	<i>BC_RPS_OPEN_DAY_COMMERROR</i> - RPS Service business day failed to open: communication error.
 * @failure	<i>BC_RPS_OPEN_DAY_INVALIDSTATE</i> - RPS Service business day failed to open: RPS Service invalid state.
 *
 * @since 1.21
 */
 function cPosRPSOpenDay(mode, date) {
 	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var cmd = "cPosRPSOpenDay";
	return executeBC(cmd,[mode, date]);
 }

/**
 *
 * @brief This function implements the Business Component: <b>cPosRPSCloseDay</b>.
 *
 * This BC performs the actions needed to close the RPS Service business day.
 *
 * @param mode - int - POS Mode: 0 - offline, 1 - store-wide, 2 - store-wide forced\n
 * @param date - string - business date to close\n
 *
 * @success <i>BC_RPS_CLOSE_DAY_SUCCESS</i> - RPS Service business day opened successfully.
 * @failure	<i>BC_RPS_CLOSE_DAY_RPSCLIENT</i> - RPS Service business day failed to open: RPS Client failed.
 * @failure	<i>BC_RPS_CLOSE_DAY_INVBUSDAY</i> - RPS Service business day failed to open: invalid business day.
 * @failure	<i>BC_RPS_CLOSE_DAY_ALREADYOPEN</i> - RPS Service business day failed to open: business day already open.
 * @failure	<i>BC_RPS_CLOSE_DAY_NOTCLOSED</i> - RPS Service business day failed to open: business day not closed.
 * @failure	<i>BC_RPS_CLOSE_DAY_OPLOGGED</i> - RPS Service business day failed to open: operator logged.
 * @failure	<i>BC_RPS_CLOSE_DAY_ERROR</i> - RPS Service business day failed to open: RPS Service failed.
 * @failure	<i>BC_RPS_CLOSE_DAY_COMMERROR</i> - RPS Service business day failed to open: communication error.
 * @failure	<i>BC_RPS_CLOSE_DAY_INVALIDSTATE</i> - RPS Service business day failed to open: RPS Service invalid state.
 *
 * @since 1.21
 */
 function cPosRPSCloseDay(mode, date) {
 	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	var cmd = "cPosRPSCloseDay";
	return executeBC(cmd,[mode, date]);
 }

/**
 * @brief This function implements the BC,Business Component: <b>cPosRPSUpDate</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * This BC is responsible for UpDate the HHOT state with data from RPS.
 *
 * @since 1.21-
 */
function cPosRPSUpDate() {
	var cmd = "cPosRPSUpDate";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);	
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRPSOpenDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosRPSOpenDay_CSL is responsible for perform the actions needed to open the day in  RPS service.\n
 * Before actually RPS opening the day, the HOT/RPS state is checked. It should be "closed" for RPS opening the day.\n
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_RPS_SUCESS_OPEN_DAY
 * 	MSG_BC_RPS_ERR_OFFLINE 
 * 	MSG_BC_RPS_OPENDAYERROR
 *
 * @since 1.21
 */
function PosRPSOpenDay_CSL(level)
{
	var cmd = "PosRPSOpenDay_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	
	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var type   = xmlPOS.@ID.toString().substr(0,3);
	var state  = Number(xmlPOS.@state);

	if(type == "HOT") {
		switch(state) {
		case POS_STA_CLOSED:
			// Gets Date Format - Store-DB-Xml
			var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
			// Gets Business Day - "dayOpenBusinessDay"
			var sdate  = xmlPOS.@busDate;
			
			//SDO-6840
			if ((("dd-MM-yyyy" != fmtDate) && ("MM-dd-yyyy" != fmtDate) && ("yyyy-MM-dd" != fmtDate))){
				fmtDate = "MM-dd-yyyy";
			}

			if (sdate == "") {
		
			   // Gets Date System
				var wdate  = new Date();
				var wyear  = API.setZerosOnLeft(wdate.getFullYear(), 4);
				var wmonth = API.setZerosOnLeft(wdate.getMonth() + 1, 2);
				var wday   = API.setZerosOnLeft(wdate.getDate(), 2);
				//SDO-6840
				if ("dd-MM-yyyy" == fmtDate){
					sdate  = wday + wmonth + wyear;
				}
				else if ("MM-dd-yyyy" == fmtDate){
					sdate  = wmonth + wday + wyear;
				}
				else if ("yyyy-MM-dd" == fmtDate){
					sdate  = wyear + wmonth + wday;
				}
			}
			else {
				//Next Day
				sdate = hlp.getNextDay(sdate);
				//SDO-6840
				if ("dd-MM-yyyy" == fmtDate){
					// reorder yyyyMMdd to ddMMyyyy
					sdate = sdate.substr(6,2) + sdate.substr(4,2) + sdate.substr(0,4);
				}
				else if ("MM-dd-yyyy" == fmtDate){
					// reorder yyyyMMdd to MMddyyyy
					sdate = sdate.substr(4, 4) + sdate.substr(0, 4);
				}
				else if ("yyyy-MM-dd" == fmtDate){
					sdate = sdate;
				}
			}
	
			var sMsg=hlp.getSysMessage("MSG_BC_DAYOPENCONF",fmtDate);
			//SDO-6840
			if ("dd-MM-yyyy" == fmtDate){
				var sdateMDY = PosShowCalculator(sMsg,"ddMMyyyy", 2, 2, null, sdate);
			}
			else if ("MM-dd-yyyy" == fmtDate){
				var sdateMDY = PosShowCalculator(sMsg,"MMddyyyy", 2, 2, null, sdate);
			}
			else if("yyyy-MM-dd" == fmtDate){
				var sdateMDY = PosShowCalculator(sMsg,"yyyyMMdd", 2, 2, null, sdate);
			}
			
			if ((sdateMDY == null) || (sdateMDY == "")) {
				return(false);
			}
			//SDO-6840
			if ("dd-MM-yyyy" == fmtDate){
				// reorder ddMMyyyy to yyyyMMdd
				var dayOpen = sdateMDY.substr(4, 4) + sdateMDY.substr(2, 2) + sdateMDY.substr(0,2);
			}
			else if ("MM-dd-yyyy" == fmtDate){
				// reorder MMddyyyy to yyyyMMdd
				var dayOpen = sdateMDY.substr(4, 4) + sdateMDY.substr(0, 4);
			}
			else if("yyyy-MM-dd" == fmtDate){
				var dayOpen = sdateMDY;
			}
		
			if (level == undefined) {
				var level = "manager";
			}
			if (level == "manager") {
				//  Manager Autorization
				if(!PosGetAuthorization("manager")) {
					return(false);
				}
			}
			result = cPosDayOpen("offline", dayOpen);
			if (result == false) {
				PosShowMessage(getLastFail("cPosDayOpen"));
			}
			else{
				PosShowMessage("MSG_BC_RPS_SUCESS_OPEN_DAY");
			}
			break;
		default:
			PosShowMessage("MSG_BC_RPS_ERROR_OPEN_DAY");
			result = false;
			break;
		}
	}
	else {
		// Gets Date Format - Store-DB-Xml
		var fmtDate	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
		var date = xmlPOS.@busDate;
		
		if (date == "") {
		   // Gets System Date
			var wdate  = new Date();
			var wyear  = API.setZerosOnLeft(wdate.getFullYear(), 4);
			var wmonth = API.setZerosOnLeft(wdate.getMonth() + 1, 2);
			var wday   = API.setZerosOnLeft(wdate.getDate(), 2);
			date  =  wyear + wmonth + wday;
		}
		else if(state == POS_STA_CLOSED) {
			// Gets Next Day
			date = hlp.getNextDay(date);
		}

		var sMsg=hlp.getSysMessage("MSG_BC_DAYOPENCONF",fmtDate);
		if (PosAskDate(date, sMsg, 2)) {
			date = getLastSuccess("PosAskDate");
		} else {
			return(false);
		}

		if (level == undefined) {
			var level = "manager";
		}
		if (level == "manager") {
			//  Manager Autorization
			if(!PosGetAuthorization("manager")) {
				return(false);
			}
		}

		result = cPosRPSOpenDay(0, date);
		if (result == false) {
			var fail = getLastFail("cPosRPSOpenDay");
			if(fail == "BC_RPS_OPEN_DAY_COMMERROR") {
				PosShowMessage("MSG_BC_RPS_ERR_OFFLINE");
			}
			else {
				PosShowMessage("MSG_BC_RPS_OPENDAYERROR");
			}
		}
		else{
			PosShowMessage("MSG_BC_RPS_SUCESS_OPEN_DAY");
		}
	}
	
 	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRPSCloseDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosRPSCloseDay_CSL is responsible for perform the actions needed to open the day in  RPS service.\n
 *
 * @sessioncontext <i>"dayOpenBusinessDay"</i> - Read to check if already set, write to clear its data.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_RPS_SUCESS_CLOSE_DAY
 * 	MSG_BC_RPS_ERR_OFFLINE 
 * 	MSG_BC_RPS_CLOSEDAYERROR
 *
 * @since 1.21
 */
function PosRPSCloseDay_CSL(level)
{
	var cmd = "PosRPSCloseDay_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	
	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var type   = xmlPOS.@ID.toString().substr(0,3);

	if(type == "HOT") {
		var state  = Number(xmlPOS.@state);

		switch(state) {
		case POS_STA_OPENED:
		case POS_STA_BLOCKED:
			if (level == undefined) {
				var level = "manager";
			}
			if (level == "manager") {
				//  Manager Autorization
				if(!PosGetAuthorization("manager")) {
					return(false);
				}
			}
			result = cPosEndOfDay("offline");		
			if (result == false) {
				PosShowMessage(getLastFail("cPosEndOfDay"));
			}
			else{
				PosShowMessage("MSG_BC_RPS_SUCESS_CLOSE_DAY");
			}
			break;
		case POS_STA_OPLOGGED:
		case POS_STA_BLOCKOP:
			PosShowMessage("MSG_BC_RPS_ERROR_CLOSE_DAY_NOT_ALLOWED");
			result = false;		
			break;
		default:
			PosShowMessage("MSG_BC_RPS_ERROR_CLOSE_DAY");
			result = false;
			break;
		}
	}
	else {
		if (level == undefined) {
			var level = "manager";
		}
		if (level == "manager") {
			//  Manager Autorization
			if(!PosGetAuthorization("manager")) {
				return(false);
			}
		}
		result = cPosRPSCloseDay(0, "");		
		if (result == false) {
			var fail = getLastFail("cPosRPSCloseDay");
			if(fail == "BC_RPS_CLOSE_DAY_COMMERROR") {
				PosShowMessage("MSG_BC_RPS_ERR_OFFLINE");
			}
			else if (fail == "BC_RPS_CLOSE_DAY_SALEMODE") {
				PosShowMessage("MSG_BC_RPS_ERROR_PENDING_ORDERS");
			}
			else {
				PosShowMessage("MSG_BC_RPS_CLOSEDAYERROR");
			}
		}
		else{
			PosShowMessage("MSG_BC_RPS_SUCESS_CLOSE_DAY");
		}
	}
	
 	return(result);
}

 /**
 * @brief This function implements the BC,Business Component: <b>PosHHOTLogin_CSL</b>
 *
 * Persistence:<b>Persisted</b>\n
 * This BC performs HHOT operator login
 * In a workflow sequence it is called:<b>PosOperatorLogin</b>
 * In java script it should be called:<b>PosHHOTLogin_CSL()</b>
 * @remarks
 *
 * Property Messages:\n
 *   MSG_BC_RPS_ERROR_LOGIN:
 *
 * @since 1.21-
 */
function PosHHOTLogin_CSL ()
{
	var cmd = "PosHHOTLogin_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	
	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);
	
	if(state != POS_STA_OPENED){
		cPosRPSUpDate();
		xmlPOS = new XML(hlp.getPOSState());
		state  = Number(xmlPOS.@state);
	}
	
	switch(state) {
	case POS_STA_OPENED:
		if(!PosDoOperatorLogin(false)) {
			result = false;
		}
		break;
	case POS_STA_CLOSED:
		PosShowMessage("MSG_BC_RPS_ERR_LOGIN_DAY_NOT_OPEN");	
		result = false;
		break;
	case POS_STA_BLOCKOP:
	case POS_STA_OPLOGGED:
		PosShowMessage("MSG_BC_RPS_ERR_USER_ALREADY_LOGGED");	
		result = false;
		break;
	default:
		PosShowMessage("MSG_BC_RPS_ERROR_LOGIN");	
		result = false;
		break;
	}
 	return(result);
}


/**
 * @brief This function implements the BC,Business Component: <b>PosHHOTLogOut_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosHHOTLogOut_CSL is responsible for perform the operator logout routine, when it's in remote mode do not prompt for confirmation.
 * In java script it should be called:<b>PosHHOTLogOut_CSL(remote)</b>
 * @param remote - String - Optional, "true" to indicate a remote logout (default:"false").
 * @success .
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_RPS_CONF_LOGOUT: Confirm logout for HHOT user:\n{0}?
 * 	MSG_BC_SALEPROG: There is a order in progress.\nYou must first store or tender the order.
 * 	MSG_BC_RPS_ERROR_LOGOUT: Logout failed because RPS did not authorize
 *	MSG_BC_INVLOGOUT: You cannot logout a user from this register since no user is currently logged in.
 * @since 1.21
 */
function PosHHOTLogOut_CSL()
{
	var cmd = "PosHHOTLogOut_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	
	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);
	
	switch(state) {
	case POS_STA_OPLOGGED:
	case POS_STA_BLOCKOP:
		if(!PosNotATransactionInProgress(true)) {
			PosShowMessage("MSG_BC_SALEPROG");	
		}
		else {
			var name   = xmlPOS.Operator.@name;
			// Confirms logout
			var sConfMsg=hlp.getSysMessage("MSG_BC_RPS_CONF_LOGOUT",name);
			if(PosShowConfirmationMessage(sConfMsg,"MSG_YES","MSG_NO")) {
				if(!cPosOperatorLogout(false)) {
					PosShowMessage("MSG_BC_RPS_ERROR_LOGOUT");				
					result = false;
				}
			}
		}
		break;
	default:
		PosShowMessage("MSG_BC_RPS_ERR_INVLOGOUT");	
		result = false;
		break;
	}
	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRPSChangeDay_CSL</b>.
 *
 * Persistence:<b>Persisted</b>\n
 * The PosRPSChangeDay_CSL is responsible for perform the actions needed to change the day in RPS service.\n
 *
 * @sessioncontext <i>"dayOpenBusinessDay"</i> - Read to check if already set, write to clear its data.
 * @remarks
 *
 * Property Messages:\n
 * 	MSG_BC_RPS_SUCESS_CLOSE_DAY:
 * 	MSG_BC_RPS_ERROR_CLOSE_DAY: 
 *
 * @since 1.21
 */
function PosRPSChangeDay_CSL(level)
{
	var cmd = "PosRPSChangeDay_CSL";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");

	var result = true;
	
	// Get State POS
	var hlp    = new BusinessObjectHelper;
	var xmlPOS = new XML(hlp.getPOSState());
	var state  = Number(xmlPOS.@state);

	switch(state) {
	case POS_STA_OPENED:
	case POS_STA_BLOCKED:
		if (level == undefined) {
			var level = "manager";
		}
		if (level == "manager") {
			//  Manager Autorization
			if(!PosGetAuthorization("manager")) {
				return(false);
			}
		}
		var cmd = "PosExecuteChangeDay";
		if(executeBC(cmd)) {
			result = cPosEndOfDay("offline");		
			if (result == false) {
				PosShowMessage(getLastFail("cPosEndOfDay"));
			}
			else{
				var sdate  = xmlPOS.@busDate;
				sdate = hlp.getNextDay(sdate);			
				result = cPosDayOpen("offline", sdate);
				if (result == false) {
					PosShowMessage(getLastFail("cPosDayOpen"));
				}
				else{
					PosShowMessage("MSG_BC_RPS_SUCESS_CHANGE_DAY");
				}
			}
		}
		else {
			var msgError = getLastFail("PosExecuteChangeDay");
			if(msgError == "MSG_BC_RPS_ERR_OFFLINE") {
				PosShowMessage(msgError);
			}
			else {
				PosShowMessage("MSG_BC_RPS_CHANGEDAYERROR");
			}
			result = false;
		}
		break;
	case POS_STA_OPLOGGED:
	case POS_STA_BLOCKOP:
		PosShowMessage("MSG_BC_RPS_ERROR_CLOSE_DAY_NOT_ALLOWED");
		result = false;
		break;
	default:
		PosShowMessage("MSG_BC_RPS_ERROR_CLOSE_DAY");
		result = false;
		break;
	}
 	return(result);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosClearDirReports</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * The PosClearDirReports is responsible for cleanup the Reports directory.\n
 * In java script it should be called:<b>PosClearDirReports()</b>
 * @success.
 * @todo check return codes.
 * @remarks
 * @since 1.21
 */
function PosClearDirReports()
{
	var cmd = "cPosClearDirReports";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	return executeBC(cmd);
}

function lGetI18nMessage(key) {
	var localMessage = API.getLocalMsg(key);

	if (key != localMessage)
		return localMessage;

	var hlp=new BusinessObjectHelper;
	return hlp.getSysMessage(key);
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRPSLogin</b>.
 *
 * The PosRPSLogin is responsible for logging in a default user into an RPS Service.
 * In java script it should be called:<b>PosRPSLogin(nbrPOS)</b>
 * @param - nbrPOS - String - Contains the name of one or more RPS services (separated by the '|' character) in which the login should be 
 *					 performed. For example if we want to execute the login in the RPS 01 and the RPS 02, then the nbrPOS parameter should
 *					 contain the string: "RPS0001|RPS0002"
 * @returns - This function always returns true
 * @success <i>MSG_BC_RPS_LOGIN_SUCCESS</i>
 * @failure <i>MSG_BC_ERROR_INVALID_NUM_PARAM</i> - Incorrect number of parameters.
 * @failure	<i>MSG_BC_RPS_ERROR_COMM_ERROR</i>  - Communication error
 * @failure	<i>MSG_BC_RPS_ERROR_CLOSED</i>  - The RPS business day is closed
 * @failure	<i>MSG_BC_RPS_ERROR_OPER_ALREADY_LOGGED</i>  - A user is already logged into the RPS
 * @failure	<i>MSG_BC_RPS_ERROR_OPER_NOT_COMPLETE</i>  - Could not complete the current operation
 *
 * @since 1.20-
 */
function PosRPSLogin(nbrPOS) {
	var cmd = "PosRPSLogin";
	var result;
	var msg;
	var pos;
	var nbrPosArray;
	
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	
	nbrPosArray = nbrPOS.split('|');
	
	for each (pos in nbrPosArray) {
	
		if (pos != undefined && pos != "" && pos != " ") {	
			result = executeBC(cmd, [pos]);
			
			// If an error occurred.
			//NPM-616 NPM-614
			if (!result) {
			
				msg = getLastFail(cmd);
				msg = lGetI18nMessage(msg);
				PosShowMessage(msg + " for " + [pos] + " .");
				
			}else{				
				
				var msg = lGetI18nMessage("MSG_BC_RPS_LOGIN_SUCCESS");			
				PosShowMessage(msg + " " + [pos] + " ." );
				
			}
			
		}
	}
	
	return true;
}

/**
 * @brief This function implements the BC,Business Component: <b>PosRPSLogout</b>.
 *
 * The PosRPSLogout is responsible for logging out a default user in an RPS Service.
 * In java script it should be called:<b>PosRPSLogout(nbrPOS)</b>
 * @param - nbrPOS - String - Contains the name of one or more RPS services (separated by the '|' character) in which the logout should be 
 *					 performed. For example if we want to execute the logout in the RPS 01 and the RPS 02, then the nbrPOS parameter should
 *					 contain the string: "RPS0001|RPS0002"
 * @returns - This function always returns true
 * @success <i>MSG_BC_RPS_LOGOUT_SUCCESS</i>
 * @failure <i>MSG_BC_ERROR_INVALID_NUM_PARAM</i> - Incorrect number of parameters.
 * @failure	<i>MSG_BC_RPS_ERROR_COMM_ERROR</i>  - Communication error
 * @failure	<i>MSG_BC_RPS_ERROR_CLOSED</i>  - The RPS business day is closed
 * @failure	<i>MSG_BC_RPS_ERROR_NO_OPER_LOGGED</i>  - There is no user logged in the RPS
 * @failure	<i>MSG_BC_RPS_ERROR_OPER_NOT_COMPLETE</i>  - Could not complete the current operation
 *
 * @since 1.20-
 */
function PosRPSLogout(nbrPOS) {
	var cmd = "PosRPSLogout";
	var result;
	var msg;
	var pos;
	var nbrPosArray;
	
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	
	nbrPosArray = nbrPOS.split('|');
	
	for each (pos in nbrPosArray) {
	
		if (pos != undefined && pos != "" && pos != " ") {	
			result = executeBC(cmd, [pos]);
			
			// If an error occurred.
			//NPM-616 NPM-614
			if (!result) {
				
				msg = getLastFail(cmd);				
				msg = lGetI18nMessage(msg);
				PosShowMessage(msg + " for " + [pos] + " .");
				
			}else{		
				
				var msg = lGetI18nMessage("MSG_BC_RPS_LOGOUT_SUCCESS");			
				PosShowMessage(msg + " " + [pos] + " ." );
				
			}
		}
	}
	
	return true;
}

function PosRPSCheckAvailability()
{
	var cmd = "PosRPSCheckAvailability";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	
	return executeBC(cmd, []);
}

/** PosVerifyMobileOrder
 *
 * This function verify mobile orders\n
 * @param bSaveView - flag that indicates if the view must be stored in the session property (should be true only at the first recall)
 * @param bDialogInThread - flag that indicates if the dialog windows must be opened in thread on not
 * Return - rval - none.
 * @since 1.23
 */
function PosVerifyMobileOrder(bSaveView, sDialogInThread)
{
	var hlp = new BusinessObjectHelper;
	var msgPopNoItems = hlp.getSysMessage("MSG_BC_DT_ORDER_WITHOUT_VALID_ITEMS");
	var msgBotSkip = hlp.getSysMessage("MSG_BC_DT_ORDER_SKIP_CAR_BUTTON");
	var msgBotModify = hlp.getSysMessage("MSG_BC_DT_ORDER_MODIFY_ORDER_BUTTON");
	var foeSavedView;
	var ctx=new SessionContext;
	foeSavedView = ctx.get("SavedFOEView");
	if((null==foeSavedView)|| (foeSavedView.length<=0)) {
		API.STTWarningLog("0", "[PosVerifyMobileOrder] - View not available.", "CSL_Register.nps");
	}
	else {
		if(bSaveView) {
			var xmlView=XML(foeSavedView);
			if(0==xmlView.InvalidItemView.length() && 0==xmlView.InvalidPromotions.Promotion.length()) {
				// no invalid items -> remove from context
				PosSetSessionProperty("SavedFOEView","","true");
			}
			else 
			{
				PosShowFOEInvalidItems("mobileDTShowItems@reports.nps","FALSE",sDialogInThread);
				if(0==xmlView.ItemView.length()) {
					var botRet = PosShowConfirmationMessage(msgPopNoItems, msgBotSkip, msgBotModify)
					// skip car
					if(botRet) {
						PosDoVoidSale(false);
						PosDoSkipCar();
					}
					// modify order
					else {
						PosDoBackFromTotal();
						PosSetSessionProperty("BackFromTotal", "true");
					}
					var Screen = ctx.get("baseScreenId");
					PosShowScreen(Screen);
					return false;
				}
			}
		}
	}
}

/**PosCheckMobileOrder
 *
 * @brief - This BC checks if validation button can show
 * Return - rval - true if the button should show
 * @since 1.23
 */
function PosCheckMobileOrder ()
{
	var retVal=false;	// FR6 do not show "re-display validation" button (default)
	var ctx=new SessionContext;
	var view		= ctx.get("SavedFOEView");

	if(view!=null) {
		if(view.length>0) {
			// show button only if SavedFOEView has valid content (at least one invalid items)
			retVal=true;
		}
	}
	return(retVal);
}

const SEAMLESS_OK 				= 0;
const SEAMLESS_LOGOUT_ERROR		= 1;
const SEAMLESS_CLOSEDAY_ERROR	= 2;
const SEAMLESS_OPENDAY_ERROR	= 3;
const SEAMLESS_LOGIN_ERROR		= 4;

function PosExecuteSeamless_CSL(NewBusinessDay, autologin)
{
	var ctx = new SessionContext;
	var ret 	= SEAMLESS_OK;
	var hlp    	= new BusinessObjectHelper;
	var xmlPOS 	= new XML(hlp.getPOSState());
	var state  	= Number(xmlPOS.@state);
	var	Id;
	var	InitFloat;
	var OpName;
	var workingMode;
	//Executing hook for begining operation
	API.STTInfoLog("0", "[PosExecuteSeamless_CSL] - Begin Seamless Process. BusinessDay: " + NewBusinessDay, "CSL_Register.nps");
	ret = (typeof(onSeamless_BeginProcess) == "function" ? onSeamless_BeginProcess(NewBusinessDay) : SEAMLESS_OK);
	if(SEAMLESS_OK != ret)
	{
		API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing hook 'onSeamless_BeginProcess'.", "CSL_Register.nps");
		return ret;
	}
	//Selecting specific state
	switch(state)
	{
	case POS_STA_BLOCKOP:
	case POS_STA_OPLOGGED:
		{
			API.STTInfoLog("0", "[PosExecuteSeamless_CSL] - Logging out operator.", "CSL_Register.nps");
			//Executing hook
			ret = (typeof(onSeamless_BeginOperatorLogout) == "function" ? onSeamless_BeginOperatorLogout() : SEAMLESS_OK);
			if(SEAMLESS_OK != ret)
			{
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_BeginOperatorLogout'.", "CSL_Register.nps");
				return ret;
			}
			//Getting login information
			Id 			= xmlPOS.Operator.@id;
			InitFloat	= xmlPOS.@grandTotal;
			OpName		= xmlPOS.Operator.@name;
			workingMode = ctx.get("workingMode");
			ctx.set("seamlessOperatorId", Id, false);
			ctx.set("seamlessOperatorInitialFloat", InitFloat, false);
			ctx.set("seamlessOperatorName", OpName, false);
			ctx.set("seamlessWorkingMode", workingMode, false);
			//Executing operator logout
			if(!(ret = cPosOperatorLogout(false, true)))
			{
				ret = SEAMLESS_LOGOUT_ERROR;
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'cPosOperatorLogout'.", "CSL_Register.nps");
				return ret;
			}
			//Executing hook
			ret = (typeof(onSeamless_EndOperatorLogout) == "function" ? onSeamless_EndOperatorLogout() : SEAMLESS_OK);
			if(SEAMLESS_OK != ret)
			{
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_EndOperatorLogout'.", "CSL_Register.nps");
				return ret;
			}
		}
	case POS_STA_BLOCKED:
	case POS_STA_OPENED:
		{
			API.STTInfoLog("0", "[PosExecuteSeamless_CSL] - Closing day.", "CSL_Register.nps");
			//Executing hook
			ret = (typeof(onSeamless_BeginDayClose) == "function" ? onSeamless_BeginDayClose() : SEAMLESS_OK);
			if(SEAMLESS_OK != ret)
			{
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_BeginDayClose'.", "CSL_Register.nps");
				return ret;
			}
			//Executing end of day
			if(!(ret = cPosEndOfDay('offline')))
			{
				ret = SEAMLESS_CLOSEDAY_ERROR;
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'cPosEndOfDay'.", "CSL_Register.nps");
				return ret;
			}
			//Executing hook
			ret = (typeof(onSeamless_EndDayClose) == "function" ? onSeamless_EndDayClose() : SEAMLESS_OK);
			if(SEAMLESS_OK != ret)
			{
				API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_EndDayClose'.", "CSL_Register.nps");
				return ret;
			}
		}
		return ret;
	/*case POS_STA_INVALID:
	case POS_STA_CLOSED:*/
	default:
		break;
		
	}
	//Executing hook
	ret = (typeof(onSeamless_BeginDayOpen) == "function" ? onSeamless_BeginDayOpen() : SEAMLESS_OK);
	if(SEAMLESS_OK != ret)
	{
		API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_BeginDayOpen'.", "CSL_Register.nps");
		return ret;
	}	
	//Opening day
	API.STTInfoLog("0", "[PosExecuteSeamless_CSL] - Opening day.", "CSL_Register.nps");
	if(!(ret = cPosDayOpen('seamless',NewBusinessDay)))
	{
		ret = SEAMLESS_OPENDAY_ERROR;
		API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'cPosDayOpen'.", "CSL_Register.nps");
		return ret;
	}
	//Executing hook
	ret = (typeof(onSeamless_EndDayOpen) == "function" ? onSeamless_EndDayOpen() : SEAMLESS_OK);
	if(SEAMLESS_OK != ret)
	{
		API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_EndDayOpen'.", "CSL_Register.nps");
		return ret;
	}
	//Logging in if necessary
	opId = ctx.get("seamlessOperatorId");
	opInitFloat = ctx.get("seamlessOperatorInitialFloat");
	operatorName = ctx.get("seamlessOperatorName");
	workingMode = ctx.get("seamlessWorkingMode");
	
	// SDO-14282 - without seamless, the login data will be erased to avoid the automatic script login (done by seamless)
	if(!IsSeamlessEnable())
	{
		opId = "";
		opInitFloat = "";
		operatorName = "";
	}
	
	if(((opId != "" && opId != null) && (opInitFloat != "" && opInitFloat != null) && (operatorName != "" && operatorName != null)) ||
		(autologin.toLowerCase() == "true"))
	{
		//Executing hook
		ret = (typeof(onSeamless_BeginOperatorLogin) == "function" ? onSeamless_BeginOperatorLogin() : SEAMLESS_OK);
		if(SEAMLESS_OK != ret)
		{
			API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_BeginOperatorLogin'.", "CSL_Register.nps");
			return ret;
		}
		//Operator Login
		if ((opId == null || opId == "") && (autologin == "true")){
			opId = API.findParamInSectionConfig("AnonymousOperatorID", "OperationMode");
			operatorName = API.findParamInSectionConfig("AnonymousOperatorName", "OperationMode");
		}
		if(!(ret = cPosOperatorLogin(opId,opInitFloat,autologin,operatorName)))
		{
			ret = SEAMLESS_LOGIN_ERROR;
			API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'cPosOperatorLogin'.", "CSL_Register.nps");
			return ret;
		}
		if (workingMode != null){
			PosChangeDtWorkingMode(workingMode);
		}
		//Reset Login Information
		ctx.set("seamlessOperatorId", "", false);
		ctx.set("seamlessOperatorInitialFloat", "", false);
		ctx.set("seamlessOperatorName", "", false);
		ctx.set("seamlessWorkingMode", "", false);
		//Executing hook
		ret = (typeof(onSeamless_EndOperatorLogin) == "function" ? onSeamless_EndOperatorLogin() : SEAMLESS_OK);
		if(SEAMLESS_OK != ret)
		{
			API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing 'onSeamless_EndOperatorLogin'.", "CSL_Register.nps");
			return ret;
		}
	}

	//Executing hook for ending operation
	ret = (typeof(onSeamless_EndProcess) == "function" ? onSeamless_EndProcess(NewBusinessDay) : SEAMLESS_OK);
	if(SEAMLESS_OK != ret)
	{
		API.STTErrorLog("0", "[PosExecuteSeamless_CSL] - Error executing hook 'onSeamless_EndProcess'.", "CSL_Register.nps");
		return ret;
	}
	API.STTInfoLog("0", "[PosExecuteSeamless_CSL] - End Seamless Process.", "CSL_Register.nps");
	
	return ret;
}

function onSeamlessError_CSL(ErrorCode)
{
	var ret = false;
	//Selecting proper error code
	switch(ErrorCode)
	{
	case SEAMLESS_OK:
		break;
	case SEAMLESS_LOGOUT_ERROR:
		{
			ret = PosShowMessage("MSG_AUTOMATIC_POS_OPERATOR_LOGOUT_FAILED");
		}
		break;
	case SEAMLESS_CLOSEDAY_ERROR:
		{
			ret = PosShowMessage("MSG_AUTOMATIC_CLOSE_DAY_FAILED");
		}
		break;
	case SEAMLESS_OPENDAY_ERROR:
		{
			ret = PosShowMessage("MSG_AUTOMATIC_OPEN_DAY_FAILED");
		}
		break;
	case SEAMLESS_LOGIN_ERROR:	
		{
			ret = PosShowMessage("MSG_AUTOMATIC_POS_OPERATOR_LOGIN_FAILED");
		}
		break;
	default:
		{
			ret = (typeof(onSeamless_CustomError) == "function" ? onSeamless_CustomError(ErrorCode) : SEAMLESS_OK);
		}
		break;
	}
	
	return ret;
}

function PosCheckSeamlessForHHOT()
{
	var cmd = "PosCheckSeamlessForHHOT";
	CSL_dbglog(7, SRC_BC_REGISTER, cmd, "Start");
	
	return executeBC(cmd, []);
}

// SDO-14282
function IsSeamlessEnable()
{
	var ReturnValue = false;

	var slEnable  = rootHlp.findParamInSectionWide("enable", "AutomaticChangeBusinessDay")
	if (slEnable != null && slEnable.toLowerCase() == "true") {
		ReturnValue = true;
	}
	return ReturnValue;
}
/**
 * END nps
 */
/* signed aut version 9-9076
 * authority id = builder
 * authority level = 10
 * authority name = NewPOS release level
 * group = npi
 * validity = 2010-04-18
 * signature type = slash_star
 * time stamp (GMT) = Fri Jan 26 16:27:04 2018
 * certificate = 393735312d3739343700fed72888f63244574ebb4aa86318830fcf57d8bd96e9ccca2458e0738d7dd132116ebe786db94b55cb43920eb5ced40e8f300010
 * =============================================================================================================================
*/
