/***  
 * @file MobileCheckin.nps
 * @brief This NPS file implements all script functions related to the Mobile Check-in Device
 * @addtogroup 	Mobile
 * @defgroup 	Checkin
 * @ingroup 	Mobile
 *
 * Copyright - - (C) 2008 McDonalds Corp. All rights reserved.
 *
 * @author Raphael (of Creation)
 * @since SDO-4013 / 2011/10/18
 *
 * @version $Id: MobileCheckin.nps $
 * @{
 */

/********************************************************************************************************************************************
 *														MCD - Mobile Check-in Device														*
 ********************************************************************************************************************************************/

var GLOBAL_CSO_BLOCK_SOURCE = null;
//MOT-362
var isPromotionalProduct = false; //used when a product was replace by a promotional one
var isPromotionalSale = false;
var itemsPromo = new Array();	  //valid products in the time-base (isPromotional at product-db.xml)
var invalidItemsPromo = new Array();
const BLOCK_SOURCE_PRINTER = "printer";
const BLOCK_SOURCE_NETWORK = "network";
const BLOCK_SOURCE_SALE_MODE = "saleMode";

// The constants below contain the name of the wav files that are the sounds played by the Check-In device.
// MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
const MCD_SOUND_CANCEL = "MCD_Cancel";
const MCD_SOUND_GREETING = "MCD_Greeting";
const MCD_SOUND_IS_ORDER_CORRECT = "MCD_Is_Order_Correct";
const MCD_SOUND_LEVEL_3_GENERIC_SELECT = "MCD_Level_3_Generic_Select";
const MCD_SOUND_MEAL_SELECT_COMPLETE = "MCD_Meal_Select_Complete";
const MCD_SOUND_ORDER_COMPLETE = "MCD_Order_Complete";
const MCD_PAYMENT_PROMPT = "MCD_Payment_Prompt";

const MOBILE_ORDER_SRC = 1;
const MOBILE_BAR_CODE_PROCESS_NP_EXT = "BarCodeProcess";
const MOBILE_BASE_CTX_SOURCE = "source";
const MOBILE_BASE_CTX_ID = "id";
const MOBILE_TAG_CUSTOMER_NICK = "customerNickname";
const MOBILE_TAG_CUSTOMER_ID = "customerId";
const MOBILE_ITEM_OK = "0";
const MOBILE_ITEM_NOT_CATALOG = "1";
const MOBILE_ITEM_NOT_SALABLE = "2";
const MOBILE_ITEM_INACTIVE = "3";
const MOBILE_ITEM_NOT_AVAILABLE = "4";
const MOBILE_ITEM_INV_DAY_PART = "5";
const MOBILE_ITEM_INV_TIME = "6";
const MOBILE_ITEM_INV_PARENT = "7";
const MOBILE_ITEM_INV_CHOICE = "8";
const MOBILE_ITEM_MC_CAFE = "9";
const MOBILE_ITEM_GRILL_ERROR = "10";
const MOBILE_PROD_OUT_FILE = "/prodoutage.xml";
const MOBILE_NUMBER_COD = 2;
const MOBILE_DIR_PATH = "MobileDirectoryPath";
const MOBILE_CTX_IS_MOBILE_ORDER = "isMobileOrder";
const MOBILE_TAG_IS_CID_ORDER = "isCIDOrder";
const MOBILE_TAG_IS_DT_ORDER = "isMobileDTOrder";

/********************************************************************************************************************************************
 *																Data Objects     															*
 ********************************************************************************************************************************************/

 /********************************************************************************************************************************************
 *															Script Initialization   														 *
 ********************************************************************************************************************************************/
 
 /** PosMCDInitCheckIn
  *
  * @brief - This BC intializes this script.
  * @return - true always
  * @since - SQM-896 - MOT Integration with NP6: Check In device is not available. It starts with error.
  */
function PosMCDInitCheckIn() {
	var ctx = new SessionContext;
	var operation = ctx.get("POD");
	
	PosMCDSetProductDictionaryJS();
	PosMCDSetNamesDictionaryJS();
	PosMobileCreateDir("MCD");
	
	if (operation == "DT") {
		// Disable the barcode reader in the COD 1
		PosMCDDisableBarcodeReaderByCOD(1);
		
		// Disable the barcode reader in the COD 2
		PosMCDDisableBarcodeReaderByCOD(2);
	}
	
	return true;
}
 
 /********************************************************************************************************************************************
 *																Product-DB         															*
 ********************************************************************************************************************************************/
 
var productDictionary = new Array();

/** PosMCDSetProductDictionaryJS
 *
 * @brief - This BC initializes the product dictionary, for fast product search. This BC must be called at Check-in Device UI initialization
 * @return - true always
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDSetProductDictionaryJS() {
	//NVS-2459
	//var csoRootProductDB = new XML(API.getProductdb().toString());
	var productCollection = GetRootProductDB();
	for each(var product in productCollection.Product) {
		productDictionary[product.ProductCode] = product;
	}
	return true;
}


/********************************************************************************************************************************************
 *																Names-DB         															*
 ********************************************************************************************************************************************/

var namesDictionary = new Array();

/** PosMCDSetNamesDictionaryJS
 *
 * @brief - This BC initializes the names dictionary, for fast product names search. This BC must be called at Check-in Device UI
 * initialization
 * @return - true aways
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDSetNamesDictionaryJS() {
	var languageArray = new Array();
	var csoRootNamesDB = new XML(API.getNamesdb().toString());
	for each(language in csoRootNamesDB.Language) {
		for each(var productName in language.ProductName) {
			languageArray[productName.ProductCode] = productName;
		}
		namesDictionary[language.@code] = languageArray;
		languageArray = [];
	}
	return true;
}

/** lMCDGetProductName
 *
 * @brief - Gets a product name xml node from the product names dictionary
 * @param - productCode - string - code of the product to be gotten
 * @return - string - the product name
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lMCDGetProductName(productCode, language) {
	if(language == null) {
		var ctx = new SessionContext;
		language = ctx.get("LANGUAGE");
	
		if (language == null || language.length <= 0) {
			if (rootStoreDB == null) {
				loadStoreDB();
			}
			
			language = rootStoreDB.StoreDB.StoreProfile.Localization.Language +
				"_" + rootStoreDB.StoreDB.StoreProfile.Localization.CountryId;
				
			var variant = String(rootStoreDB.StoreDB.StoreProfile.Localization.Variant);

			if(variant != null && variant.length > 0) {
				language += "_" + variant;
			}
			
			API.dbg("lMCDGetProductName using language: " + language);
		}
	}

	var languageDictionary = namesDictionary[language];
	
	if (languageDictionary == null) {
		API.dbg("lMCDGetProductName WARNING - language was not found: " + language);
		return null;
	}
	
	var productNameXML = languageDictionary[productCode];
	
	if (productNameXML == null) {
		API.dbg("lMCDGetProductName WARNING - product was not found: " + productCode + ", language: " + language);
		return null;
	}
	
	API.dbg("lMCDGetProductName (" + language + ") - CSOName: " + productNameXML.CSOName + ", " + "LongName: " +productNameXML.LongName);
	var csoName = String(productNameXML.CSOName);
	if(csoName != null && csoName.length > 0) {
		return csoName;
	} else {
		return String(productNameXML.LongName);
	}
}

/********************************************************************************************************************************************
 *																Auxiliar Methods															*
 ********************************************************************************************************************************************/

/**
*
* @brief - This BC creates a directory, one level up the bin directory, i.e. on the same level as PosData directory. It also create the control files ctr_fail.dat amd ctr_success.dat
* @param - directoryName - string - directory name
* @return - true if the directory was successfully created, or if it already exists. False if it could not be created
* @author - Raphael Almeida
* @since - SDO-4013 - Implement Mobile Check-in Device
*/
function PosMobileCreateDir(directoryName) {
	var path = "../"+directoryName+"/";
	var ret = File.createDir(path);

	API.dbg("Mobile - PosMobileCreateDir - ret: "+ret);

	var ctx = new SessionContext;
	ctx.set(MOBILE_DIR_PATH, path, false);

	if( (ret > 0) || (ret == 0) ) {
		API.dbg("Mobile - PosMobileCreateDir - directory created successfully or already exists");
		return true;
	}

	API.dbg("Mobile - PosMobileCreateDir - error creating directory");
	return false;
}

/** lGetBarcodeServiceName
 *
 * @brief - Gets the name of the bar code Adaptor that was configured on the pos-db.xml and that will be used to control the LED and the sound via javascript.
 * The name of the adaptor returned will follow a precendence, if the Bar Code Reader is configured, than its name will be returned, if not than the name of 
 * the Bar Code Process will be returned. If the name of the Bar Code Process is not set at the pos-db.xml the default name will be returned: BCP0001.
 * @returns - String containing the name of the configured adaptor.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function lGetBarcodeServiceName() {

	var posDb = new XML(API.getPosdb());
	var extensions = posDb.Services.Service.(@type == "POS").Adaptors.Adaptor.(@name == "nps.extension");
	var ext;
	var serviceType, serviceName, barcodeProcess, barcodeReader, barcodeService;

	barcodeProcess = "";
	barcodeReader = "";
	
	for each (ext in extensions) {
		serviceType = ext.Section.(@name == "driverconfig").Parameter.(@name == "serviceType").@value.toXMLString();
				
		if (serviceType == "BCP") {
			serviceName = ext.Section.(@name == "driverconfig").Parameter.(@name == "serviceName").@value.toXMLString();
			barcodeProcess = serviceType + serviceName;
		
		} else if (serviceType == "BCR") {
			serviceName = ext.Section.(@name == "driverconfig").Parameter.(@name == "serviceName").@value.toXMLString();
			barcodeReader = serviceType + serviceName;
		
		}
	}
	
	if (barcodeReader != "") {
		barcodeService = barcodeReader;
	
	} else if (barcodeProcess != "") {
		barcodeService = barcodeProcess;
	
	// If the Bar Code Process service name is not configured inside the pos-db.xml, use the default value.	
	} else {
		barcodeService = "BCP0001";
	
	}

	return barcodeService;
}
 
/** lCreateMCDEvent
 *
 * @brief - Formats a XML string with the event to be send to Mobile Check-in Device UI
 * @param - type - string - type of event (e.g. "ASYNC" or "SYNC")
 * @param - name - string - name of the event as defined in the UI (e.g. "DLG_SYS_TENDER_START")
 * @param - params - array - parameters values that will be sent to the UI, for the specified event
 * @return - XML string containg the event to be sent to the Mobile Check-in Device UI
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
function lCreateMCDEvent(type, name, params) {
    var xml = new StringBuffer();
    xml.append(GLOBAL_UTF8_PROLOG_XML);
    xml.append("<Event ");
    {
        xml.append(" type=\"" + type + "\"");
        xml.append(" name=\"" + name + "\"");
        xml.append(">\n");
		
		if ((params != undefined) && (params instanceof Array)) {
			for (var i=0; i<params.length; i++) {
				var p = params[i].split("|");
				xml.append("\t<Parameter name=\"" + p[0] + "\" value=\"" + p[1] + "\"/>\n");
			}
		}
    }
    xml.append("</Event>");
    return xml.toString();
}

/** lGetI18nMessage
 *
 * @brief - Gets the i18n string message for the specified key
 * @param - key - string - i18n key entry for the desired message
 * @return - string containing the local message, or the key itself, when it is not found in the i18n properties files
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lGetI18nMessage(key) {
	var localMessage = API.getLocalMsg(key);

	if (key != localMessage)
		return localMessage;

	var hlp=new BusinessObjectHelper;
	return hlp.getSysMessage(key);
}

/** lMCDSendSyncMessage
 *
 * @brief - Sends a sync message to the Mobile Check-in Device UI, to create a dialog
 * @param - eventType - string - name of the sync message understandable by the UI
 * @param - btnTexts - array - texts or images name for buttons in the dialog created by the UI
 * @param - btnValues - array - id's for each button. When a button is pressed, NP6 core creates a session context,
 *								"SelectedButtonValue", containing the ID of the button that was pressed
 * @param - winTitle - name of the dialog
 * @return - ID of the button that was pressed, or null in case of timeout or no button pressed
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lMCDSendSyncMessage(eventType, btnTexts, btnValues, winTitle) {
	var retValue = null;

	var tmpBtnTexts = new Array();
	for each(item in btnTexts) {
		//Array type
		if (item != null && typeof(item) == 'object' && item.length) {
			tmpBtnTexts.push(item.join("@"));
		} else {
			tmpBtnTexts.push(item);
		}
	}

	var hasSuceeded = PosItemSelection(tmpBtnTexts.join("|"), btnValues.join("|"), eventType,  winTitle);
	if (hasSuceeded) {
		var ctx = new SessionContext;
		retValue = ctx.get("SelectedButtonValue");
		API.dbg("[MCD - lMCDSendSyncMessage] selected value = " + retValue);
	} else {
		API.dbg("[lMCDSendSyncMessage - lMCDSendSyncMessage] cancel has been pressed");
	}
	return retValue;
}

/** lcreateBlockUnblock
 *
 * @brief - Creates the XML UI block / unblock message, command message sample:
 *
 *			<Event type="ASYNC" name="UI_BLOCK"/>
 *	   			<Parameter name="Code" value="6969"/>
 *	  			<Parameter name="Msg" value="The message"/>
 *			</Event>
 *
 * @param - evtName - string - name of the event for the UI command
 * @param - code - string - value for the "Code" parameter
 * @param - msg - string - value for the "Msg" parameter
 * @return - XML string of the command
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lcreateBlockUnblock(evtName, code, msg) {
	var xml = new StringBuffer();
	xml.append(GLOBAL_UTF8_PROLOG_XML);
	xml.append("<Event ");
	{
		xml.append(" type=\"ASYNC\"");
		xml.append(" name=\"" + evtName + "\"");
		xml.append(">\n");
		if (code != null && msg != null) {
			xml.append("\t<Parameter name=\"Code\" value=\"" + code + "\" />\n");
			xml.append("\t<Parameter name=\"Msg\"  value=\"" + msg  + "\" />\n");
		}
	}
	xml.append("</Event>");
	return xml.toString();
}

/** lSetScreen
 *
 * @brief - This function sends the xml definition of a screen to the UI
 * @param - screenXml - string - xml string containing the screen definition
 * @return - true if the command was successfully sent to the UI
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lSetScreen(screenXml) {
	var xml = new StringBuffer();
	xml.append(GLOBAL_UTF8_PROLOG_XML);
	xml.append("<Event type=\"ASYNC\" name=\"DAT_SYS_SET_GENERIC_SCREEN\">\n");
	xml.append(screenXml.toXMLString());
	xml.append("</Event>");
	return PosSendUICmd(xml.toString())
}

/** lShowScreen
 *
 * @brief - Shows a screen previously created using lSetScreen API. The call is asynchronous
 * @param - screenName - string - name of the screen to be shown
 * @return - true if the command was successfully sent to the UI
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function lShowScreen(screenName) {
	var xml = new StringBuffer();
	xml.append(GLOBAL_UTF8_PROLOG_XML);
	xml.append("<Event type=\"ASYNC\" name=\"DLG_SYS_SHOW_GENERIC_SCREEN\">\n");
	xml.append("  <Parameter name=\"ScreenName\" value=\""+screenName+"\"/>\n");
	xml.append("</Event>");
	return PosSendUICmd(xml.toString());
}

/** lShowScreenWithSound
 * 
 * @brief - Shows a screen previously created and plays a given sound. This call is asynchronous.
 * @param - screenName - string - name of the screen to be shown.
 * @param - sound - string - name of the sound that will be played when the screen is shown.
 * @param - soundDelay - string (optional) - delay (in milliseconds) before playing the sound.
 * @return - true if the command was successfully sent to the UI.
 * @author - Felipe Armoni
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 */
function lShowScreenWithSound(screenName, sound, soundDelay) {
	var xml = new StringBuffer();
	
	if (soundDelay == undefined) {
		soundDelay = "";
	}
	
	xml.append(GLOBAL_UTF8_PROLOG_XML);
	xml.append("<Event type=\"ASYNC\" name=\"DLG_SYS_SHOW_GENERIC_SCREEN\">\n");
	xml.append("  <Parameter name=\"ScreenName\" value=\""+screenName+"\"/>\n");
	xml.append("  <Parameter name=\"Sound\" value=\""+sound+"\"/>\n");
	xml.append("  <Parameter name=\"SoundDelay\" value=\""+soundDelay+"\"/>\n");
	xml.append("</Event>");
	return PosSendUICmd(xml.toString());
}

/********************************************************************************************************************************************
 *															GENERIC SCREEN API																*
 *																																			*
 * The Generic Screen API is a solution for creating custom screens via script for the Mobile Check-in Device UI. The methods create a xml 	*
 * describing the elements of a screen: image, text, button and box. See the API of each element for details. The xml must have a header 	*
 * with the following attributes:																											*
 * 		@name - name of the screen																											*
 *		@transition - transition effect when the screen appears. Possible values: "fadeAndGrowPopupTransition", "fadeAndGrowTransition",	*
 *						"goForwardTransition", "goBackTransition", "fadeAndShrinkPopupTransition", "fastShrinkPopupTransition", 			*
 *						"fadePopupTransition"																								*
 *		@timeout - timeout in seconds for synchronous screen																				*
 *		@resX - number of rows that the screen will have.																					*
 *		@resY - number of columns that the screen will have																					*
 *																																			*
 * For example:																																*
 * var screenXml = new XML('<GenericScreen name="totalscreen" transition="fadeAndGrowPopupTransition" timeout="5" resX="10" resY="10"/>');	*
 * In this example the screen will have a 100x100 grid. The elements of this screen will be placed in this grid.							*
 * Screens can be either synchronous or asynchronous.																						*
 * 																																			*
 * - For synchronous screens:																												*
 * GenericScreen_CreateScreen must be called, passing the screen XML as parameter.															*
 * The GenericScreen_CreateScreen method will return null when the screen times out, or the button ID, when a button is pressed in the 		*
 * screen dialog.																															*
 *																																			*
 * - For asynchronous screens: 																												*
 * The method lSetScreen(screenXml) must be called passing the xml describing the screen (same xml as the synchronous one). Note that it is *
 * not necessary to pass a timeout. The screen will remain until another one is shown. Then lShowScreen must be called, passing the screen 	*
 * name, as @name in the screen xml. lSetScreen and lShowScreen can be called in different Business Components.								*
 * The main screen must be created with name "MainScreen", and for this screen it is not necessary to call lShowScreen, as the UI will show *
 * it automatically during the initialization.																								*
 *																																			*
 * The API for creating elements is: GenericScreen_AddImage, GenericScreen_AddText, GenericScreen_AddButton and GenericScreen_AddBox.		*
 * See declaration of each method below for more details.																					*
 * Note that the API for the screen elements only appends child nodes, so it is necessary to create a xml previously. 						*
 * For example:																																*
 * //10x10 grid screen with 10 seconds timeout																								*
 * var screenXml = new XML('<GenericScreen name="screenName" transition="transitionName" timeout="10" resX="10" resY="10"/>');				*
 * var imagesXml = new XML('<Images/>');																									*
 * // definition of a image for the screen																									*
 * imagesXml = GenericScreen_AddImage(imagesXml, "image_name.PNG", "2", "2", "4", "5");														*
 * screenXml.appendChild(imagesXml);																										*
 * // sends the sync message to the UI to create the dialog																					*
 * GenericScreen_CreateScreen(screenXml);																									*
 *																																			*
 ********************************************************************************************************************************************/

/** GenericScreen_AddImage
 *
 * @brief - Appends a child xml in the passed xml parameter, with imageName, left position, top position, width and height attributes, that specifies
 * the position and size of the image in the generic screen.
 * Only one horizontal and vertical coordinate should be used to set this image's position (for example one should use either right or left, never both).
 * The value of the coordinates that are not used shoud be "-1".
 * @param - xml - XML - parent image xml, where the image will be appended
 * @param - imageName - string - name of the image that will be placed in the generic screen
 * @param - left - string - horizontal position of the image in pixels.
 * @param - top - string - vertical position of the image, in pixels.
 * @param - right - string - horizontal position of the image, in pixels
 * @param - bottom - string - vertical position of the image, in pixels
 * @param - width - string - horizontal "span" of the image, in pixels.
 * @param - height - string - vertical "span" of the image, in pixels
 * @return - XML given by "xml" parameter, with one new image tag appended
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The image xml will have the following format:
 *	<Images>
 * 		<Image name="image1.png" left="1" right="-1" bottom="-1" top="2" width="2" height="2"/>
 *	</Images>
 */
function GenericScreen_AddImage(xml, imageName, left, top, right, bottom, width, height) {
	xml.appendChild(new XML('<Image name="'+imageName+'" left="'+left+'" top="'+top+'" right="'+right+'" bottom="'+bottom+'" width="'+width+'" height="'+height+'"/>'));
	return xml;
}

/** GenericScreen_AddAnimatedImage
 *
 * @brief - Appends a child xml in the passed xml parameter, with imageName, left position, top position, width and height attributes, that specifies
 * the position and size of the image in the generic screen.
 * Only one horizontal and vertical coordinate should be used to set this image's position (for example one should use either right or left, never both).
 * The value of the coordinates that are not used shoud be "-1".
 * @param - xml - XML - parent image xml, where the image will be appended
 * @param - imageName - string - name of the image that will be placed in the generic screen
 * @param - left - string - horizontal position of the image, in pixels.
 * @param - top - string - vertical position of the image, in pixels.
 * @param - right - string - horizontal position of the image, in pixels
 * @param - bottom - string - vertical position of the image, in pixels
 * @param - width - string - horizontal "span" of the image, in pixels.
 * @param - height - string - vertical "span" of the image, in pixels.
 * @return - XML given by "xml" parameter, with one new image tag appended
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The image xml will have the following format:
 *	<Images>
 * 		<Image name="image1.png" left="1" top="2" right="-1" bottom="-1" width="2" height="2" direction="vertical"/>
 *	</Images>
 */
function GenericScreen_AddAnimatedImage(xml, imageName, left, top, right, bottom, width, height, direction, distance) {
	xml.appendChild(new XML('<AnimatedImage name="'+imageName+'" left="'+left+'" top="'+top+'" right="'+right+'" bottom="'+bottom+'" width="'+width+'" height="'+height+'" direction="'+direction+'" distance="'+distance+'"/>'));
	return xml;
}

/** GenericScreen_AddText
 *
 * @brief - Appends a child xml in the passed xml parameter, with text value, left position, top position, width, height, foreground color,
 * font family and font size attributes, that specifies the position, font and size of the text that will be added to the generic screen XML.
 * Only one horizontal and vertical coordinate should be used to set this text's position (for example one should use either right or left, never both).
 * The value of the coordinates that are not used shoud be "-1".
 * @param - xml - XML - parent Text xml, where the image will be appended
 * @param - text - string - text that will be displayed in the screen. If it is a i18n message, the value must be first gotten using lGetI18nMessage API
 * @param - left - string - horizontal position of the text in pixels.
 * @param - top - string - vertical position of the text in pixels.
 * @param - right - string - horizontal position of the text, in pixels
 * @param - bottom - string - vertical position of the text, in pixels
 * @param - width - string - horizontal "span" of the text, in pixels. If the value of this parameter is -1, then the Width property will be ignored.
 * @param - height - string - vertical "span" of the text, in pixels. If the value of this parameter is -1, then the Height property will be ignored.
 * @param - foreground - string - color definition of the text. It can be either predefined system colors, or hexadecimal values, e.g. #cf0309
 * @param - fontFamily - string - font family name. E.g. "Arial" or "Century Gothic"
 * @param - fontSize - string - font size for the text
 * @param - fontWeight - string - optional parameter that sets the font weight (bold, italic, etc). 
 * If this parameter is not specified the default will be used (Bold).
 * @return - XML given by "xml" parameter, with one new text tag appended
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The text xml will have the following format:
 *	<Texts>
 * 		<Text text="Scan sucessful" left="1" top="1" right="-1" bottom="-1" width="2" height="2" foreground="#cf0309" fontFamily="Arial" fontSize="28" fontWeight="Bold"/>
 *	</Texts>
 */
function GenericScreen_AddText(xml, text, left, top, right, bottom, width, height, foreground, fontFamily, fontSize, fontWeight) {
	
	if (fontWeight == undefined)
		fontWeight = "";
	
	xml.appendChild(new XML('<Text text="'+text+'" left="'+left+'" top="'+top+'" right="'+right+'" bottom="'+bottom+'" width="'+width+'" height="'+height+'" foreground="'+foreground+'" fontFamily="'+fontFamily+'" fontSize="'+fontSize+'" fontWeight="'+fontWeight+'"/>'));
	return xml;
}

/** GenericScreen_AddButton
 *
 * @brief - Appends a child xml in the passed xml parameter, with button image, button text, left position, top position, right position, bottom position, width, height, 
 * background color and button ID that specifies the content, position, size and color of the button that will be added to the generic screen XML.
 * Only one horizontal and vertical coordinate should be used to set this button's position (for example one should use either right or left, never both).
 * The value of the coordinates that are not used shoud be "-1".
 * @param - xml - XML - parent Button xml, where the Button will be appended
 * @param  - textSize - string - text size in pixel or points (for points use "pt" after the number, e.g.: 28pt)
 * @param - text - string - text that will be displayed in the button. If it is a i18n message, the value must be first gotten using lGetI18nMessage API
 * @param - left - string - horizontal position of the button, in pixels
 * @param - top - string - vertical position of the button, in pixels
 * @param - right - string - horizontal position of the button, in pixels
 * @param - bottom - string - vertical position of the button, in pixels
 * @param - width - string - horizontal "span" of the button, in pixels
 * @param - height - string - vertical "span" of the button, in pixels
 * @param - background - string - color definition of the button. It can be either predefined system colors such as "Blue" or "Red",
 * 								  or hexadecimal values, such as #cf0309
 * @param - id - string - Button ID. When a button is pressed in the screen, the API GenericScreen_CreateScreen will return its ID.
 * @param - borderThickness - string (optional) - Thickness of the button border.
 * @param - borderBrush - string (optional) - Color of the button border It can be either predefined system colors such as "Blue" or "Red",
 * 								  or hexadecimal values, such as #cf0309
 * @return - XML given by "xml" parameter, with one new button tag appended
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The text xml will have the following format:
 *	<Buttons>
 * 		<Button image="" textSize="" text="" left="10" top="10" right="-1" bottom="-1" width="3" height="4" background="#cf0309" cornerRadius="10" id="button1" borderThickness="12" borderBrush="Gray"/>
 *	</Buttons>
 *
 * @TODO - Review how the image is handled by the UI
 */
 function GenericScreen_AddButton(xml, textSize, text, left, top, right, bottom, width, height, background, cornerRadius, id, borderThickness, borderBrush, sound) {
	
	if (borderThickness == undefined){
		borderThickness = "-1";
	}
		
	if (borderBrush == undefined){
		borderBrush = "";
	}
	
	if (sound == undefined) {
		sound = MCD_SOUND_LEVEL_3_GENERIC_SELECT;
	}
	 
	xml.appendChild(new XML('<Button textSize="'+textSize+'" text="'+text+'" left="'+left+'" top="'+top+'" right="'+right+'" bottom="'+bottom+'" width="'+width+'" height="'+height+'" background="'+background+'" cornerRadius="'+cornerRadius+'" id="'+id+'" borderThickness="'+borderThickness+'" borderBrush="'+borderBrush+'" sound="'+sound+'" />'));
	return xml;
 }

/** GenericScreen_AddBox
 *
 * @brief - Appends a child xml in the passed xml parameter, with left position, top position, width, height, foreground color,
 * font family and font size attributes, that specifies the position, font and size of the text that will be added to the generic screen XML.
 * A box is a rectangular border. Other elements can be defined "inside" it.
 * Only one horizontal and vertical coordinate should be used to set this box's position (for example one should use either right or left, never both).
 * The value of the coordinates that are not used shoud be "-1".
 * @param - xml - XML - parent Box xml, where the Box will be appended
 * @param - left - string - horizontal position of the box, in pixels
 * @param - top - string - vertical position of the box, in pixels
 * @param - right - string - horizontal position of the box, in pixels
 * @param - bottom - string - vertical position of the box, in pixels
 * @param - width - string - horizontal "span" of the box, in pixels
 * @param - height - string - vertical "span" of the box, in pixels
 * @param - thickness - string - border thickness, in pixels
 * @param - borderBrush - string - color definition of the border. It can be either predefined system colors, or hexadecimal values, e.g. #cf0309
 * @return - XML given by "xml" parameter, with one new box tag appended
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The text xml will have the following format:
 *	<Boxes>
 * 		<Box left="2" top="2" right="-1" bottom="-1" width="3" height="5" thickness="3" borderBrush="Red" backgroundBrush="Black"/>
 *	</Boxes>
 */
function GenericScreen_AddBox(xml, left, top, right, bottom, width, height, thickness, borderBrush) {
	xml.appendChild(new XML('<Box left="'+left+'" top="'+top+'" right="'+right+'" bottom="'+bottom+'" width="'+width+'" height="'+height+'" thickness="'+thickness+'" borderBrush="'+borderBrush+'"/>'));
	return xml;
}

/** GenericScreen_AddBackgroundDivision
 * 
 * @brief - Appends a child xml in the passed xml parameter, with left position, top position, width, height, brush color, that specifies the position, color 
 * and size of a division in the screen background.
 * A box is a rectangular border. Other elements can be defined "inside" it.
 * @param - xml - XML - parent Background xml, where the Division will be appended
 * @param - backgroundBrush - string - color definition of the background of the screen.
 * @param - left - string - horizontal position of the division, in pixels
 * @param - top - string - vertical position of the division, in pixels
 * @param - width - string - horizontal "span" of the division, in pixels
 * @param - height - string - vertical "span" of the division, in pixel
 * @return - XML given by "xml" parameter with the "Division" tag appended.
 * @author - Felipe Armoni
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 *	The text xml will have the following format:
 *	<Background backgroundBrush="White">
 *		<Division brush="Black" left="0" top="0" width="480" height="384" />
 *	</Background> 
 */
function GenericScreen_AddBackgroundDivision(xml, brush, left, top, width, height) {
	xml.appendChild(new XML('<Division brush="' + brush + '" left="' + left + '" top="' + top + '" width="' + width + '" height="' + height + '" />'));
	return xml;
}

/** GenericScreen_AddDropShadow
 * 
 * @brief - Appends a child xml in the passed xml parameter. This function should be used to add a drop shadow to a single button. It does not adds a drop shadow
 * to other elements.
 * @param - xml - XML - parent Button XML, for example: <Button image="" textSize="" text="" left="10" top="10" width="3" height="4" background="#cf0309" cornerRadius="10" id="button1"/>
 * @param - buttonId - string - Id of the button that should have the drow shadow appended.
 * @param - depth - string (double) - Depth of the drop shadow to be added.
 * @param - direction - string (double) - direction - Direction, in degrees, of the drop shadow.
 * @param - opacity - string (double) - opacity of the drop shadow.
 * @param - blur - string (double) - blur amount of the drop shadow. 
 * @return - XML given by the "xml" parameter with the "DropShadow" tag appended.
 * @author - Felipe Armoni
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks -
 * 	The text xml will have the following format:
 * <Buttons>
 * 		<Button image="" textSize="" text="" left="10" top="10" width="3" height="4" background="#cf0309" cornerRadius="10" id="button1">
 *			<DropShadow depth="3" direction="330" opacity="2" blur="4" />
 *		</Button>
 *	</Buttons> 
 */
function GenericScreen_AddDropShadow(xml, buttonId, depth, direction, opacity, blur) {
	
	var dropShadowXml = new XML('<DropShadow depth="' + depth + '" direction="' + direction + '" opacity="' + opacity + '" blur="' + blur + '"/>');
	
	xml.Button.(@id == buttonId).appendChild(dropShadowXml);	
	
	return xml;
}

/** GenericScreen_CreateScreen
 *
 * @brief - Creates a sync screen based on an XML definition and sends it to the UI
 * @param - screenXml - XML - definition of the generic screen
 * @return - return pressed button id, or null after the timeout
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 */
function GenericScreen_CreateScreen(screenXml) {
	var buttonsIDs = new Array();
	for each(button in screenXml.Buttons.Button) {
		buttonsIDs.push(button.@id);
	}
	// closes any popup before showing new screen
	PosSendUICmd('<Event type="ASYNC" name="DLG_SYS_CLOSE_SCREENPOPUP" />');
	var ret = lMCDSendSyncMessage("SYNC_DLG_GENERIC_SCREEN", new Array(), buttonsIDs, screenXml);
	API.dbg("GenericScreen_CreateScreen - pressed button: "+ret);
	return ret;
}

/********************************************************************************************************************************************
 *																Actual BCs																	*
 ********************************************************************************************************************************************/

/** PosMCDWaitPrintoutScreenJS
*
* @brief - This BC creates and shows a asynchronous screen with a text (given by the i18n tag MCD_MSG_WAIT_PRINTOUT) and an animation.
* This screen was created to be shown while the order's ticket is being printed.
* @return - Allways true
* @author - Felipe Armoni
* @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
*/
function PosMCDWaitPrintoutScreenJS() {
	
	var screen = new XML('<Event type="ASYNC" name="DLG_MSG_START"/>');
	
	var codeXml = new XML('<Parameter name="Code" value="" />');
	var messageXml = new XML('<Parameter name="Msg" value="' + lGetI18nMessage("MCD_MSG_WAIT_PRINTOUT") + '" />')
	var buttonMsgXml = new XML ('<Parameter name="ButtonMsg" value="" />')
	
	screen.appendChild(codeXml);
	screen.appendChild(messageXml);
	screen.appendChild(buttonMsgXml);	
	
	// Shows a blank screen so that this screen will not be displayed on top of another.
	lShowScreen("blankScreen");
	
	PosSendUICmd('<Event type="ASYNC" name="DLG_SYS_CLOSE_SCREENPOPUP" />');
	
	PosSendUICmd(screen.toXMLString());
	
	return true;
}

/**
 * 
 * @brief - This BC creates a plain white screen without any elements. This screen is asynchronous.
 * @returns - Always true
 * @author - Felipe Armoni
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 */
function PosMCDSetBlankScreenJS() {	
	var screenXml = new XML('<GenericScreen name="blankScreen" transition="" sound="" soundDelay="" timeout="" />');

	lSetScreen(screenXml);
	return true;
}

 /** PosMCDScreenContinueJS
 *
 * @brief - This BC creates and shows a screen with two buttons, "yes" and "no", that will be prompted for the user for time passed in
 * "timeout" parameter. If the user chooses "yes" button, the BC will return true. If the user chooses "no", or if the timeout is reached,
 * it will return false
 * @param - timeout - string - screen timeout in seconds
 * @return - true if "yes" button is clicked. false if "no" button is clicked or if the timeout is reached
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 */
 function PosMCDScreenContinueJS(timeout) {
	// Creates screen using Generic Screen API
	var screenXml = new XML('<GenericScreen name="timeoutScreen" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_IS_ORDER_CORRECT+'" soundDelay="" timeout="'+timeout+'"/>');
	var buttonsXml = new XML('<Buttons/>');
	var textsXml = new XML('<Texts/>');
	
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_TIME_OUT"), "35", "84", "-1", "-1", "400", "-1", "Red", "Arial", "36px");
	screenXml.appendChild(textsXml);
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_YES"), "35", "190", "-1", "-1", "190", "190", "Red", "15", "yes");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_NO"), "-1", "190", "35", "-1", "190", "190", "Red", "15", "no");

	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "yes", "5", "234", "0.6", "4");
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "no", "5", "234", "0.6", "4");
	screenXml.appendChild(buttonsXml);

	var pressedButton = GenericScreen_CreateScreen(screenXml);
	if(pressedButton == "yes") {
		return true;
	}
	return false;
}

 /** PosMCDSetMainScreenJS
 *
 * @brief - This BC creates the Main Screen and sends to the MCD UI. Note that this BC does not shows the screen. The screen is called
 * automatically by the UI at initialization. The main screen must have its name set as "MainScreen". When the workflow WF_BarCodeReceived
 * finishes its execution, the Main Screen is aways shown
 * @return - aways true
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_MAIN_SCREEN: Welcome message
 *
 */
function PosMCDSetMainScreenJS() {
	// Creates the Screen using Generic Screen API
	var screenXml = new XML('<GenericScreen name="MainScreen" transition="fadeAndGrowTransition" sound="" soundDelay="" timeout=""/>');
	var imagesXml = new XML('<Images/>');
	var animatedImagesXml = new XML('<AnimatedImages/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')

	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "0", "480", "384");
	screenXml.appendChild(backgroundXml);
	
	animatedImagesXml = GenericScreen_AddAnimatedImage(animatedImagesXml, "MCD_1_ArrowUp.png", "-1", "18", "0", "-1", "251", "232", "vertical", "50");
	screenXml.appendChild(animatedImagesXml);

	imagesXml = GenericScreen_AddImage(imagesXml, "MCD_BigMac.png", "-1", "434", "91", "-1", "394", "285");
	screenXml.appendChild(imagesXml)

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MAIN_SCREEN"), "35", "274", "-1", "-1", "400", "-1", "White", "Arial", "36px");
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MAIN_SCREEN_MOBILE"), "-1", "-1", "195", "35", "-1", "-1", "Red", "Arial", "26pt");
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MAIN_SCREEN_ORDERS"), "-1", "-1", "35", "35", "-1", "-1", "Red", "Arial", "26pt", "Normal");
	
	screenXml.appendChild(textsXml);

	lSetScreen(screenXml);

	return true;
}

/** PosMCDScreenScanSuccessJS
 *
 * @brief - This BC creates and shows a screen with the text defined in MCD_MSG_SCAN_SUCCESSFUL and shows it
 * @param - timeout - string - screen timeout in seconds
 * @return - aways true
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_SCAN_SUCCESSFUL: Scan successful message
 *
 */
function PosMCDScreenScanSuccessJS(timeout) {
	var screenXml = new XML('<GenericScreen name="textScreen" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_MEAL_SELECT_COMPLETE+'" soundDelay="" timeout="'+timeout+'"/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "0", "480", "384");
	screenXml.appendChild(backgroundXml);
	
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_SCAN_SUCCESSFUL"), "35", "313", "-1", "-1", "400", "-1", "White", "Arial", "36px");
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MAIN_SCREEN_MOBILE"), "-1", "-1", "195", "35", "-1", "-1", "Red", "Arial", "26pt");
	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MAIN_SCREEN_ORDERS"), "-1", "-1", "35", "35", "-1", "-1", "Red", "Arial", "26pt", "Normal");
	screenXml.appendChild(textsXml);
	
	GenericScreen_CreateScreen(screenXml);
	
	return true;
}

/** PosMCDScreenAskSaleTypeJS
 *
 * @brief - This BC creates and shows a screen with 3 buttons: cancel, eat in and take out options. The screen is shown until the user clicks
 * in any of the buttons, or until the timeout is reached. If the timeout is reached, a screen is shown (defined by PosMCDScreenContinueJS)
 * asking if the user wants to continue
 * @param - timeout - string - screen timeout in seconds
 * @return - true if a sale type (eat in or take out) is chosen, false if cancel is pressed, or if the timeout is reached and the user
 * selects not to continue
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_CANCEL: Text for cancel button
 *				MCD_MSG_EAT_IN: Text for "Eat In" button
 *				MCD_MSG_TAKE_OUT: Text for "Take Out" button
 *
 */
function PosMCDScreenAskSaleTypeJS(timeout) {
	var transition = "goForwardTransition";
	if(PosCheckSessionProperty("back","true")) {
		var transition = "goBackTransition";
	}

	var screenXml = new XML('<GenericScreen name="selectSaleType" sound="'+MCD_PAYMENT_PROMPT+'" soundDelay="" transition="'+transition+'" timeout="'+timeout+'" />');
	var buttonsXml = new XML('<Buttons/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_PLEASE_CHOOSE"), "35", "-1", "-1", "680", "400", "-1", "Black", "Arial", "36px");
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_EAT_IN"), "35", "190", "-1", "-1", "190", "190", "Red", "15", "eatIn");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_TAKE_OUT"), "255", "190", "-1", "-1", "190", "190", "Red", "15", "takeOut");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_CANCEL"), "20", "-1", "-1", "20", "160", "56", "Gray", "10", "cancel", "3", "LightGray", MCD_SOUND_CANCEL);
	
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "eatIn", "5", "234", "0.6", "4");
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "takeOut", "5", "234", "0.6", "4");
	
	screenXml.appendChild(backgroundXml);
	screenXml.appendChild(textsXml);
	screenXml.appendChild(buttonsXml);
	

	while (true) {
		pressedButton = GenericScreen_CreateScreen(screenXml);
		if(pressedButton == null) {
			// Timeout. Continue?
			var cont = PosMCDScreenContinueJS("15");
			if(!cont){
				return false;
			}
		}
		else {
			break;
		}
	}

	if(pressedButton == "cancel") {
		API.dbg("PosMCDScreenAskSaleTypeJS - cancel button has been pressed");
		return false;
	}

	//(0=EAT IN;1=TAKE OUT;2=OTHER)
	if (pressedButton == "eatIn")
	{
		PosSetSaleType(0);
	}
	else
	{
		PosSetSaleType(1);
	}

	return true;
}

/** PosMCDScreenHandleExceptionJS
 *
 * @brief - This BC creates and shows an exception screen. This BC also creates a receipt, defined in functionName, that informs the user
 * which the reason why the order could not be completed. In the workflow, this BC is called when there is any invalid item,
 * or the barcode has an invalid country code. The screen is shown until the user clicks the "Ok" button.
 * @param - errorMessage - i18n string - name of an i18n tag that contains an error message that will be displayed by this screen.
 * @param - functionName - string - name of the report script to format the exception receipt. This parameter is optional, if it's not supplied, then no
 * report will be created.
 * @param - timeout - string - screen timeout in seconds
 * @return - aways true
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_CANCEL: Text for "cancel" button
 *				MCD_MSG_EXCEPTION_MESSAGE: Upper exception message
 *			- Session contexts:
 * 				"MCDView": contains a xml with the product status:	0 - order item OK
 *																			1 - not in the catalog
 *																			2 - not salable
 *																			3 - inactive
 *																			4 - order item not available (prodoutage.xml)
 *																			5 - invalid day part
 *																			6 - out of time restriction
 *	 			e.g.:
 *					<MobV validCountryCode="true">
 *						<Product code="1111" name="big mac" quantity="2" level="0" status="0"/>
 *						<Product code="2222" name="" quantity="1" level="1" status="1"/>
 *						<Product code="3333" name="coke" quantity="3" level="2" status="2"/>
 *					</MobV>
 *
 */
function PosMCDScreenHandleExceptionJS(errorMessage, functionName, timeout) {
	var ctx = new SessionContext;
	
	if ((functionName != "") && (functionName != undefined)) {
		PosCreateReport("VIEW|CUSTOMDATA", functionName, "NOPREVIEW|ALIAS", ctx.get("MCDView"), "CSO");
	}

	var screenXml = new XML('<GenericScreen name="exceptionScreen" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_IS_ORDER_CORRECT+'" soundDelay="" timeout="'+timeout+'" />');
	var buttonsXml = new XML('<Buttons/>');
	var imagesXml = new XML('<Images/>');
	var animatedImagesXml = new XML('<AnimatedImages/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");
	screenXml.appendChild(backgroundXml);

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage(errorMessage), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_OK"), "-1", "-1", "20", "20", "160", "56", "Red", "10", "ok", "3", "LightGray");
	screenXml.appendChild(buttonsXml);

	animatedImagesXml = GenericScreen_AddAnimatedImage(animatedImagesXml, "MCD_ExceptionRedArrowDown.png", "-1", "-1",  "19", "132", "234", "223", "vertical", "50");
	screenXml.appendChild(animatedImagesXml);

	imagesXml = GenericScreen_AddImage(imagesXml, "MCD_ExceptionTicket.png", "35", "-1", "-1", "95", "194", "240");
	screenXml.appendChild(imagesXml)

	while (true) {
		pressedButton = GenericScreen_CreateScreen(screenXml);
		if(pressedButton == null) {
			// Timeout. Continue?
			var cont = PosMCDScreenContinueJS("15");
			if(!cont){
				return true;
			}
		}
		else {
			break;
		}
	}
	
	if(pressedButton == "ok") {
		API.dbg("PosMCDScreenOrderNumberJS - ok pressed");
	}

	return true;
}

/** PosMCDScreenChoosePaymentJS
 *
 * @brief - This BC creates and shows a screen with payment options. The screen displays the order total and two buttons with payment options.
 * To continue the order, the user must choose either cashless payment or to pay at a counter. If any of these buttons is clicked, the BC
 * returns true. A session context, "isTender", is set to "true" if cashless payment is chosen, or to "false", if pay at a counter is chosen.
 * The screen also contains "cancel" and "back" buttons. If the user clicks the "back" button, a session context, "back" is set to "true" and
 * the BC returns false. If the user clicks the "cancel", the BC also returns false, but the session context "back" is set to "false"
 * @param - timeout - string - screen timeout in seconds
 * @return - true when the user clicks in any of the payment options buttons. false when "cancel" or "back" buttons are pressed, or when
 * timeout is reached and the user chooses not to continue.
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_TOTAL
 *				MCD_MSG_PAY_HERE
 *				MCD_MSG_PAY_AT_COUNTER
 *				MCD_MSG_BACK
 *				MCD_MSG_CANCEL
 *
 * 			- Session Contexts:
 *				"back": Set to "true" when "back" button is clicked. Set to "false" when "cancel" button is clicked.
 *				"isTender": Set to "true" when chashless payment is clicked. Set to "false" when pay at counter is clicked.
 */
function PosMCDScreenChoosePaymentJS(timeout) {
	var hlp = new BusinessObjectHelper;
	var orderView = new XML(hlp.getCurrentView());
	var currencySymbol = rootStoreDB.StoreDB.StoreProfile.Localization.CurrencySymbol.toString();	
	var localStoreId = rootStoreDB.StoreDB.StoreProfile.StoreDetails.StoreId;	
	var orderStoreId = null; 
	var totalPriceMobile, totalPriceLocal;
	var msgText;

	if(currencySymbol.charAt(currencySymbol.length-1) != ' ') {
		currencySymbol += " ";
	}	
			
	var ctx = new SessionContext;
	var view = ctx.get("MCDView");		
	var view = new MCDMobileView(view);	
	var mobileView = view.getView();	
	
	totalPriceMobile = parseFloat(mobileView.@totalPrice.toString());
	totalPriceLocal = parseFloat(orderView.@totalDue);
	

	
	
	
	var totalDue = currencySymbol + API.formatNumber(orderView.@totalDue, "##0.00").replace(/^\s+|\s+$/g,'');		
	
	orderStoreId = mobileView.@StoreId.toString();	
	
	//MOT-379
	API.dbg("[PosMCDScreenChoosePaymentJS] - Checking if total amount has changed");	
	
	var showMessage = false;
	if (totalPriceLocal != totalPriceMobile)
	{		
		API.dbg("[PosMCDScreenChoosePaymentJS] - Total amount is different");
		API.dbg("[PosMCDScreenChoosePaymentJS] - Total from Mobile:" + totalPriceMobile );
		API.dbg("[PosMCDScreenChoosePaymentJS] -  Total from Store:" + totalPriceLocal);
		
		API.dbg("[PosMCDScreenChoosePaymentJS] - Checking if StoreId has changed");				
		
		if (localStoreId != orderStoreId)
		{					
			API.dbg("[PosMCDScreenChoosePaymentJS] - StoreId is different");
			msgText = lGetI18nMessage("TOTAL_CHANGED_DIFFERENT_RESTAURANT");			
			
		}else{
		
			msgText = lGetI18nMessage("TOTAL_CHANGED_SAME_RESTAURANT");		
		
		}
		showMessage = true;
	}else{
		API.dbg("[PosMCDScreenChoosePaymentJS] - Total amount has no change");
	}
	
	if (isPromotionalProduct)
	{
		//The Items below have Promotional Prices
		API.dbg("[PosMCDScreenChoosePaymentJS] - Items with discount");
		msgText = lGetI18nMessage("PROMOTION_DISCOUNT_ALERT_VALID_AT_THIS_TIME");
		for each (var cod in itemsPromo){
			msgText += ": " + cod + ", ";			
		}
		isPromotionalProduct = false;
		
		//zeroizing itemsPromo
		itemsPromo.length = 0;
		showMessage = true;
	}
	
	API.dbg("[PosMCDScreenChoosePaymentJS] - isPromotionalSale: " + isPromotionalSale);
	if (isPromotionalSale)
	{
		API.dbg("[PosMCDScreenChoosePaymentJS] - Promotional Order");
		if (msgText != undefined)
			msgText = msgText + " " + lGetI18nMessage("PROMOTION_DISCOUNT_ALERT_VALID_AT_THIS_MOMENT");
		else
			msgText = lGetI18nMessage("PROMOTION_DISCOUNT_ALERT_VALID_AT_THIS_MOMENT");
			
		isPromotionalSale = false;
		showMessage = true;
	}
	
	//when an order has promotional product (isPromotional) in an invalid time frame
	//TODO: check when put this message, because, if the order is invalid, the code below will not be reached	
	if (invalidItemsPromo.length > 0)
	{		
		msgText = "Invalid order. Promotional Products not in promotional time-frame: " + '\n';
		for each(var codProd in invalidItemsPromo)
		{
			productNameToReplace = lMCDGetProductName(codProd);
			if ( productNameToReplace == null 	||
				productNameToReplace == ""		||
				productNameToReplace == undefined)
			{
				productNameToReplace = codProd;
				API.dbg("[Mobile - ProcessView] - WARNING - Product name not found at names-db.xml for Code: " + codProd);				
			}			
			msgText += productNameToReplace + '\n' ;
			API.dbg("[Mobile - PosDoSaleMobile] - Invalid product: " + codProd);
		}
		invalidItemsPromo.lenght = 0;
	}
	
	if (showMessage)
	{		
		API.dbg("[PosMCDScreenChoosePaymentJS] - Local StoreId:" + localStoreId );
		API.dbg("[PosMCDScreenChoosePaymentJS] - Order StoreId:" + orderStoreId);
		
		var screenXml = new XML('<GenericScreen name="errorScreen" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_IS_ORDER_CORRECT+'" soundDelay="" timeout="'+timeout+'" />');
		var buttonsXml = new XML('<Buttons/>');
		var textsXml = new XML('<Texts/>');
		var backgroundXml = new XML('<Background brush="White"/>')
	
		backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");
		screenXml.appendChild(backgroundXml);
	
		buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_OK"), "-1", "-1", "20", "20", "160", "56", "Red", "10", "ok", "3", "LightGray");
		screenXml.appendChild(buttonsXml);

		textsXml = GenericScreen_AddText(textsXml, msgText, "35", "84", "-1", "-1", "400", "-1", "Red", "Arial", "36px");
		screenXml.appendChild(textsXml);
		GenericScreen_CreateScreen(screenXml);	
	}	

	var screenXml = new XML('<GenericScreen name="totalScreen" transition="goForwardTransition" sound="" soundDelay="" timeout="'+timeout+'" />');
	var textsXml = new XML('<Texts/>');
	var boxesXml = new XML('<Boxes/>');
	var buttonsXml = new XML('<Buttons/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");
	screenXml.appendChild(backgroundXml);

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_TOTAL"), "35", "-1", "-1", "680", "400", "-1", "Black", "Arial", "36px");
	textsXml = GenericScreen_AddText(textsXml, totalDue, "-1", "-1", "35", "680", "-1", "-1", "Red", "Arial", "48px");
	screenXml.appendChild(textsXml);

	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_PAY_HERE"), "35", "190", "-1", "-1", "190", "190", "Red", "15", "here");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_PAY_AT_COUNTER"), "255", "190", "-1", "-1", "190", "190", "Red", "15", "atCounter");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_CANCEL"), "20", "-1", "-1", "20", "160", "56", "Gray", "10", "cancel", "3", "LightGray", MCD_SOUND_CANCEL);
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_BACK"), "190", "-1", "-1", "20", "160", "56", "Gray", "10", "back", "3", "LightGray");
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "here", "5", "234", "0.6", "4");
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "atCounter", "5", "234", "0.6", "4");
	screenXml.appendChild(buttonsXml);
	
	var ctx = new SessionContext;
	ctx.set("back", "false");
	var pressedButton = null;
	while (true) {
		pressedButton = GenericScreen_CreateScreen(screenXml);
		if(pressedButton == null) {
			// Timeout. Continue?
			var cont = PosMCDScreenContinueJS("15");
			if(!cont){
				return false;
			}
		}
		else {
			break;
		}
	}

	var ret = false;
	switch(pressedButton) {
		case "here":
			API.dbg("[PosMCDScreenChoosePaymentJS] - cashless payment chosen");
			ctx.set("isTender", "true");
			ret = true;
			break;
		case "atCounter":
			API.dbg("[PosMCDScreenChoosePaymentJS] - payment at counter chosen");
			ctx.set("isTender", "false");
			ret = true;
			break;
		case "cancel":
			API.dbg("[PosMCDScreenChoosePaymentJS] - cancel button pressed");
			ret = false;
			break;
		case "back":
			API.dbg("[PosMCDScreenChoosePaymentJS] - back button pressed");
			ctx.set("back", "true");
			ret = false;
			break;
		default:
			API.dbg("PosMCDScreenChoosePaymentJS - invalid button pressed: "+pressedButton);
			ret = false
			break;
	}
	return ret;
}

/** PosMCDScreenSwipeCardJS
 *
 * @brief - This BC creates and shows a screen with a text and a image, asking the user to swipe a card. Note that this screen is
 * assynchronous. Due to this fact, this screen cannot have any buttons. It is shown until another screen is shown.
 * @return - true aways
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_SWIPE_CARD: Text asking the user to swipe/tap a card
 *
 */
function PosMCDScreenSwipeCardJS() {
	var screenXml = new XML('<GenericScreen name="swipeCard" transition="goForwardTransition" sound="" soundDelay="" timeout="" />');
	var textsXml = new XML('<Texts/>');
	var animatedImagesXml = new XML('<AnimatedImages/>');

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_SWIPE_CARD"), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);

	animatedImagesXml = GenericScreen_AddAnimatedImage(animatedImagesXml, "MCD_CardRedArrowSide.png", "-1", "248",  "72", "-1", "215", "216", "horizontal", "50");
	screenXml.appendChild(animatedImagesXml);

	lSetScreen(screenXml);
	lShowScreen("swipeCard");
	return true;
}

/** PosMCDScreenMixedOrderJS
 *
 * @brief - This BC creates and shows a screen informing the user that the current order has two pickup counters. This screen does not have a timeout.
 * @param - timeout - string - screen timeout in seconds
 * @return - true aways
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_MIXED_ORDER: Text describing that the order has more than one pickup counter
 *				MCD_MSG_NEXT: Text for the "next" button
 */
function PosMCDScreenMixedOrderJS(timeout) {
	var screenXml = new XML('<GenericScreen name="mixedOrderScreen" transition="goForwardTransition" sound="'+MCD_PAYMENT_PROMPT+'" soundDelay="" timeout="'+timeout+'" />');
	var buttonsXml = new XML('<Buttons/>');
	var imagesXml = new XML('<Images/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	// Shows a blank screen so that this screen will not be displayed on top of another.
	lShowScreen("blankScreen");
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");
	screenXml.appendChild(backgroundXml);
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_NEXT"), "-1", "-1", "20", "20", "160", "56", "Red", "10", "next", "3", "LightGray");
	screenXml.appendChild(buttonsXml);

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_MIXED_ORDER"), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);

	if (PosCheckSessionProperty("hasFC", "true") && PosCheckSessionProperty("hasMCC", "true")) {
		imagesXml = GenericScreen_AddImage(imagesXml, "MCD_Mixed_MCD.png", "0", "0", "-1", "-1", "480", "800");
		imagesXml = GenericScreen_AddImage(imagesXml, "MCD_Mixed_MCC.png", "0", "0", "-1", "-1", "480", "800");
	} else if (PosCheckSessionProperty("hasFC", "true")) {
		API.dbg("PosMCDScreenMixedOrderJS - Skip screen - FC only");
		return true;
	} else if (PosCheckSessionProperty("hasMCC", "true")) {
		imagesXml = GenericScreen_AddImage(imagesXml, "MCD_Mixed_MCC.png", "-120", "0", "120", "-1", "480", "800");
	}
	
	screenXml.appendChild(imagesXml);
	
	var pressedButton = null;
	//NPM-386 - MOT: The order is finished and print out occurs even if customer presses not to continue 
	if(PosCheckSessionProperty("isTender", "true")) {
		GenericScreen_CreateScreen(screenXml);
		//Order paid. Always return true. No "Do you wish to continue?" popup
		return true;
	}
	else {
		while (true) {
			pressedButton = GenericScreen_CreateScreen(screenXml);
			if(pressedButton == null) {
				// Timeout. Continue?
				var cont = PosMCDScreenContinueJS("15");
				if(!cont){
					return false;
				}
			}
			else {
				break;
			}
		}
	}

	return true;
}

/** PosMCDScreenOrderNumberJS
 *
 * @brief - This BC creates and shows a screen asking the user to take the receipt and wait the order at Order Ready screen.
 * @param - timeout - string - screen timeout in seconds
 * @return - true aways
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_START: Text for the "start" button
 *				MCD_MSG_ORDER_NUMBER: Text asking the user to take the receipt
 */
function PosMCDScreenOrderNumberJS(timeout) {
	var screenXml = new XML('<GenericScreen name="orderNumberScreen" transition="goForwardTransition" sound="'+MCD_SOUND_ORDER_COMPLETE+'" soundDelay="1000" timeout="'+timeout+'" />');
	var imagesXml = new XML('<Images/>');
	var animatedImagesXml = new XML('<AnimatedImages/>');
	var textsXml = new XML('<Texts/>');

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_ORDER_NUMBER"), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);
	
	imagesXml = GenericScreen_AddImage(imagesXml, "MCD_OrderNumberScreen.png", "0", "0", "-1", "-1", "480", "800");
	imagesXml = GenericScreen_AddImage(imagesXml, "MCD_OrderReadyTicket.png", "-15", "0", "-1", "-1", "480", "800");
	screenXml.appendChild(imagesXml);
	
	animatedImagesXml = GenericScreen_AddAnimatedImage(animatedImagesXml, "MCD_OrderReadyRedArrowDown.png", "-1", "-1", "19", "132", "234", "223", "vertical", "50");
	screenXml.appendChild(animatedImagesXml);

	GenericScreen_CreateScreen(screenXml);

	return true;
}

/** PosMCDScreenRetryJS
 *
 * @brief - This BC creates and shows a screen when the cashless payment failed. The screen shows three options: retry, pay in front counter,
 * or cancel the order.
 * @param - timeout - string - screen timeout in seconds
 * @return - true if the user clicks in any button. false if the timeout is reached and the user chooses not to continue
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_PAYMENT_FAIL: Text describing the payment failure
 *				MCD_MSG_RETRY: Text for the "retry" button
 *				MCD_MSG_PAY_IN_FC: Text for the "pay in front counter" button
 *				MCD_MSG_CANCEL_ORDER: Text for the "cancel" button
 *
 */
function PosMCDScreenRetryJS(timeout) {
		
	var screenXml = new XML('<GenericScreen name="selectSaleType" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_IS_ORDER_CORRECT+'" soundDelay="" timeout="'+timeout+'" />');
	var buttonsXml = new XML('<Buttons/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	var ctx = new SessionContext;
	
	var numEftAttempts = getRetryNumber(ctx);
	var maxEftAttempts = getMaxRetryAttempts();
	
	ctx.set("isRetry", "false");
	ctx.set("payAtFC", "false");
	ctx.set("eftFailed", "false");
	ctx.set("isCancel", "false");
	
	if (numEftAttempts >= maxEftAttempts) {
		API.dbg("[PosMCDScreenRetryJS] - Max number of eft attempts reached.");
		ctx.set("eftFailed", "true");
		return true;
	}
	
	// Shows a blank screen so that this screen will not be displayed on top of another.
	lShowScreen("blankScreen");
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_PAYMENT_FAIL"), "35", "84", "-1", "-1", "400", "-1", "Red", "Arial", "36px");
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_RETRY"), "35", "190", "-1", "-1", "190", "190", "Red", "15", "retry");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "28px", lGetI18nMessage("MCD_MSG_PAY_IN_FC"), "255", "190", "-1", "-1", "190", "190", "Red", "15", "payAtFC");
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_CANCEL"), "20", "-1", "-1", "20", "160", "56", "Gray", "10", "cancel", "3", "LightGray", MCD_SOUND_CANCEL);
	
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "retry", "5", "234", "0.6", "4");
	buttonsXml = GenericScreen_AddDropShadow(buttonsXml, "payAtFC", "5", "234", "0.6", "4");
	
	screenXml.appendChild(backgroundXml);
	screenXml.appendChild(textsXml);
	screenXml.appendChild(buttonsXml);

	var pressedButton = null;
	while (true) {
		pressedButton = GenericScreen_CreateScreen(screenXml);
		if(pressedButton == null) {
			// Timeout. Continue?
			var cont = PosMCDScreenContinueJS("15");
			if(!cont){
				return false;
			}
		}
		else {
			break;
		}
	}
	
	switch(pressedButton) {
		case "retry":
			API.dbg("[PosMCDScreenRetryJS] - retry button chosen");
			numEftAttempts++;
			ctx.set("numRetryAttempts", numEftAttempts);
			ctx.set("isRetry", "true");
			break;
		case "payAtFC":
			API.dbg("[PosMCDScreenRetryJS] - payAtFC button chosen");
			ctx.set("payAtFC", "true");
			break;
		case "cancel":
			API.dbg("[PosMCDScreenRetryJS] - cancel button chosen");
			ctx.set("isCancel", "true");
			break;
		default:
			API.dbg("[PosMCDScreenRetryJS] - invalid button: "+pressedButton);
			break;
	}
	
	return true;
	
	/**
	 * @brief - Get the number of EFT payments attempts from the contex. If no attempt was made so far, returns 1.
	 * @param - ctx - SessionContext
	 * @returns - An integer with the number of EFT payment attempts.
	 * @author - Felipe Armoni
	 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
	 */
	function getRetryNumber(ctx) {
		
		var retryNum = ctx.get("numRetryAttempts");
		if (retryNum == "" || retryNum == undefined) {
			retryNum = 1;
		
		} else {
			retryNum = toInt(retryNum);
			
		}
		
		return retryNum;
	}
	
	/**
	 * @brief - Get the maximum number of EFT payment attempts that the user can make. This number is configured on the tag: 
	 * <Parameter name="maxNumberOfEFTAttempts" value="3" /> of the store-db.xml.
	 * If this tag does not exists or if its value is invalid (less than 0, greater than 9 or not a number) than the returned value is the default setting: 3.
	 * @returns - An integer with the maximum number of attempts.
	 * @author - Felipe Armoni
	 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
	 */
	function getMaxRetryAttempts(){
		
		var maxAttempts = rootStoreDB.Configurations.Configuration.(@type == "POS").Section.(@name == "CSO.UserInterface").Parameter.(@name == "maxNumberOfEFTAttempts").@value;
		
		if ((maxAttempts == undefined) || isNaN(maxAttempts)) {
			maxAttempts = 3;
		
		} else if (maxAttempts > 9 || maxAttempts < 0) {
			maxAttempts = 3;
		
		} else {
			maxAttempts = parseInt(maxAttempts);
			
		}
		
		return maxAttempts;
	}
}

/** PosMCDScreenDiscardOrderJS
 *
 * @brief - This BC creates and shows a screen with a message that the order was discarded
 * @param - timeout - string - screen timeout in seconds
 * @return - true aways
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 *				MCD_MSG_DISCARD_ORDER: Text saying that the order was discarded
 *
 */
function PosMCDScreenDiscardOrderJS(timeout) {
	var screenXml = new XML('<GenericScreen name="discardScreen" transition="fadeAndGrowPopupTransition" sound="" soundDelay="" timeout="'+timeout+'" />');
	var textsXml = new XML('<Texts/>');

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_DISCARD_ORDER"), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);

	GenericScreen_CreateScreen(screenXml);

	return true;
}

/** PosMCDScreenStoreOrder
 *
 * @brief - This BC creates and shows a screen with a message for the user to take the receipt and and proceed to any open register.
 * This screen is shown when the user chooses to pay the order at the front counter.
 * @param - timeout - string - screen timeout in seconds
 * @return - true aways
 * @author - Raphael Almeida
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 * @remarks - Property Messages:
 * 				MCD_MSG_START: Text for the "start" button
 *				MCD_MSG_TAKE_TICKET: Text asking the user to take te receipt and proceed to any open register
 *
 */
function PosMCDScreenStoreOrder(timeout) {
	var screenXml = new XML('<GenericScreen name="storeScreen" transition="goForwardTransition" sound="'+MCD_SOUND_ORDER_COMPLETE+'" soundDelay="1000" timeout="'+timeout+'" />');
	var imagesXml = new XML('<Images/>');
	var animatedImagesXml = new XML('<AnimatedImages/>');
	var textsXml = new XML('<Texts/>');

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_MSG_TAKE_TICKET"), "35", "84", "-1", "-1", "400", "-1", "Black", "Arial", "36px");
	screenXml.appendChild(textsXml);

	imagesXml = GenericScreen_AddImage(imagesXml, "MCD_Ticket.png", "35", "260", "-1", "-1", "195", "319");
	screenXml.appendChild(imagesXml);
	
	animatedImagesXml = GenericScreen_AddAnimatedImage(animatedImagesXml, "MCD_RedArrowDown.png", "-1", "-1", "15", "69", "234", "223", "vertical", "50");
	screenXml.appendChild(animatedImagesXml);

	GenericScreen_CreateScreen(screenXml);

	return true
}

/** PosMCDSleepJS
 * 
 * @brief - Waits for a given time.
 * Please note that the waiting is done in the GUI, because since Javascript does not support methods like Thread.Sleep, then a synchronous message
 * is sent to the GUI and the Thread.Sleep method is called there. When the time is done control is returned to the NewPOS.
 * @param - string - time - Time to wait in miliseconds
 * @returns - Always true
 * @author - Felipe Armoni
 * @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
 */
function PosMCDSleepJS(time) {
	
	API.dbg("Sleeping: " + time + " miliseconds");
	lMCDSendSyncMessage("SYNC_SLEEP", new Array(), new Array(), time);
	
	return true;
}

/**
 *
 * @brief - This function activates or deactivates the auto close for asynchronous screens.
 * Note: deactivating the auto close means that the Check In Device will ignore "DLG_MSG_STOP" events, therefore opened async screens must be 
 * closed by the user.
 * @param - boolean - autoClose - If true, activates the auto close for asynchronous screens, if false, deactivates it.
 * @returns - Always true.
 * @autor - Felipe Armoni
 * @since - NPM-451 - Apply Update (During POS Open or Forced) leaves the Check-In Device with screen 'Apply update is running' 
 */
function PosMCDSetAsyncScreenAutoCloseJS(autoClose) {
	
	var params = new Array();
	var messageXml;
	
	params.push("autoClose|" + autoClose);

	messageXml = lCreateMCDEvent("ASYNC", "DLG_SYS_SET_ASYNC_SCREEN_AUTO_CLOSE", params);

	PosSendUICmd(messageXml);
	
	return true;
}

/** PosMCDVoidSaleJS
 *
 * @brief - This BC checks if there is an order in progress and voids it.
 * @return - true if the order was sucessfully voided. false if there is no order to void, or if the order could not be voided
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
function PosMCDVoidSaleJS() {
	var isInProgress = (!PosNotATransactionInProgress("true"));

	var hlp = new BusinessObjectHelper;
	var currentView = hlp.getCurrentView();

	if(currentView != null && isInProgress) {
		API.dbg("PosMCDVoidSaleJS - Voiding current sale...");
		return PosDoVoidSale(false, false);
	}
	API.dbg("PosMCDVoidSaleJS - There is no order to void");
	return false;
}

/** PosMCDStoreRecallJS
 *
 * @brief - This BC stores and recalls the current order. This BC must be called immediately AFTER the cashless payment approval
 * and BEFORE setting the session contexts CASHLESS, CASHLESS_STATUS, CASHLESS_TENDERID, CASHLESS_VALUE and CASHLESS_PROVIDER in the cashless
 * script PosCashlessPayment.
 * @return - true if the order was successfully stored and recalled. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
function PosMCDStoreRecallJS() {
	var hlp = new BusinessObjectHelper;
	
	var pod = hlp.findParamInSectionConfig("POD","PosType");
	if (pod != "CSO") {
		return true;
	}

	if(PosAreAllReqSrvsAvailable()) {
		var view = new XML(hlp.getCurrentView());
		var ret = PosDoStore();
		API.dbg("PosMCDStoreRecallJS - PosDoStore returned: "+ret);
		if(PosRecallNextOrder("",view.@orderKey)) {
			ret = PosDoTotal();
			API.dbg("PosMCDStoreRecallJS - PosDoTotal returned: "+ret);
			return true;
		}
		else {
			API.dbg("PosMCDStoreRecallJS - Unable to recall order from production");
		}
	}
	else {
		API.dbg("PosMCDStoreRecallJS - WARNING!!! REQUIRED SERVICES ARE NOT ONLINE. The order may NOT appear in KVS!");
	}
	return false;
}

/** PosMCDBarCodeReadErrorJS
 *
 * @brief - This BC shows an error message, when the barcode could not be read. This BC is called by WF_BarCodeReadError workflow
 * @param - timeout - string - screen timeout in seconds
 * @return - true aways
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 * @remarks - Property Messages:
 *				MCD_BARCODE_ERROR: Error message to be displayed
 */
function PosMCDBarCodeReadErrorJS(timeout) {
	var screenXml = new XML('<GenericScreen name="errorScreen" transition="fadeAndGrowTransition" sound="'+MCD_SOUND_IS_ORDER_CORRECT+'" soundDelay="" timeout="'+timeout+'" />');
	var buttonsXml = new XML('<Buttons/>');
	var textsXml = new XML('<Texts/>');
	var backgroundXml = new XML('<Background brush="White"/>')
	
	backgroundXml = GenericScreen_AddBackgroundDivision(backgroundXml, "Black", "0", "705", "480", "95");
	screenXml.appendChild(backgroundXml);
	
	buttonsXml = GenericScreen_AddButton(buttonsXml, "24px", lGetI18nMessage("MCD_MSG_OK"), "-1", "-1", "20", "20", "160", "56", "Red", "10", "ok", "3", "LightGray");
	screenXml.appendChild(buttonsXml);

	textsXml = GenericScreen_AddText(textsXml, lGetI18nMessage("MCD_BARCODE_ERROR"), "35", "84", "-1", "-1", "400", "-1", "Red", "Arial", "36px");
	screenXml.appendChild(textsXml);
	
	var pressedButton = null;
	while (true) {
		pressedButton = GenericScreen_CreateScreen(screenXml);
		if(pressedButton == null) {
			// Timeout. Continue?
			var cont = PosMCDScreenContinueJS("15");
			if(!cont){
				return true;
			}
		}
		else {
			break;
		}
	}
	
	if(pressedButton == "ok") {
		API.dbg("PosMCDBarCodeReadErrorJS - ok pressed");
	}

	return true;
}

/** PosMCDCreateDirJS
 *
 * @brief - This BC creates a directory, one level up the bin directory, i.e. on the same level as PosData directory. It also create the control files ctr_fail.dat amd ctr_success.dat
 * @param - directoryName - string - directory name
 * @return - true if the directory was successfully created, or if it already exists. False if it could not be created
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
 function PosMCDCreateDirJS(directoryName) {
	var path = "../"+directoryName+"/";
	var ret = File.createDir(path);
	API.dbg("PosMCDCreateDirJS - ret: "+ret);
	var ctx = new SessionContext;
	ctx.set("MCDDirectoryPath",path,true);
	if(ret > 0 || ret == 0) {
		API.dbg("PosMCDCreateDirJS - directory created successfully or already exists");
		// creates also control file
		if(!File.exists(path+"ctr_success.dat")) {
			var controlFile = new File(path+"ctr_success.dat");
			if(controlFile.open("w")){
				controlFile.write("0");
				controlFile.close();
				API.dbg("PosMCDCreateDirJS - ctr_success.dat created successfully");
			}
		}
		if(!File.exists(path+"ctr_fail.dat")) {
			var controlFile = new File(path+"ctr_fail.dat");
			if(controlFile.open("w")){
				controlFile.write("0");
				controlFile.close();
				API.dbg("PosMCDCreateDirJS - ctr_fail.dat created successfully");
			}
		}
		return true;
	}

	API.dbg("PosMCDCreateDirJS - error creating directory");
	return false;
 }

/** PosMCDSaveFailViewJS
 *
 * @brief - This BC saves the barcode view when the order could not be sold. The file is saved in the directory created by PosMCDCreateDirJS
 * @return - true if file was successfully saved. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
 function PosMCDSaveFailViewJS() {
	var ctx = new SessionContext;
	var path = ctx.get("MCDDirectoryPath");
	if(!File.exists(path+"ctr_fail.dat")) {
		var newControlFile = new File(path+"ctr_fail.dat");
		if(newControlFile.open("w")) {
			newControlFile.write("0");
			newControlFile.close();
			API.dbg("PosMCDSaveFailViewJS - ctr_fail.dat created successfully");
		}
	}

	var fileNameCount;
	var controlFile = new File(path+"ctr_fail.dat");
	if(controlFile.open("r")) {
		fileNameCount = Number(controlFile.read());
		var tempCount = fileNameCount + 1;
		controlFile.close();
		controlFile.open("w");
		controlFile.write(tempCount.toString());
		controlFile.close();
	}
	else {
		API.dbg("PosMCDSaveFailViewJS - error reading ctr_fail.dat");
		return false;
	}
	var fileNamePattern = "MobileViewFail_";

	var fileName = fileNamePattern+fileNameCount.toString()+".xml";
	API.dbg("PosMCDSaveFailViewJS - fileName: "+fileName);

	if(File.exists(path+fileName)) {
		// there is something wrong
		API.dbg("PosMCDSaveFailViewJS - file "+fileName+" already exists");
		return false;
	}
	var viewFile = new File(path+fileName);
	if(viewFile.open("w")) {
		viewFile.write(ctx.get("MCDView"));
		viewFile.close();
	}
	else {
		API.dbg("PosMCDSaveFailViewJS - error opening file: "+fileName);
		return false;
	}

	return true;
 }

/** PosMCDSaveSuccessViewJS
 *
 * @brief - This BC saves the barcode view for successful orders. The file is saved in the directory created by PosMCDCreateDirJS
 * @return - true if file was successfully saved. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
 function PosMCDSaveSuccessViewJS() {
	var ctx = new SessionContext;
	var path = ctx.get("MCDDirectoryPath");
	if(!File.exists(path+"ctr_success.dat")) {
		var newControlFile = new File(path+"ctr_success.dat");
		if(newControlFile.open("w")) {
			newControlFile.write("0");
			newControlFile.close();
			API.dbg("PosMCDSaveSuccessViewJS - ctr_success.dat created successfully");
		}
	}

	var fileNameCount;
	var controlFile = new File(path+"ctr_success.dat");
	if(controlFile.open("r")) {
		fileNameCount = Number(controlFile.read());
		var tempCount = fileNameCount + 1;
		controlFile.close();
		controlFile.open("w");
		controlFile.write(tempCount.toString());
		controlFile.close();
	}
	else {
		API.dbg("PosMCDSaveSuccessViewJS - error reading ctr_success.dat");
		return false;
	}

	var fileNamePattern = "np6View_";

	var fileName = fileNamePattern+fileNameCount.toString()+".xml";
	API.dbg("PosMCDSaveSuccessViewJS - fileName: "+fileName);

	if(File.exists(path+fileName)) {
		// there is something wrong
		API.dbg("PosMCDSaveSuccessViewJS - file "+fileName+" already exists");
		return false;
	}
	
	var hlp = new BusinessObjectHelper;
	var view = new XML(hlp.getLastSaleView());
	
	var viewFile = new File(path+fileName);
	if(viewFile.open("w")) {
		viewFile.write("<MobTld>\n" + ctx.get("MCDView") + "\n" + view.toXMLString() + "\n</MobTld>");
		viewFile.close();
	}
	else {
		API.dbg("PosMCDSaveSuccessViewJS - error opening file: "+fileName);
		return false;
	}
	return true;
 }

/** PosMCDEnqueueWFExecutionJS
 *
 * @brief - This BC enqueue a workflow to be excuted after the current finishes its execution. To execute the workflow, call PosMCDExecuteWFFromQueueJS
 * @param - WFName - string - name of the workflow to be executed
 * @return - true if the command was successfully sent to the UI. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDEnqueueWFExecutionJS(WFName) {
	var eventXml = new XML('<Event type="ASYNC" name="DAT_SYS_ENQUEUEWF" />');
	eventXml.appendChild(new XML('<WFName>'+WFName+'</WFName>'));

	return PosSendUICmd(eventXml.toString());
}

/** PosMCDExecuteWFFromQueueJS
 *
 * @brief - This BC executes the workflow enqueued by PosMCDEnqueueWFExecutionJS
 * @return - true if the command was successfully sent to the UI. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDExecuteWFFromQueueJS() {
	return PosSendUICmd('<Event type="ASYNC" name="DAT_SYS_DEQUEUEWF" />');
}

/** PosMCDIsTrnInProgressJS
 *
 * @brief - This BC checks if there is a transaction in progress.
 * @param - isSilenceMode - string - "true" to show a message MSG_BC_NO_ORDER_IN_PROGRESS, "false" not to show
 * @return - true if there is transaction in progress. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDIsTrnInProgressJS(isSilenceMode) {
	var isInProgress = (!PosNotATransactionInProgress("true"));

	if (isInProgress) {
		return true;
	} else {
		if (isSilenceMode == 'false') {
			PosShowMessage("MSG_BC_NO_ORDER_IN_PROGRESS");
		}
		return false;
	}
}

/** PosMCDSetDefaultLanguageJS
 *
 * @brief - This BC sets the default language for the Mobile Check-in Device UI
 * @return - true aways
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDSetDefaultLanguageJS() {
	if (!PosNotATransactionInProgress("false")) {
		PosShowMessage("Trasaction In progress");
	}

	if(rootStoreDB == null) {
		loadStoreDB();
	}
	var countryId 	= rootStoreDB.StoreDB.StoreProfile.Localization.CountryId;
	var language 	= rootStoreDB.StoreDB.StoreProfile.Localization.Language;
	API.dbg("[PosMCDSetDefaultLanguageJS] - Reseting to the default language: [" + countryId + "_" + language + "]");
	PosMCDSetLanguageJS(countryId, language);
	return true;
}

/** PosMCDSetLanguageJS
 *
 * @brief - This BC sets the language for the Mobile Check-in Device
 * @param - country - string - country ID of the langauge, as defined in "localization" section, in store-db.xml
 * @param - language - string - language, as defined in "localization" section, in store-db.xml
 * @return - true if the command was successfully sent to the UI. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDSetLanguageJS(country, language) {
	API.dbg("[PosMCDSetLanguageJS]");
	var xmlResult = new StringBuffer();

	newLanguage = language+"_"+country;
    API.dbg("[CSO - PosSetLanguageJS] Current language: [" + newLanguage + "].");
	var ctx = new SessionContext;
	ctx.set("LANGUAGE", newLanguage);
	PosSetLanguage(country, language);
	xmlResult.append(GLOBAL_UTF8_PROLOG_XML);
	xmlResult.append("<Event type=\"ASYNC\" name=\"DAT_SYS_CURRENT_LANGUAGE\">\n");
	xmlResult.append("\t<Parameter name='I18N' value=\""+newLanguage+"\"/>\n");
    xmlResult.append("\</Event>");

	return PosSendUICmd(xmlResult.toString());
}

/** PosMCDGoHomeJS
 *
 * @brief - This BC shows voids current order and shows the main screen
 * @return - true aways
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDGoHomeJS() {
	PosMCDVoidSaleJS();
	
	// @since - MOT-78 - Check-In Device Screens Redesign (screen orientation moved from Landscape to Portrait)
	// If an exception occurred on the last sale, the main screen will not have a sound.
	if (PosCheckSessionProperty("SaleSuccess", "true")) {
		lShowScreenWithSound("MainScreen", MCD_SOUND_GREETING);
		PosSetSessionProperty("SaleSuccess", "false");
	
	} else {
		lShowScreen("MainScreen");
		
	}
	
	
	return true;
}

/** PosMCDDoStopWhenOnGrillModeJS
 *
 * @brief - This BC checks if the order is in grill mode.
 * @return - true if the order is not on grill mode. false otherwise
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 *
 */
function PosMCDDoStopWhenOnGrillModeJS() {
	var hlp = new BusinessObjectHelper;
	var isOnGrill = hlp.isGrilling();
	return (!isOnGrill);
}

/** PosMCDOrderItemJS
 * @brief - Performs a sale on Check-in device.
 * First, the BC gets the xml view from the barcode reader adaptor. Then validates all items, by calling lIsValidProduct for each item in
 * the view. If any of the items is invalid (see lIsValidProduct for details), or if the country code from the view does not match the one
 * defined in the store-db.xml, this BC sets "MCDView" session context with the status of each product, and returns false.
 * If all items are valid the BC sells them and perform all grill and choices actions.
 * This BC also sets "isMixedOrder" session context to either "true" or "false": "true" if there is MCCafe items, "false" otherwise
 * This session context is checked later in the workflow and in report function
 * @param - source - string - barcode reader adaptor source name
 * @param - id - string - barcode id
 * @return - true if sale is ok. false if unable to sell (unavailable items, invalid country code, etc.)
 * @author - Raphael Almeida
 * @since - SDO-4013 - Implement Mobile Check-in Device
 */
function PosMCDOrderItemJS(source, id) {
	var ret;

	API.dbg("PosMCDOrderItemJS - source: "+source+" id: "+id);

	if (!PosNPSExtRequestCmd("BarCodeProcess", "Read", source, id)) {
		//PosShowMessage(getLastFail("PosNPSExtRequestCmd"));
		API.dbg(getLastFail("PosNPSExtRequestCmd"))
		return false;
	}
	// get result as Encoded xml (some xml symbols are removed to be able to use getLastSuccess)
	var xmlEncode = getLastSuccess("PosNPSExtRequestCmd");
	
	var mobileView = new MCDMobileView(xmlEncode.toString());
	
	var view = mobileView.getView();
	
	API.dbg("PosMCDOrderItemJS - Received view: " + view);

	var ctx = new SessionContext;
	
	API.dbg("PosMCDOrderItemJS - Validating the received view.");
	
	if (!mobileView.Validate()) {
		API.dbg("PosMCDOrderItemJS - The current view has one or more invalid items.");
		
		ctx.set("MCDView", view.toXMLString(), true);
		return false;
	} else {
		API.dbg("PosMCDOrderItemJS - The current view is valid.");
		ctx.set("MCDView", view.toXMLString());
	}	
	
	//MOT-362 - Checking Basic promotions	
	API.dbg("PosMCDOrderItemJS - Checking Basic promotions ");
	if (mobileView.CheckAllBasicPromotions() == false)
	{
		API.dbg("PosMCDOrderItemJS -  - One or more products are not in the promotional period.");
		return false;
		
	}else{
		API.dbg("PosMCDOrderItemJS -  - One or more products are in the promotional period.");
	}	

	API.dbg("PosMCDOrderItemJS - Processing the current view.");
	mobileView.ProcessView();
	
	// Check if the sale was really successfull (a Grill error could have happenened).
	if (!mobileView.areAllItemsValid()) {
		
		API.dbg("PosMCDOrderItemJS - There was an error while processing the current view. At least one item turned out to be invalid.");
		
		// Try to void the current sale.
		ret = PosDoVoidSale(false, false);
		if (ret != true)
			API.dbg("PosMCDOrderItemJS - ERROR - An error occurred while voiding the current sale.");
		else
			API.dbg("PosMCDOrderItemJS - The current sale was successfully voided.");
		
		ret = false;
	
	} else {
		API.dbg("PosMCDOrderItemJS - The current view was successfully processed.");
		ret = true;
	}
	
	//Checking if there is any PromotionProductCode at product-db.xml
	if (ret != true)
	{
		API.dbg("PosMCDOrderItemJS - ERROR - An error occurred while applying promotional discount.");
		ret = false;
	}
	else{
		API.dbg("PosMCDOrderItemJS - The current sale is a promotional one.");
		ret = true;
	}

	//Checking if there is any PromotionalDiscountTable at store.wide
	API.dbg("PosMCDOrderItemJS -  - Checking if there is any PromotionalDiscountTable at store.wide .");
	var totalOrderBD = Number(view.@totalPrice);		
	var totalAfterDiscount = mobileView.ApplyDiscount(totalOrderBD);		

	if (!totalAfterDiscount){
		API.dbg("PosMCDOrderItemJS - totalAfterDiscount: " + totalAfterDiscount);		
	}	

	return ret;
}

function OnGetPromotional(productNode, productCode) 
{
	var ret = false;
	if( productNode.CustomParameters.Parameter.(@name=="PromotionProductCode").@value.toString() != ""  &&
			  productNode.CustomParameters.Parameter.(@name=="PromotionProductCode").@value.toString() != undefined &&
			  productNode.CustomParameters.Parameter.(@name=="PromotionProductCode").@value.toString() != null)
	{			
		API.dbg("[OnGetPromotional] -  Has PromotionProductCode at product-db.xml ?");
		var tokenPromo = productNode.CustomParameters.Parameter.(@name=="PromotionProductCode").@value.toString().split("|");
		
		for each(var codePromo in tokenPromo)
		{
			API.dbg("[OnGetPromotional] -  - Validating PromotionalProductCode: " + codePromo + " .");
			productPromo = productDictionary[codePromo];		
			
			if (productPromo != undefined && productPromo != null && productPromo != "")
			{
				if (this.onValidateTimeBase(productPromo, productCode))
				{	
					//replace original with the new promotional one
					API.dbg("[CheckBasicPromotions] [ReplaceProduct] -  Product: " + productCode + " replaced by: " + codePromo);										
					ret = true;
					return Number(codePromo);
				}
			}
		}
		API.dbg("[OnGetPromotional] -  Validating finished");
	}		
	return ret;
}
	
	
function onValidateTimeBase (productNodeDb, productCode)
{
	// - Basic Promotions - TimeFrame validating
	var ret = false;
	API.dbg("[onValidateTimeBase] -  started");
	//var productNode = productDictionary[productCode];		
	
	if (productNodeDb.CustomParameters.Parameter.(@name=="IsPromotional").@value.toString() == "true")
	{		
		//API.dbg("[ValidateTimeBase] productNode: " + productNodeDb);
		if (productNodeDb.CustomParameters.Parameter.(@name=="PromotionStartDate").@value.toString() != undefined 	&&
			productNodeDb.CustomParameters.Parameter.(@name=="PromotionStartDate").@value.toString() != null 		  	&&
			productNodeDb.CustomParameters.Parameter.(@name=="PromotionStartDate").@value.toString() != ""		  	&&
			
			productNodeDb.CustomParameters.Parameter.(@name=="PromotionEndDate").@value.toString() != undefined	 	&&
			productNodeDb.CustomParameters.Parameter.(@name=="PromotionEndDate").@value.toString() != null 			&&
			productNodeDb.CustomParameters.Parameter.(@name=="PromotionEndDate").@value.toString() != "" )
		{			
			
			var promoStartDate = productNodeDb.CustomParameters.Parameter.(@name=="PromotionStartDate").@value.toString();						
			var promoEndDate = productNodeDb.CustomParameters.Parameter.(@name=="PromotionEndDate").@value.toString();									
		
			if (!isInDateInRange(promoStartDate, promoEndDate))
			{
				API.STTErrorLog("0", "[CheckBasicPromotions] - Product "+ productCode +" is not in a valid promotion period", BC_EVENTS_NAME);
				return false;						
			}
		}
		
		var weekDayRule = productNodeDb.CustomParameters.Parameter.(@name==getDayAsTagName()).@value.toString();
		if (!lIsInTimeRestriction(weekDayRule) || weekDayRule == "Disable" )
		{					
			API.dbg("0", "[CheckBasicPromotions] - Product "+ productCode +" is not in a valid promotion timeframe or it is disabled");
			API.dbg("0", "[CheckBasicPromotions] - [ - WeekDayRule disabled] - product " + productCode + " is not in a valid promotion timeframe");
			return false;																						
		}
	}	
	return true;
};	

/**
 *
 * @brief - This class validates and process a mobile sale view.
 */
function MCDMobileView(viewStr) {
	var ctx = new SessionContext;
	
	// decode to a "regular" xml object.
	var view = new XML(DecodeToXml(viewStr));
	
	var allItemsInvalid = true;
	var allItemsValid = true;
	
	/** getView
	 *
	 * @brief This method returns the current XML view of this object.
	 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
	 */
	this.getView = function() {
		return view;
	};
	
	/** areAllItemsInvalid
	 *
	 * @brief This method returns the property allItemsInvalid. Its value is true if all the received items are invalid, otherwise it is false.
	 * Note: The value of this property is set by the ValidateItems method, therefore its value will always be true 
	 * until the ValidateItems method is called.
	 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
	 */
	this.areAllItemsInvalid = function() {
		return allItemsInvalid;
	};
	
	/** areAllItemsValid
	 *
	 * @brief This method returns the property allItemsValid. Its value is true if all the received items are valid, otherwise it is false.
	 * Note: The value of this property is set by the ValidateItems method, therefore its value will always be true 
	 * until the ValidateItems method is called.
	 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
	 */
	this.areAllItemsValid = function() {
		return allItemsValid;
	}
	
	/** Validate
	 *
	 * @brief - This method validates the current view.
	 * @returns - True if this view's country and its items are all valid, otherwise false.
	 */
	this.Validate = function() {
		if (!this.ValidateCountry()) {
			return false;
		} else {
			return this.ValidateItems();
		}
	};
	
	/** ValidateCountry
	 *
	 * @brief - This method validates the country of the current view.
	 * @returns - True if the country is valid, otherwise false.
	 */
	this.ValidateCountry = function() {
		if(rootStoreDB == null) {
			loadStoreDB();
		}
		var countryId = rootStoreDB.StoreDB.StoreProfile.Localization.CountryId;
		
		if(view.@CountryId == countryId) {
			API.dbg("[Mobile - ValidateCountry] The countryId of this view is valid. Code: " + view.@CountryId + " Config: " + countryId);
			view.@validCountryCode = "true";
			return true;
		} else {
			API.dbg("[Mobile - ValidateCountry] Invalid countryId. Code: " + view.@CountryId + " Config: " + countryId);
			view.@validCountryCode = "false";
			return false;
		}
	};
	
	// Check all items for Basic Promotions
	this.CheckAllBasicPromotions = function() 
	{
		var ret = true;
		
		// Get the current POD.
		var operation = ctx.get("POD");
		
		API.dbg("[Mobile -  - CheckAllBasicPromotions] Started ");
			
		for each(var product in view.Product) 
		{			
			productNode = productDictionary[product.@productCode.toString()];			
			API.dbg("[Mobile -  - CheckBasicPromotions] Checking Product: " + product.@productCode.toString());			
		
			//When one or more items are not valid, the application will reject the entire order for Checkin-Devices
			//For DT the invalid items will be detailed and the order will be accept
			var productNameToReplace = lMCDGetProductName(product.@productCode);
			if ( productNameToReplace == null 	||
				productNameToReplace == ""		||
				productNameToReplace == undefined)
			{			
				productNameToReplace = product.@productCode;
				API.dbg("[Mobile - ProcessView] - WARNING - Product name not found at names-db.xml for Code: " + product.@productCode);				
			}
			
			if (onValidateTimeBase(productNode, product.@productCode.toString()) == false)
			{
				API.dbg("[Mobile -  - CheckBasicPromotions] Product: " + product.@productCode + " not in promotional");								
				invalidItemsPromo.push(productNameToReplace);				
				if (operation != "DT")
				{
					return false;					
				}				
			}
			itemsPromo.push(productNameToReplace);			
		}		
		API.dbg("[Mobile -  - CheckAllBasicPromotions] Basic Promotions done ");
		
		return ret;		
	};	
	
	

	
	
	/** ValidateItems
	 *
	 * @brief - This method validates all the items of the current view.
	 * @returns - True if all the items are valid, otherwise false.
	 */
	this.ValidateItems = function() {
				
		PosSetSessionProperty("hasFC","false");
		PosSetSessionProperty("hasMCC","false");
	
		API.dbg("[Mobile - ValidateItems] Before validation. Items length: " + view.ItemView.length());
			
		for each(var product in view.Product) {
			this.lDoValidation(product, true);
		}
		
		API.dbg("[Mobile - ValidateItems] After validation. result: " + allItemsValid);
		
		return allItemsValid;		
	};
	
	/** lDoValidation
	 *
	 * @brief - This function validates one item and its children recursively.
	 * Note: if an item is invalid, then all of its children also become invalid.
	 * @param - item - Item to be validated.
	 * @param - parentValidationResult - Result of this item's immediate parent validation.
	 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
	 */
	this.lDoValidation = function(item, parentValidationResult) {
			
		var product;
		var grill;
		var result;
		var children;
		var childValidationResult;
		var component;
		
		// Validate the current item.
		result = this.lIsValidProduct(item, parentValidationResult);
		
		// Validate this item's children (if any).
		children = item.children();
		for each (var child in children) {
		
			// Retrieve the child configuration from the product-db.xml.
			component = GetProductComponent(item.@productCode, child.@productCode);
			
			// Add the required configuration to the child.
			if (component != undefined) {
				child.@defaultQuantity = component.DefaultQuantity;
				child.@minQuantity = component.MinQuantity;
				child.@maxQuantity = component.MaxQuantity;
			}
		
			// Validate the child.
			childValidationResult = this.lDoValidation(child, result);
			
			// Only assign a new value to result if its current value is true. Otherwise hold on to the "false" value to return it as
			// a result of this function.
			if (result)
				result = childValidationResult;
		}

		if (!result)
		{
			for each (var child in children) {
				if(child.@status == MOBILE_ITEM_OK)
					child.@status=MOBILE_ITEM_INV_PARENT;	// Invalid all the items of the VM
			}	
			if(item.@status == MOBILE_ITEM_OK)
					item.@status=MOBILE_ITEM_NOT_AVAILABLE;	// Invalid the main item also
		}

		if (!result)
			allItemsValid = false; // If there is at least one invalid product.
		else
			allItemsInvalid = false; // If there is at least one valid product.

		return result;
	}
	
	/** 
	 * @brief - This method validates if a product/item can be sold in a Mobile Check-in Device
	 * @param - item - xml -  The product node (from MobileView.xml) to be checked
	 * @return - true if the item can be sold, false otherwise
	 * @author - Raphael Almeida
	 * @since - SDO-4013 - Implement Mobile Check-in Device
	 * @remarks
	 *
	 *	- A valid product is:
	 *		- Exists in the catalog;
	 *		- Is salable (for parent items);
	 *		- Is active;
	 *		- Is NOT in the outage file;
	 *		- Is from the same day part (see business limits in the store-db file);
	 *		- Is in time restriction
	 *
	 *	- For each item that will be validated, this method fills a xml, stored in a session context ("MCDView"), containing the product code and item status:
	 *		0 - order item OK
	 *		1 - not in the catalog
	 *		2 - not salable
	 *		3 - inactive
	 *		4 - order item not available (prodoutage.xml)
	 *		5 - invalid day part
	 *		6 - out of time restriction
	 * 		7 - parent product is invalid
	 * 		8 - the current product belongs to the Mc Cafe (Note: Mcc products are not accepted in the DT).
	 */
	this.lIsValidProduct = function(item, parentValidationResult) {
		var productNode = productDictionary[item.@productCode.toString()];
		
		if(productNode == undefined || productNode == null || productNode.toString().length == 0) {
			// not in the catalog
			API.dbg("[lIsValidProduct] - product " + item.@productCode + " not in the catalog");
			item.@status = MOBILE_ITEM_NOT_CATALOG;
		}
		else {
		
			// Get the current POD.
			var operation = ctx.get("POD");
		
			// Check if the current item or grill is a MCC item.
			var value;
			var isMcc
			value = productNode.CustomParameters.Parameter.(@name=="IsMCC").@value.toString();
			if (value == "true" || value == "1") {
				PosSetSessionProperty("hasMCC","true");
				isMcc = true;
			}
			else {
				isMcc = false;
				PosSetSessionProperty("hasFC","true");
			}

			if (productNode.@productClass == "PRODUCT")
				item.@productType = 2;
			else if (productNode.@productClass == "VALUE_MEAL")
				item.@productType = 3;
			else if (productNode.@productClass == "NON_FOOD_PRODUCT")
				item.@productType = 8;
			else if (productNode.@productClass == "COMMENT")
				item.@productType = 6;
			else if (productNode.@productClass == "CHOICE")
				item.@productType = 4;
			else
				item.@productType = 0;

			item.@longName = lMCDGetProductName(item.@productCode.toString()).toString();
			item.@description = item.@longName.toString();

			if (!parentValidationResult) {
				// parent product is invalid
				API.dbg("[lIsValidProduct] - the parent product of " + item.@productCode + " is invalid");
				item.@status = MOBILE_ITEM_INV_PARENT;
			}
			else if (productNode.@salable == "false" && item.@level == "0") {
				// not salable
				API.dbg("[lIsValidProduct] - product " + item.@productCode + " not salable");
				item.@status = MOBILE_ITEM_NOT_SALABLE;
			}
			else if (productNode.@statusCode == "INACTIVE") {
				// inactive
				API.dbg("[lIsValidProduct] - product " + item.@productCode + " inactive");
				item.@status = MOBILE_ITEM_INACTIVE;
			}
			else if (lIsInProductOutage(item.@productCode)) {
				// prodoutage
				API.dbg("[lIsValidProduct] - product " + item.@productCode + " in prodoutage.xml");
				item.@status = MOBILE_ITEM_NOT_AVAILABLE;
			}
			else if(!lIsInDayPart(productNode.CustomParameters.Parameter.(@name=="dayPart").@value.toString(), productNode.DayPartCode)) {
				// invalid day part
				var customDayPart = productNode.CustomParameters.Parameter.(@name=="dayPart").@value.toString();
				API.STTErrorLog("0", "[onFoeValidateSaleView] - product " + item.productCode + " only salable in daypart " + ((customDayPart == undefined || customDayPart == "") ? productNode.DayPartCode : customDayPart) + ", current daypart is " + storeDaypart, BC_EVENTS_NAME);
				item.@status = MOBILE_ITEM_INV_DAY_PART;
			}
			else if(!lIsInTimeRestriction(productNode.CustomParameters.Parameter.(@name=="timeRestriction").@value.toString())) {
				API.dbg("[lIsValidProduct] - product " + item.@productCode + " not salable at this time of the day");
				item.@status = MOBILE_ITEM_INV_TIME;
			}
			else if (isMcc && (operation == "DT")) {
				API.dbg("[Mobile - lIsValidProduct] - product " + item.@productCode + " MC Cafe items are not allowed on DT");
				item.@status = MOBILE_ITEM_MC_CAFE;
			}
			else {
				API.dbg("[lIsValidProduct] - product "+item.@productCode+" OK");
				item.@status = MOBILE_ITEM_OK;
			}
		}

		return item.@status == "0";

		/** lIsInProductOutage
		 *
		 * @brief - Checks if the a given product is in the outage file.
		 * @param - productCode - Product to check.
		 * @returns - True if the product is in the outage file, otherwise false.
		 */
		function lIsInProductOutage(productCode) {
			var hlp 			= new BusinessObjectHelper();
			var posDataPath		= hlp.PosGetDataDir();
			var outageFilePath	= posDataPath + MOBILE_PROD_OUT_FILE;
			if(File.exists(outageFilePath)) {
				var outageFile = new File(outageFilePath);
				if(outageFile.open("r")) {
					var outageBuffer = outageFile.read();
					outageBuffer = outageBuffer.replace("<?xml","<!-- bug_336551"); //spidermonkey bugzilla 336551
					outageBuffer = outageBuffer.replace("?>","bug_336551 -->");
					outageFile.close();
					var outageXML = new XML(outageBuffer);
					for each(var outageProductCode in outageXML.Product.@code) {
						if(outageProductCode == productCode.toString()) {
							return true;
						}
					}
				}
			}
			else {
				API.dbg("[lIsValidProduct.lIsInProductOutage]Outage file not found: "+outageFilePath);
			}
			return false;
		}

		/** lIsInTimeRestriction
		 *
		 * @brief - Checks if the the product is in salable period.
		 * @param - interval - string - period when the product can be sold. The format is <from>,<to>. Where the format for <from> and <to> is
		 * hh:mm where hh is the hour (from 00 to 23) and mm is the minute (from 00 to 59). Multiple values must be concatenated using "|",
		 * for instance "<from>,<to>| <from>,<to>| <from>,<to>".
		 * Examples:
		 *	- Product can only be sold from 10:00 to 14:00 = "10:00,14:00"
		 *	- Product can only be sold from 22:00 to 04:00 = "22:00,23:59|00:00,04:00"
		 *	- Product can be sold from 14:00 to 16:00 and  from 21:00 to 23:00="14:00,16:00|21:00,23:00"
		 * @return - true if the current time is within the period. false otherwise
		 * @author - Raphael Almeida
		 * @since - SDO-4013 - Implement Mobile Check-in Device
		 */
		function lIsInTimeRestriction(period) {
			if(period == null || period == "") {
				return true;
			}
			var timeNow = new NPDate();

			API.STTErrorLog("0", "[lIsInTimeRestriction] - product salable in " + period + " period(s) and the current time is " + timeNow.getHours() + ":" + timeNow.getMinutes() + ":" + timeNow.getSeconds(), BC_EVENTS_NAME);

			var intervals = String(period).split("|");
			for each(interval in intervals) {
				var timeRange = String(interval).split(",");
				var initialHour = Number(String(timeRange[0]).split(":")[0]);
				var initialMinute = Number(String(timeRange[0]).split(":")[1]);
				var finalHour = Number(String(timeRange[1]).split(":")[0]);
				var finalMinute = Number(String(timeRange[1]).split(":")[1]);

				var initialTime = new NPDate(timeNow.getFullYear(), timeNow.getMonth(), timeNow.getDate(), initialHour, initialMinute);
				var finalTime = new NPDate(timeNow.getFullYear(), timeNow.getMonth(), timeNow.getDate(), finalHour, finalMinute);
				if(timeNow >= initialTime && timeNow < finalTime) {
					return true;
				}
			}

			return false;
		}

			/** lIsInDayPart
		 *
		 * @brief - Checks if the the product is in salable day partition, based on daypart custom parameter and <DayPartCode> parameter. Custom overides <DayPartCode>.
		 * @param - dayPartCustom - day partition from custom parameter to be checked. Possible values: "BREAKFAST_MENU", "DAY_MENU", or "BREAKFAST_DAY_MENU"
		 * @param - dayPartCode - day partition from <DayPartCode> parameter to be checked. Possible values: "BREAKFAST_MENU", "DAY_MENU", or "BREAKFAST_DAY_MENU"
		 * @return - true if the received dayPart matches the current one. false otherwise.
		 * @author - Raphael Almeida
		 * @since - SDO-4013 - Implement Mobile Check-in Device
		 */
		function lIsInDayPart(dayPartCustom, dayPartCode) {
			if(dayPartCustom == null || dayPartCustom == "") {
				if(dayPartCode == "BREAKFAST_MENU" && PosIsBreakfastTime() ||
				   dayPartCode == "DAY_MENU" && !PosIsBreakfastTime() ||
				   dayPartCode == "BREAKFAST_DAY_MENU") {
					return true;
				}
				return false;
			}
			if(	dayPartCustom == "BREAKFAST_MENU" && PosIsBreakfastTime() ||
				dayPartCustom == "DAY_MENU" && !PosIsBreakfastTime() ||
				dayPartCustom == "BREAKFAST_DAY_MENU") {
				return true;
			}
			return false;
		}

	};
	
	/** ProcessView
	 *
	 * @brief - Try to sell all of the valid products from the current view.
	 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
	 */
	this.ProcessView = function() {	
		API.dbg("[Mobile - ProcessView] Start");
	
		var helper = new BusinessObjectHelper();
	
		var showGrillScreen = ctx.get("showGrillScreen");
		ctx.set("showGrillScreen", "no");
		
		// set to not do PosAutoChoice on BCEvents.nps, function onChoiceMade
		ctx.set("isMobileOrder", "true");
		
		// Iterate through the level 0 items.
		for each (var item in view.Product) {
			SellProduct(item);
		}
		
		// Add additional sale info
		AddAdditionalInfo();
	
		return true;
	
		/** SellProduct
		 *
		 * @brief - This function tries to sell a product/grill and its children recursively.
		 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
		 */
		function SellProduct(product) {
		
			var i;
			var quantity;		
			var grillItems;
			
			quantity =  parseInt(product.@quantity);
				
			API.dbg("[Mobile - DoSaleItem] - Trying to sell the product: " + product.@productCode + " . Quantity: " + quantity);
			
			if (product.@status != MOBILE_ITEM_OK)
			{
				API.dbg("[Mobile - SellProduct] WARNING - The product: " + product.@productCode + " is invalid, it and its children will not be sold. Status: " + product.@status + " View: " + product.toXMLString());
				return;
			}
			
			for (i = 0; i < quantity; i++) {
			
				// Sell the current product.
				ProcessSale(product);
				
				// Grill the current product, if necessary.
				grillItems = product.Grill;
				if (grillItems.length() > 0) {
				
					// Start the grill
					var grillStartResult = PosDoGrillStart("");
					if (grillStartResult) {
						API.dbg("[Mobile - SellProduct]  - PosDoGrillStart, successfully executed for product: " + product.@productCode);
									
						// Get the grill index.
						var index = getTabIndex(product.@productCode);
						if (index != null) {
							PosDoSelGrillIndex(index);
							API.dbg("[Mobile - ProcessView] PosDoSelGrillIndex index: " + index + ", productCode: " + product.@productCode);
						} else {
							API.dbg("[Mobile - ProcessView] ERROR - SelectGrillIndex, index not found: " + product.@productCode);
						}
									
						// Process the grill.
						for each (var grill in grillItems) {
							
							// Check if the grill is valid before proceeding.
							if (grill.@status != MOBILE_ITEM_OK) {
								API.dbg("[Mobile - SellProduct] WARNING - The grill: " + grill.@productCode + " is invalid. Status: " + grill.@status + " View: " + grill.toXMLString());
								continue;
							}
						
							ProcessGrill(grill);
						}
					
						// End grill
						var grillEndResult = PosDoGrillEnd(3);
						if (!grillEndResult) {
							API.dbg("[Mobile - ProcessView] WARNING - PosDoGrillEnd, result: " + grillEndResult + " | item: " + itemView);
						}
						
					}
					else 
						API.dbg("[Mobile - SellProduct] WARNING - PosDoGrillStart, result: " + grillStartResult + " | item: " + product.toXMLString());
					
				}
				
				// Process child products (if any).
				for each (var childProduct in product.Product)
					SellProduct(childProduct);
			}
			
			API.dbg("[Mobile - DoSaleItem] - The product: " + product.@productCode + " was successfully sold.");
		}
	
		/** AddAdditionalInfo
		 *
		 * @brief - This function adds the required additional info to the New POS sale view.
		 * @since - SQM-1265 - MOT: Grill customizations are not maintained for the second value meal ordered
		 */
		function AddAdditionalInfo() {
			
			ctx.set("showGrillScreen", showGrillScreen);
			
			ctx.set("isMobileOrder", "false");
			
			// Save customer nick name and the customer id for use on pick up list on cashier/kvs
			var customerId = view.@customerId;
			var customerNickStr = convXMLSpecialChars(view.@customerNick.toString(), true);
			
			API.dbg("[Mobile - AddAdditionalInfo] Customer nickname: " + customerNickStr);
			
			PosSetCustomInfo(MOBILE_TAG_CUSTOMER_ID, customerId);
			PosSetCustomInfo(MOBILE_TAG_CUSTOMER_NICK, customerNickStr);
			
			// Save a mark on this order view to indicate that it came from the CheckIn Device or the Mobile Drive Through
			var operation = ctx.get("POD");
			
			if (operation == "CSO") {
				PosSetCustomInfo(MOBILE_TAG_IS_CID_ORDER, "true");
				PosSetCustomInfo(MOBILE_TAG_IS_DT_ORDER, "false");
			
			} else  if (operation == "DT") {
				PosSetCustomInfo(MOBILE_TAG_IS_CID_ORDER, "false");
				PosSetCustomInfo(MOBILE_TAG_IS_DT_ORDER, "true");
			}
			
			// Set the order src attribute in the current order view as a mobile order
			PosSetOrderSrc(MOBILE_ORDER_SRC);
		}

		/**
		 * @brief - do a sale or choice for an item
		 */
		 function ProcessSale(item) {
			if (item.@prodAction != 3 && item.@level != 0) {
				API.dbg("[Mobile - ProcessView] ERROR - ProcessSale, item can not be sold: " + item.toXMLString());
				return;
			}
						
			API.dbg("[Mobile - ProcessView] - Trying to sell the item: " + item.@productCode);
					
			if (item.@prodAction != 3) 
			{
				//Replacing the item
				productNode = productDictionary[item.@productCode];			
				
				if ((productNode.CustomParameters.Parameter.(@name=="IsPromotional").@value.toString()) != "true"		&&
					(productNode.CustomParameters.Parameter.(@name=="IsPromotional").@value.toString()) != undefined 	&&
					(productNode.CustomParameters.Parameter.(@name=="IsPromotional").@value.toString()) != null )		 
					
				{
					var productToReplace = OnGetPromotional(productNode, item.@productCode);
					if (productToReplace != undefined && 
						productToReplace != false && 
						productToReplace != null)
					{
						isPromotionalProduct = true;
						API.dbg("[Mobile - ProcessView]  -  Replace by: " + productToReplace);
						var productNameToReplace = 	lMCDGetProductName(productToReplace);
						if (productNameToReplace == null 	  ||
							productNameToReplace == undefined ||
							productNameToReplace == "")
						{							
							productNameToReplace = item.@productCode;
							
							API.dbg("[Mobile - ProcessView] - WARNING - Product name not found at names-db.xml for Code: " + item.@productCode);
						}							
						itemsPromo.push(productNameToReplace);						
						
					}else{
						API.dbg("[Mobile - ProcessView] - Product " + productToReplace + "is not in a promotional period");
						productToReplace = item.@productCode;
						isPromotionalProduct = false;
					}
					var result = PosDoSale(productToReplace);				
					
				}else{
					API.dbg("[Mobile - ProcessView] - Selling without any swap");
					var result = PosDoSale(item.@productCode);
				}				
				
				API.dbg("[Mobile - ProcessView] ProcessSale PosDoSale product: " + item.@productCode + ", result: " + result);
			}
			else {
				var result = PosDoChoice(item.@productCode);
				API.dbg("[Mobile - ProcessView] ProcessSale PosDoChoice product: " + item.productCode + ", result: " + result);
			}
		}

		/**
		 * @brief - process item grill
		 */
		function ProcessGrill(item) {
		
			var operation = '';
			var quantity = 1;

			if (item.@specialModifiers > 0) {
				operation = '0';
			} else if (item.@grilledQuantity < 0) {
				operation = 'm';
				quantity = item.@grilledQuantity * (-1);
			} else {
				operation = 'p';
				quantity = item.@grilledQuantity;
			}

			API.dbg("[Mobile - ProcessGrill] productCode: " + item.@productCode + ", operation: " + operation + ", quantity: " + quantity + ", specialModifiers: " + item.@specialModifiers);
			
			do {
				// Cannot use the BC PosDoGrillOperMulti here, because it always returns true (even if an error occurs during the grill
				// operations).
				// SQM-1125 - MOT integration with NP6: 'Checking device' does not accept customized items
				var grillResult = PosDoGrillOperMulti_Ex(operation, item.@productCode, item.@specialModifiers.charAt(0), false);
				if (!grillResult) {
					API.dbg("[Mobile - ProcessGrill] PosDoGrillOperMulti productCode failed: " + item.@productCode + ", oper: " + operation + ", mod: " + item.@specialModifiers + ", result: " + grillResult);
					item.@status = MOBILE_ITEM_GRILL_ERROR;
					allItemsValid = false;
				}
				quantity--;
			}
			while (quantity > 0);

			return true;
		}
		
		/**
		 * @brief - get grill index for product code
		 * 			based on getTabIndex and lGetGrillView from CSO (PosDoCloneItemKioskJS)
		 */
		function getTabIndex(productCode) {
			var hlp = new BusinessObjectHelper;
			var grillView = hlp.getGrillView();

			if (grillView == null) {
				return null;
			}

			var regs			= grillView.split("<@");
			var grillableLst	= null;
			for (var i=0;i<regs.length;i++) {
				var reg = regs[i];
				if (reg.length > 0) {
					if (reg.substr(0, 1) == "3") { // 3-GRILLABLE LIST
						grillableLst = reg.substr(1, reg.length-2).split("|");
						var lstIndex = (grillableLst.length - 1);
						var lstComp = grillableLst[lstIndex];
						grillableLst[lstIndex] = lstComp.substr(0, lstComp.length-1);
					}
				}
			}

			for (var i=0; i<grillableLst.length;i++) {
				var code = rtrim(grillableLst[i].substr(0, 40));
				if (code == productCode)
					return i;
			}

			return null;

			/** Remove right spaces of String **/
			function rtrim(s)
			{
				var r = s.length - 1;
				while ( (r > 0) && (s[r] == ' ') ) {
					r -= 1;
				}
				return s.substring(0, r+1);
			}
		}
	};
	
	
	this.ApplyDiscount = function(totalOrder)
	{
		
		var ret = true;
		var totalDiscount = 0;		
		
		API.dbg("0", " - [ApplyDiscount] - Checking 'PromotionalDiscountTable' at 'store.wide' section   ");
		
		loadStoreDB();
		var xmlPromoDiscTable = null;
		if ( rootStoreDB.Configurations.Configuration.(@type == "Store.wide").Section.(@name == "PromotionalDiscountTable") != null 	&&
			rootStoreDB.Configurations.Configuration.(@type == "Store.wide").Section.(@name == "PromotionalDiscountTable") != undefined	&&
			rootStoreDB.Configurations.Configuration.(@type == "Store.wide").Section.(@name == "PromotionalDiscountTable") != "" )
		{		
			xmlPromoDiscTable =	new XML(rootStoreDB.Configurations.Configuration.(@type == "Store.wide").Section.(@name == "PromotionalDiscountTable"));
			
		}else{
		
			API.dbg("0", " - [ApplyDiscount] - 'PromotionalDiscountTable' not found at 'store.wide' section");
			return false;
		}
				
		var arrayDiscount = [];
		var count = 0;
		for each (var promoItem2 in xmlPromoDiscTable.Parameter)
		{
			arrayDiscount[count] = {name:parseInt(promoItem2.@name.toString()), value:promoItem2.@value};
			count++;
		}		
		
		arrayDiscount.sort(function(a, b){
			return a.name > b.name;
		})						
		
		for each(var promoItem in arrayDiscount)
		{	
			API.dbg(" - [ApplyDiscount] promoItem.(@name): " + promoItem.name);												
			if (promoItem.name != null && promoItem.name > 0)
			{							
				var discountToken = promoItem.value;
				API.dbg(" - [ApplyDiscount] discountToken: " + discountToken);											
				var token = discountToken.split("|");
				var enableDb 		= token[0];
				var initDateDb 		= token[1];
				var finalDateDb 	= token[2];
				var initRangeDb 	= token[3];
				var finalRangeDb 	= token[4];
				var discountIdDb 	= token[5];
				var discountTypeDb 	= token[6];
				var discountValueDb = token[7];									
				
				if (enableDb.toUpperCase() == "ENABLED")
				{					
					API.dbg("[ApplyDiscount] - if enabled");		
					
					if (!isInDateInRange(initDateDb, finalDateDb)) {
						API.dbg("[ApplyDiscount] - The Order's date is not in a valid period");
						ret = false;
						
					}					
					else if (!isAmountInRange(totalOrder, discountTypeDb, initRangeDb, finalRangeDb)) {	
					
						API.dbg("[ApplyDiscount] - The Order Total is not in a valid range");						
						ret = false;
						
					}else{
					
						isPromotionalSale = true;
						API.dbg("[ApplyDiscount] - isPromotionalSale: " + isPromotionalSale);					
						//calculating discount				
						API.dbg("[ApplyDiscount] - Calculating discount");		
						var ret = null;
						
						//Percent discount
						if ( discountTypeDb.toUpperCase() == "P" )
						{
							ret = executeBC("cPosAddDiscountRate", [1, 2, discountValueDb, "Basic Promotions"]);								
							//Handle results
							if (!ret) 
							{								
								var messageBC = getLastFail("cPosAddDiscountRate");
								API.dbg("[ApplyDiscount] - messageBC: " + messageBC);									
							}
							//just do debug
							API.dbg("[ApplyDiscount] - Percent - totalOrderBD : " + totalOrder);
							totalDiscount = (1 - (Number(discountValueDb)/100)); 							
							API.dbg("[ApplyDiscount] - totalDiscount : " + totalDiscount);
							totalOrder = totalOrder * totalDiscount;
							API.dbg("[ApplyDiscount] - totalOrder After: " + totalOrder);
							
						}else if ( discountTypeDb.toUpperCase() == "A")
						{	
							ret = executeBC("cPosAddDiscountRate", [1, 1, discountValueDb, "Basic Promotions"]);															
							API.dbg("[ApplyDiscount] - Amount - totalOrderBD: " + totalOrder);
							totalOrder = totalOrder - Number(discountValueDb); 
							API.dbg("[ApplyDiscount] - totalOrder After: " + totalOrder);						
							
						}else{
						
							API.dbg("[ApplyDiscount] - Invalid discountType: " + discountTypeDb);						
							return false;
						}
						return totalOrder;							
						
					}						
				}
			}						
		} //for each		   
	   return ret;
	}
	
	function isAmountInRange(value, discountType, range1, range2)
	{
		ret = true;
		
		//Range1 Is mandatory only when the Discount Type is equal to "Amount"
		if (discountType == "1" && (range1 == undefined || range1 == null || range1 == ""))
		{
			API.STTErrorLog("0", "[isAmountInRange] - Initial Order Total Value is mandatory when the Discount Type is equal to Amount" , BC_EVENTS_NAME);		   
			return false;
		}			
		
		if ( (range1 == undefined || range1 == null || range1 == "") && (range2 != "") )
		{
			API.STTDebugLog("0", "[isAmountInRange] - Range1 empty, Range2 filled" , BC_EVENTS_NAME);		   
			if (Number(value) > Number(range2))
			{
				ret = false;
			}			
			
		}else if ((range1 != "") && (range2 == undefined || range2 == null || range2 == ""))
		{
			API.STTDebugLog("0", "[isAmountInRange] - Range1 filled, Range2 empty" , BC_EVENTS_NAME);		   
			if ( Number(value) < Number(range1) )
			{
				ret = false;
			}
			
		}else if ((range1 != "") && (range2 != ""))
		{
			API.STTDebugLog("0", "[isAmountInRange] - Range1 Range2 filled" , BC_EVENTS_NAME);		   
			if ( Number(value) > Number(range2) &&
				 Number(value) < Number(range1) )
			{
				ret = false;
			}
		}
		
		return ret;			
	}	
	
		
	/** GetProductComponent
	 *
	 * @brief - This function tries to get the Component configuration of a product in the product-db.xml
	 * @param - parentProductCode - Parent product code.
	 * @param - productCode - Component product code.
	 * @returns - A XML with Compontent configuration or undefined if the configuration is not found.
	 */
	function GetProductComponent(parentProductCode, productCode) {
		var parentProductNode;
		var component;
		
		API.dbg("[Mobile - GetProductComponent] Trying to get the component for the product: " + productCode + " in the parent: " + parentProductCode);
		
		parentProductNode = productDictionary[parentProductCode.toString()];
		
		if (parentProductNode == undefined) {
			API.dbg("[Mobile - GetProductComponent] WARNING Could not find the parent: " + parentProductCode + " in the product-db.xml");
			return undefined;
		}
		
		// Try to find the product component as a Composition
		component = parentProductNode.Composition.Component.(ProductCode == productCode);
		if (component != undefined) {
			API.dbg("[Mobile - GetProductComponent] Found Composition node for product: " + productCode + " in parent: " + parentProductCode);
			return component;
		}
		
		// Try to find the product component as a Can Add
		component = parentProductNode.Composition.CanAdds.(ProductCode == productCode);
		if (component != undefined) {
			API.dbg("[Mobile - GetProductComponent] Found CanAdd node for product: " + productCode + " in parent: " + parentProductCode);
			return component;
		}
		
		// Try to find the product component as a Comment
		component = parentProductNode.Composition.Comments.(ProductCode == productCode);
		if (component != undefined) {
			API.dbg("[Mobile - GetProductComponent] Found Comments node for product: " + productCode + " in parent: " + parentProductCode);
			return component;
		}
		
		API.dbg("[Mobile - GetProductComponent] WARNING - Could not find product: " + productCode + " in parent: " + parentProductCode);
		return undefined;
	}
	
	/** DecodeToXml
	 *
	 * @brief - Decode a string returned from getLastSuccess into a XML string
	 * @param - xmlStr - string to be decoded
	 * @return  string decode in xml
	 * @since 1.17
	 */
	function DecodeToXml(xmlStr) {
		if (xmlStr == null || xmlStr.length <= 0) {
			return xmlStr;
		}
	
		// replace all 0x7f 0x04 for """
		// replace all 0x7f 0x03 for "<"
		// replace all 0x7f 0x02 for ">"
		// replace all 0x7f 0x01 for 0x7f

		var markString = new RegExp("\x7F\x01", "g");
		var markStringHigher = new RegExp("\x7F\x02", "g");
		var markStringLower = new RegExp("\x7F\x03", "g");
		var markStringQuote = new RegExp("\x7F\x04", "g");

		xmlStr = xmlStr.replace(markStringQuote, "\"");
		xmlStr = xmlStr.replace(markStringLower, "<");
		xmlStr = xmlStr.replace(markStringHigher, ">");
		xmlStr = xmlStr.replace(markString, "\x7F");

		// replace all 0x7e 0x06 for "'" ("&apos;")
		// replace all 0x7e 0x05 for "&" ("&amp;")
		// replace all 0x7e 0x04 for """ ("&quot;")
		// replace all 0x7e 0x03 for "<" ("&lt;")
		// replace all 0x7e 0x02 for ">" ("&gt;")
		// replace all 0x7e 0x01 for 0x7e
		var markString = new RegExp("\x7E\x01", "g");
		var markStringHigher = new RegExp("\x7E\x02", "g");
		var markStringLower = new RegExp("\x7E\x03", "g");
		var markStringQuote = new RegExp("\x7E\x04", "g");
		var markStringAmpersand = new RegExp("\x7E\x05", "g");
		var markStringApostrophe = new RegExp("\x7E\x06", "g");

		xmlStr = xmlStr.replace(markStringApostrophe, "&apos;");
		xmlStr = xmlStr.replace(markStringAmpersand, "&amp;");
		xmlStr = xmlStr.replace(markStringQuote, "&quot;");
		xmlStr = xmlStr.replace(markStringLower, "&lt;");
		xmlStr = xmlStr.replace(markStringHigher, "&gt;");
		xmlStr = xmlStr.replace(markString, "\x7E");

		return xmlStr;
	}
}

function isInDateInRange(startDate, finalDate)
{
	if ( (finalDate == "" || finalDate == undefined || finalDate == null) &&		
		 (startDate == "" || startDate == undefined || startDate == null) )
	{
		API.STTErrorLog("0", "[isInDateInRange] - StartDate and InitDate in blank - Order allowed" , BC_EVENTS_NAME);		   		
		return true;
	}		
		
	var timeNow = new NPDate();
	//API.formatDate(timeNow, "dd/MM/yyyy");
	//initDate: 2012-12-01
	//finalDate: 2012-12-15
	if (startDate != "" && startDate != undefined && startDate != null)
	{
		var YYYY = startDate.substr(0, 4);
		var MM = startDate.substr(5, 2);
		var DD = startDate.substr(8, 2);
		
		var startD = new NPDate(Number(YYYY), Number(MM) - 1, Number(DD));
		if (startD.getDate() != Number(DD) || startD.getMonth() != Number(MM) - 1)
		{			
			API.STTErrorLog("0", "[isInDateInRange] - Initial Effective Date is invalid" , BC_EVENTS_NAME);		   
			return false;
		}
	}
	
	if (finalDate != "" && finalDate != undefined && finalDate != null)
	{
		YYYY = finalDate.substr(0, 4);
		MM = finalDate.substr(5, 2);
		DD = finalDate.substr(8, 2);
		var finalD = new NPDate(Number(YYYY), Number(MM) - 1, Number(DD));
		if (finalD.getDate() != Number(DD) || finalD.getMonth() != Number(MM) - 1)
		{
			API.STTErrorLog("0", "[isInDateInRange] - Final Effective Date is invalid" , BC_EVENTS_NAME);		   
			return false;
		}
	}
	
	//StartDate and FinalDate are valid
	if ( (finalD != "" && finalD != undefined && finalD != null) &&
		 (startD != "" && startD != undefined && startD != null) )
	{		
		if ( (timeNow < startD) || (timeNow > finalD)){
			API.STTErrorLog("0", "[isInDateInRange] - Date is not in the range allowed" , BC_EVENTS_NAME);		   		
			return false;
		}
	}		
	//Just StartDate is filled
	else if ((startD != "" && startD != undefined  && startD != null) &&
			 (finalD == "" || finalD == undefined || finalD == null) )
	{			
		if (timeNow < startD){
			API.STTErrorLog("0", "[isInDateInRange] - StartDate is invalid" , BC_EVENTS_NAME);		   		
			return false;
		}
	}			
	//Just FinalDate is filled
	else if ((finalD != "" && finalD != undefined  && finalD != null) &&
			 (startD == "" || startD == undefined  || startD == null) )
	{		
		if (timeNow > finalD){
			API.STTErrorLog("0", "[isInDateInRange] - FinalDate is invalid" , BC_EVENTS_NAME);		   		
			return false;
		}
	}
	return true;
}	

function getDayAsTagName()
{
	var curdate = new NPDate();
	var wday = curdate.getDay();
	var wdayString="";
		
	switch(wday) {
		case 0:
			wdayString = "PromotionTimeSun";
			break;
		case 1:
			wdayString = "PromotionTimeMon";
			break;		
		case 2:
			wdayString = "PromotionTimeTue";
			break;
		case 3:
			wdayString = "PromotionTimeWed";
			break;
		case 4:
			wdayString = "PromotionTimeThu";
			break;
		case 5:
			wdayString = "PromotionTimeFri";
			break;
		case 6:
			wdayString = "PromotionTimeSat";
			break;			
		default:
			break;	
	}
		
	return wdayString;
	
}	

/** PosMCDBlockJS
 *
 * @brief - Sends the unblock message if the block source was the same that has blocked
 * @param - msgCode - Message code which explains the reason for blocking the UI.
 * @return - none.
 * @since - SDO-4013
 * @author - Raphael Almeida
 */
 function PosMCDBlockJS(msgCode, blockSource) {
 
	// If the check in device is currently unblocked or the same source is trying once more to block the check in device.
	// NPM-581 Check-In Device displays 'Welcome, scan your order code' screen directly after POS Open with no Cashier logged 
	if((GLOBAL_CSO_BLOCK_SOURCE == null) || (GLOBAL_CSO_BLOCK_SOURCE == blockSource)) {
		GLOBAL_CSO_BLOCK_SOURCE = blockSource;
		var hlp	= new BusinessObjectHelper;
		var msgText = lGetI18nMessage(msgCode);
		PosSendUICmd(lcreateBlockUnblock("UI_BLOCK", msgCode, msgText));
		API.dbg("[PosMCDBlockJS] Check-in UI has been BLOCKED - msg: [" + msgText + "] blocked by: "+blockSource);
	} else {
		// NPM-581 Check-In Device displays 'Welcome, scan your order code' screen directly after POS Open with no Cashier logged 
		API.dbg("[PosMCDBlockJS] The Check-in cannot be blocked by the source: " + blockSource + " because is already blocked by: " + GLOBAL_CSO_BLOCK_SOURCE);
	}
}

/** PosMCDUnBlockJS
 *
 * @brief - Sends the unblock message if the UI is not yet blocked
 * @param - blockSource - constant - the source that has blocked the UI
 * @return - none.
 * @since - SDO-4013
 * @author - Raphael Almeida
 */
 function PosMCDUnBlockJS(blockSource) {
	if(blockSource == GLOBAL_CSO_BLOCK_SOURCE) {
		PosSendUICmd(lcreateBlockUnblock("UI_UNBLOCK"));
		API.dbg("[PosMCDUnBlockJS] - Check-in UI has been UNBLOCKED by: "+blockSource);
		GLOBAL_CSO_BLOCK_SOURCE = null;
	} else {
		// NPM-581 Check-In Device displays 'Welcome, scan your order code' screen directly after POS Open with no Cashier logged 
		API.dbg("[PosMCDUnBlockJS] The Check-in cannot be unblocked by the source: " + blockSource + " because is was blocked by: " + GLOBAL_CSO_BLOCK_SOURCE);
	}
}

/**PosMCDCheckPrinterStatusJS
 *
 * @brief - Checks the printer status, status sample: out of paper, paper jammed, paper near end and etc.
 *          This function has been designed to block the NewPOS application process if any problem
 *          is detected in the printer.
 *	     The bScriptCall is used to determine if the function is called from an workflow or from the scripts.
 *          If called from the scripts the method will return the status and not only true.
 * @return - always TRUE.
 * @since - NPM-101 - Check-In Device : Initialisation of Check-In Device to detect the Custom Kiosk Printer on start-up fails
 * @remarks
 */
function PosMCDCheckPrinterStatusJS() {
	var paperNearEndSensorPresent;
	var paperEndSensorPresent;
	
	const BIT_0=1;
	const BIT_1=2;
	const BIT_2=4;
	const BIT_3=8;
	const BIT_4=16;
	const BIT_5=32;
	const BIT_6=64;
	const BIT_7=128;

	const STATUS_OK=0;
	const STATUS_NOT_AVAILABLE=1;
	const STATUS_PAPER_NEAR_END=2;
	const STATUS_PAPER_OUT=3;
	const STATUS_DOOR_OPEN=4;
	const STATUS_PAPER_JAM=5;
	const STATUS_USER_INTERVENTION=6;
	const STATUS_ERROR_UNKNOWN=7;
	const STATUS_API_UNAVAILABLE=8;

	const CLASS_PRINTER_STATUS=String.fromCharCode(0x01);
	const CLASS_OFFLINE_STATUS=String.fromCharCode(0x02);
	const CLASS_ERROR_STATUS=String.fromCharCode(0x03);
	const CLASS_PAPER_SENSOR_STATUS=String.fromCharCode(0x04);

	try {
		API.dbg("INFO : Checking default printer status.");
		while (true) {
			// Sends the real-time status transmission command.
			var rc1=0;
			var rc2=0;
			var rc3=0;
			var rc4=0;
			rc1 = sndRcvPrnCmd(CLASS_PRINTER_STATUS);
			if (rc1 != STATUS_API_UNAVAILABLE) {
			
				// Checks the status of the paper sensors before cheking the status of the paper itself
				checkPaperSensorsStatus();
				
				// If any of the two paper sensors are online, check the paper status. Otherwise ignore this check
				if (paperEndSensorPresent || paperNearEndSensorPresent) {
					rc2 = sndRcvPrnCmd(CLASS_PAPER_SENSOR_STATUS);
				} else {
					rc2 = STATUS_OK;
				}
				
				rc3 = sndRcvPrnCmd(CLASS_OFFLINE_STATUS);
				rc4 = sndRcvPrnCmd(CLASS_ERROR_STATUS);
				
			}
			if ((rc1+rc2+rc3+rc4)!=STATUS_OK) {
				API.dbg("PRN: Sending NOT STATUS_OK...");
				API.dbg("PRN class: CLASS_PRINTER_STATUS, rc: " + rc1);
				API.dbg("PRN class: CLASS_PAPER_SENSOR_STATUS, rc: " + rc2);
				API.dbg("PRN class: CLASS_OFFLINE_STATUS, rc: " + rc3);
				API.dbg("PRN class: CLASS_ERROR_STATUS, rc: " + rc4);
				var msg = "";
				msg=mountMsg(decodeMessage(rc2), msg);
				msg=mountMsg(decodeMessage(rc3), msg);
				msg=mountMsg(decodeMessage(rc4), msg);
				if (msg.length <= 0) {
					msg=mountMsg(decodeMessage(rc1), msg);
				}
				API.dbg("INFO : Printer is NOT ready to work, due to: " + msg);
				
				PosMCDBlockJS(msg, BLOCK_SOURCE_PRINTER);
				break;
			} else {
				API.dbg("INFO : Printer is ready to work.");
				
				PosMCDUnBlockJS(BLOCK_SOURCE_PRINTER);
				break;
			}
		}
	} catch (ex) {
		var msg = "Could not check printer status, due to: " + ex;
		PosMCDBlockJS(msg, BLOCK_SOURCE_PRINTER);
	}

	return GLOBAL_CSO_BLOCK_SOURCE == null;

	/** decodeMessage
	 *
	 * @brief - Decodes the message.
	 * @return - Error message.
	 * @since - NPM-101 - Check-In Device : Initialisation of Check-In Device to detect the Custom Kiosk Printer on start-up fails
	 */
	function decodeMessage(rc) {
		if (STATUS_OK==rc) {
			return null;
		} else if (STATUS_NOT_AVAILABLE==rc){
			return "Printer is offline or not available in the network.";
		} else if (STATUS_PAPER_NEAR_END==rc){
			return "Paper is near end in the printer.";
		} else if (STATUS_PAPER_OUT==rc){
			return "Printer is out of paper.";
		} else if (STATUS_DOOR_OPEN==rc){
			return "Printer cover is opened.";
		} else if (STATUS_PAPER_JAM==rc){
			return "Paper is jammed in the printer.";
		} else if (STATUS_USER_INTERVENTION==rc){
			return "Printer error, human intervention is required.";
		} else if (STATUS_API_UNAVAILABLE==rc) {
			return "This feature is not available for the configured printer driver.";
		}
		return "Unknown printer error.";
	}

	/** sndRcvPrnCmd
	 *
	 * @brief - Sends and receives the printer command.
	 * @return - Encoded status.
	 * @since - NPM-101 - Check-In Device : Initialisation of Check-In Device to detect the Custom Kiosk Printer on start-up fails
	 */
	 function sndRcvPrnCmd(class) {
		const cmd = createCmd(class);						// Class command.
		const rc = PosSendPrinterCmd(cmd); 					// Sends the escape command to the default printer.
		
		API.dbg("[PosMCDCheckPrinterStatusJS sndRcvPrnCmd] class: " + class.charCodeAt(0) + ", rc: " + (rc != null ? rc.charCodeAt(0) : "null"));
		
		//				PRINTER		OFFLINE		ERROR		PAPER SENSOR
		//				STATUS		STATUS		STATUS		STATUS
		//------------	----------	--------	--------	---------
		// OK			18			18			18			30
		// offline 		null		null		null		null
		// no paper		26			114			18			126
		// near end		
		// paper jam	18			18			18			30
		// cover open	26			86			18			30
		
		if (rc == "-1") {
			// This kind of RC is created by NewPOS
			return STATUS_API_UNAVAILABLE; 					// This API is not implemented in this printer driver.
		} else if ((rc == null) || (rc.length == 0)) {
			return STATUS_NOT_AVAILABLE; 					// Printer is disconnected or offline.
		} else {
			//
			// ALL CHECKS BELOW MAY DEPEND ON THE PRINTER DRIVER IMPLEMENTATION
			//
			var charCode = rc.charCodeAt(0);
			if (charCode == 0) {
				return STATUS_NOT_AVAILABLE; 				// Printer is disconnected or offline.
			} else {
				// BT-T080 is: 22 18 18 18
				if (class == CLASS_PRINTER_STATUS) {
					if (charCode & BIT_3) {
						return STATUS_NOT_AVAILABLE; // offline
					}
				} else if (class == CLASS_OFFLINE_STATUS) {
					if (charCode & BIT_6) {
						if (charCode & BIT_2) {
							return STATUS_DOOR_OPEN;
						} if (charCode & BIT_3) {
							return STATUS_PAPER_OUT;
						} else {
							return STATUS_USER_INTERVENTION;
						}
					}
				} else if (class == CLASS_ERROR_STATUS) {
					if (charCode & BIT_3 || charCode & BIT_5) {
						return STATUS_USER_INTERVENTION;
					}
					
				} else if (class == CLASS_PAPER_SENSOR_STATUS) {
					if ((charCode & BIT_5) && (charCode & BIT_6) && paperEndSensorPresent) {
						return STATUS_PAPER_OUT;
					} 
					
					if ((charCode & BIT_2) && (charCode & BIT_3) && paperNearEndSensorPresent) {
						return STATUS_PAPER_NEAR_END;
					}
				}
			}
			return STATUS_OK;
		}
	}

	/** checkPaperSensorsStatus
	 *
	 * @brief - This function checks if the printer's "near paper-end sensor" and "end paper-sensor" are available.
	 * The variables paperNearEndSensorPresent and paperEndSensorPresent are set to true if their corresponding sensor is
	 * available or are set to false if their corresponding sensor is not available.
	 * @returns STATUS_API_UNAVAILABLE if there is any error during this function's execution, otherwise returns STATUS_OK.
	 */
	function checkPaperSensorsStatus() {
				
		const cmd = createPaperSensorStatusCmd();
		const rc = PosSendPrinterCmd(cmd); // Sends the escape command to the default printer.
		
		API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] Checking the paper sensors status.");
			
		if (rc == "-1") {
			// This API is not implemented in this printer driver.
			API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] Error: This API is not implemented in this printer driver.");
			paperNearEndSensorPresent = false;
			paperEndSensorPresent = false;
			return STATUS_API_UNAVAILABLE; 
			
		} else if ((rc == null) || (rc.length == 0)) {
			// Printer is disconnected or offline.
			API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] Error: Printer is disconnected or offline.");
			paperNearEndSensorPresent = false;
			paperEndSensorPresent = false;
			return STATUS_NOT_AVAILABLE; 					
		
		} else {
		
			var charCode = rc.charCodeAt(0);
			
			if (charCode == 0) {
				// Printer is disconnected or offline.
				API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] Error: Printer is disconnected or offline.");
				paperNearEndSensorPresent = false;
				paperEndSensorPresent = false;
				return STATUS_NOT_AVAILABLE; 	
				
			} else {
				
				if ((charCode & BIT_0) && (charCode & BIT_1)) {
					API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] The Paper Near End Sensor is not present.");
					paperNearEndSensorPresent = false;
				
				} else {
					API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] The Paper Near End Sensor is present.");
					paperNearEndSensorPresent = true;
				}
				
				if ((charCode & BIT_2) && (charCode & BIT_3)) {
					API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] The Paper End Sensor is not present.");
					paperEndSensorPresent = false;
				
				} else {
					API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] The Paper End Sensor is present.");
					paperEndSensorPresent = true;
					
				}
			}
		}
		
		API.dbg("[PosMCDCheckPrinterStatusJS checkPaperSensorsStatus] The paper sensors status were successfully checked.");
		
		return STATUS_OK;
	}
	
	/** createCmd
	 *
	 * @brief - Creates the real time status transmission command. The command sequence has been extracted
	 *          from the programming guide manual of the printers: Wincor TH230 and BT-T080 both models were
	 *          used in the Europen kiosk solution.
	 * @return - real time status command.
	 * @since - NPM-101 - Check-In Device : Initialisation of Check-In Device to detect the Custom Kiosk Printer on start-up fails
	 */
	 function createCmd(class) {
		var DLE 		= 0x10;
		var EOT 		= 0x04;
		var END_OF_CMD 	= 0x00;
		var cmd = new StringBuffer();

		cmd.append(String.fromCharCode(DLE));
		cmd.append(String.fromCharCode(EOT));
		cmd.append(class);
		cmd.append(String.fromCharCode(END_OF_CMD));

		return cmd.toString();
	}
	
	/** createPaperSensorStatusCmd
	 * 
	 * @brief - Creates a command to check if the printer's near-end and paper-end sensors are present.
	 * @return - Transmit paper sensor status command.
	 * @since - SQM-933 - MOT Integration with NP6: Check In printer is not working. The print receipt is not printed When barcode is read and paid with cashless. 
	 */
	function createPaperSensorStatusCmd() {
		var DLE 		= 0x1B;
		var EOT 		= 0x76;
		var END_OF_CMD 	= 0x00;
		var cmd = new StringBuffer();

		cmd.append(String.fromCharCode(DLE));
		cmd.append(String.fromCharCode(EOT));
		cmd.append(String.fromCharCode(END_OF_CMD));

		return cmd.toString();
	}

	/**mountMsg
	 *
	 * @brief - This function is required for not show the message twice.
	 * @return - unique message.
	 * @since - NPM-101 - Check-In Device : Initialisation of Check-In Device to detect the Custom Kiosk Printer on start-up fails
	 */
	function mountMsg(inMsg, outMsg) {
		if ((inMsg != null) && (outMsg.indexOf(inMsg)<0)) {
			return (outMsg + "\n" + inMsg);
		}
		return outMsg;
	}
}

/** PosMCDCheckRequiredServicesJS
 *
 * @brief - Verifies if all configured services (as required) are available on the network (on-line). If at least one
 *          of the required services is not available, this function sends a block command message to the third part
 *          UI application (Checkin UI). An unblock command message is sent, as soon as, all the required services become
 *          available again.
 *
 *          Background: During daily operations, the Customer Self Order (CSO) Checkin or a normal POS register can
 *          lose network connectivity to other services in the store, if this occurs, the POS or CSO Checkin cannot
 *          send any order to the production area kitchen video monitors for assembly.
 *
 * @param - none.
 * @return - Always TRUE.
 * @since - NPS-5801
 * @author - Kalil
 */
function PosMCDCheckRequiredServicesJS() {
	if (++GLOBAL_CSO_CHK_CYCLES_COUNTER >= GLOBAL_CSO_CHK_CYCLES) {
		GLOBAL_CSO_CHK_CYCLES_COUNTER = 0;
		PosMCDHandleCheckServices();
	} else {
		//API.dbg("INFO_CSO : Still not the cycle (MAIN): " + GLOBAL_CSO_CHK_CYCLES_COUNTER + ", conf: " + GLOBAL_CSO_CHK_CYCLES);
	}

	if(GLOBAL_CSO_BLOCK_SOURCE != null) {
		if ((GLOBAL_CSO_CUSTOMER_MSG_CYCLES_COUNTER != -1)) {
			if (++GLOBAL_CSO_CUSTOMER_MSG_CYCLES_COUNTER > GLOBAL_CSO_CUSTOMER_MSG_CYCLES) {
				GLOBAL_CSO_CUSTOMER_MSG_CYCLES_COUNTER = -1;
				API.dbg("PosMCDCheckRequiredServicesJS - unblocking/blocking...");
				PosMCDUnBlockJS(BLOCK_SOURCE_NETWORK);
				PosMCDSetDefaultLanguageJS();
				PosMCDBlockJS("MSG_CSO_BLOCKED", BLOCK_SOURCE_NETWORK); // This Checkin is blocked because of local network issues.
			} else {
				//API.dbg("INFO_CSO : Still not the cycle (defaul_language): " + GLOBAL_CSO_CUSTOMER_MSG_CYCLES_COUNTER + ", conf: " + GLOBAL_CSO_CUSTOMER_MSG_CYCLES);
			}
		}
	}
	return GLOBAL_CSO_BLOCK_SOURCE == null;

}

/** PosAreAllReqSrvsAvailable
 *
 * @brief - Sends a ping command to the configured services.
 * @param - none.
 * @return - TRUE when at least one service is unavailable, otherwise returns FALSE.
 * @since - NPS-5801
 * @author - Kalil
 */
function PosAreAllReqSrvsAvailable() {
	/** Remove left spaces **/
	function ltrim(s)
	{
		if (s == null || s.length <= 0)
			return s;

		s = new String(s);

		var l = 0;
		while(l < s.length && s[l] == ' ')
			l++;

		return s.substring(l, s.length);
	}

	/** Remove right spaces **/
	function rtrim(s)
	{
		if (s == null || s.length <= 0)
			return s;

		s = new String(s);

		var r = s.length - 1;
		while(r > 0 && s[r] == ' ')
			r--;

		return s.substring(0, r + 1);
	}

	if ((GLOBAL_CSO_REQ_SRVS == null) || (ltrim(rtrim(GLOBAL_CSO_REQ_SRVS)).length == 0)) {
		API.dbg("INFO_CSO : Required services for Checkin are not configured, services availability can not be performed.");
	} else {
		API.dbg("INFO_CSO : Looking up services: [" + GLOBAL_CSO_REQ_SRVS + "]");
		var srv = GLOBAL_CSO_REQ_SRVS.split("|");
		for (var i=0;i<srv.length;i++) {
			if (!PosCheckConnectivity(srv[i], GLOBAl_CSO_NET_TIMEOUT)) {
				API.dbg("INFO_CSO : Required service [" + srv[i] + "] for Checkin is UNAVAILABLE.");
				return false;
			}
		}
		API.dbg("INFO_CSO : All required services are available.");
	}
	return true;
}

/** PosMCDHandleCheckServices
 *
 * @brief - Handles the check mechanism of the required services and its basic functionalities,
 *          such as: the creation of the block and unblock command messages.
 * @return - true if the UI was unblocked. false otherwise
 * @since - SDO-4013
 * @author - Raphael Almeida
 */
function PosMCDHandleCheckServices() {
	if (PosAreAllReqSrvsAvailable()) {
		API.dbg("PosMCDHandleCheckServices - PosAreAllReqSrvsAvailable() returned TRUE - unblocking...");
		PosMCDUnBlockJS(BLOCK_SOURCE_NETWORK);
	} else {
		var msgCode = "MSG_CSO_BLOCKED";
		var isInProgress 	= (!PosNotATransactionInProgress("true"));
		if (isInProgress) {
			msgCode = "MSG_CSO_BLOCKED_INPROGRESS";			// Dear customer, your order has been cancelled because of local network issues. Please remove your credit card and go to the front counter.
			if (isInProgress) {
				var hlp 	= new BusinessObjectHelper;
				if (hlp.isGrilling()) {
					API.dbg("INFO_CSO : Finalizing grill mode...");
					PosDoGrillEnd('2');
				}
				API.dbg("INFO_CSO : Voiding in progress order...");
				PosDoVoidSale('false','false');
			}
			API.dbg("INFO_CSO : In progress order has been CANCELLED.");
		}
		API.dbg("PosMCDHandleCheckServices - PosAreAllReqSrvsAvailable() returned false - blocking...");
		PosMCDBlockJS(msgCode, BLOCK_SOURCE_NETWORK);
		GLOBAL_CSO_CUSTOMER_MSG_CYCLES_COUNTER = 0;
	}

	return GLOBAL_CSO_BLOCK_SOURCE == null;
}


/** PosMCDCheckSaleMode
 *
 * @brief - This BC checks if the POS is in sale mode. If it is not, it blocks the UI.
 * @return - true when the UI was unblocked. false when it was blocked
 * @since - SDO-4013
 * @author - Raphael Almeida
 */
function PosMCDCheckSaleMode() {
	if(PosIsInSaleMode(false)) {
		API.dbg("PosMCDCheckSaleMode - POS in sale mode. Unblocking...");
		PosMCDUnBlockJS(BLOCK_SOURCE_SALE_MODE);
	}
	else {
		API.dbg("PosMCDCheckSaleMode - POS NOT in sale mode. Blocking...");
		PosMCDBlockJS("MCD_MSG_BLOCK_SALE_MODE",BLOCK_SOURCE_SALE_MODE);
	}
	return GLOBAL_CSO_BLOCK_SOURCE == null;
}

/********************************************************************************************************************************************
 *													   Barcode Methods                     													*
 ********************************************************************************************************************************************/
 
 /** lGetAssociatedBarcodeReaderName
  *
  * @brief - This function retrieves the value parameter "BarcodeReaderMap" from the section "MOT" in the store-db.xml Store.Wide parameters.
  * This value contains the mapping of each BarcodeReader that is connected with a given COD separated by the '|' character, for example 
  * if the Barcode reader BCR0001 is connected with the COD1 and the Barcode reader BCR0002 is connected with the COD 2 then the value 
  * of this parameter will be: "COD1=BCR0001|COD2=BCR0002".
  * @param - key - Key to search the Barcode reader name, for example, if we want to look for the name of the Barcode reader that is 
  * connected with the COD1 in the example above, then we should call this function passing the "COD1" argument.
  * @returns - The name of the corresponding Barcode reader or an empty string "" if the no name was found for a given key.
  * @since - MOT-239 - Mobile - Enable Crew Activation of the Scanner for Drive-thru check in - 6151868 
  */
 function lGetAssociatedBarcodeReaderName(key) {
	
	var hlp = new BusinessObjectHelper;
	var nameMapping;
	var nameMappingArray;
	var readerNameMap;
	var barcodeReaderName;
	
	barcodeReaderName = "";
	
	nameMapping = hlp.findParamInSectionWide("BarcodeReaderMap", "MOT");
	
	if (nameMapping != undefined && nameMapping != "") {
	
		// Split the reader names using the '|' character.
		nameMappingArray = nameMapping.split("|");

		for each (var name in nameMappingArray) {
			
			// Split each individual mapping using the character '='
			readerNameMap = name.split("=")

			// Check to see if this is the key we are looking for. If so, get its value and return it.
			if (readerNameMap[0] == key) {
				barcodeReaderName = readerNameMap[1];
				break;
			}
		}
	}
	
	return barcodeReaderName;
 }
 
 /** PosMCDEnableBarcodeReaderByCOD
  *
  * @brief - This functions enables a Barcode Reader connected to a given COD.
  * Use the parameter "BarcodeReaderMap" in the Store.Wide configuration section: "MOT" to configure which COD is connected to which Barcode
  * reader.
  * @param - cod - Number of the COD that should have its Barcode Reader enabled (should be 1 or 2).
  * @returns - Always true.
  * @since - MOT-239 - Mobile - Enable Crew Activation of the Scanner for Drive-thru check in - 6151868 
  */
 function PosMCDEnableBarcodeReaderByCOD(cod) {
	
	var codKey;
	var barcodeReaderName;
	
	codKey = "COD" + cod;
	
	API.dbg("[Mobile - PosMCDEnableBarcodeReaderByCOD] Getting Barcode Reader name.");
	barcodeReaderName = lGetAssociatedBarcodeReaderName(codKey);
	API.dbg("[Mobile - PosMCDEnableBarcodeReaderByCOD] COD: " + cod + " Barcode Reader name: " + barcodeReaderName);
	
	if (barcodeReaderName != "") {
		PosMCDSetBarcodeReaderOnActiveMode(barcodeReaderName);
	
	} else {
		API.dbg("[Mobile - PosMCDEnableBarcodeReaderByCOD] No Barcode Reader was found for the COD: " + cod + " no action will be taken");

	}
	
	return true;
 }
 
 /** PosMCDDisableBarcodeReaderByCOD
  *
  * @brief - This functions disables a Barcode Reader connected to a given COD.
  * Use the parameter "BarcodeReaderMap" in the Store.Wide configuration section: "MOT" to configure which COD is connected to which Barcode
  * reader.
  * @param - cod - Number of the COD that should have its Barcode Reader disabled (should be 1 or 2).
  * @returns - Always true.
  * @since - MOT-239 - Mobile - Enable Crew Activation of the Scanner for Drive-thru check in - 6151868 
  */
 function PosMCDDisableBarcodeReaderByCOD(cod) {
	
	var codKey;
	var barcodeReaderName;
	
	codKey = "COD" + cod;
	
	API.dbg("[Mobile - PosMCDDisableBarcodeReaderByCOD] Getting Barcode Reader name.");
	barcodeReaderName = lGetAssociatedBarcodeReaderName(codKey);
	API.dbg("[Mobile - PosMCDDisableBarcodeReaderByCOD] COD: " + cod + " Barcode Reader name: " + barcodeReaderName);
	
	if (barcodeReaderName != "") {
		PosMCDSetBarcodeReaderOnStandByMode(barcodeReaderName);
	
	} else {
		API.dbg("[Mobile - PosMCDDisableBarcodeReaderByCOD] No Barcode Reader was found for the COD: " + cod + " no action will be taken");

	}
	
	return true;
 }
 
 /** PosMCDEnableBarcodeReaderInSelectedCOD
  *
  * @brief - This function enables the Barcode Reader that is connected to the currently selected COD.
  * Use the parameter "BarcodeReaderMap" in the Store.Wide configuration section: "MOT" to configure which COD is connected to which Barcode
  * reader.
  * @returns - Always true.
  * @since - MOT-239 - Mobile - Enable Crew Activation of the Scanner for Drive-thru check in - 6151868 
  */
 function PosMCDEnableBarcodeReaderInSelectedCOD() {
 
	var tandemNbr = PosGetTandemNbrJS();
	
	// If a COD Is selected.
	if (tandemNbr != 0) {
		API.dbg("[Mobile - PosMCDEnableBarcodeReaderInSelectedCOD] Selected COD: " + tandemNbr);
		PosMCDEnableBarcodeReaderByCOD(tandemNbr);
	
	} else {
		API.dbg("[Mobile - PosMCDEnableBarcodeReaderInSelectedCOD] No COD is selected. TandemNbr: " + tandemNbr);
		
	}
	
	return true;
 }
 
  /** PosMCDDisableBarcodeReaderInSelectedCOD
  *
  * @brief - This function disables the Barcode Reader that is connected to the currently selected COD.
  * Use the parameter "BarcodeReaderMap" in the Store.Wide configuration section: "MOT" to configure which COD is connected to which Barcode
  * reader.
  * @returns - Always true.
  * @since - MOT-239 - Mobile - Enable Crew Activation of the Scanner for Drive-thru check in - 6151868 
  */
 function PosMCDDisableBarcodeReaderInSelectedCOD() {
		
	var tandemNbr = PosGetTandemNbrJS();
	
	// If a COD Is selected.
	if (tandemNbr != 0) {
		API.dbg("[Mobile - PosMCDDisableBarcodeReaderInSelectedCOD] Selected COD: " + tandemNbr);
		PosMCDDisableBarcodeReaderByCOD(tandemNbr);
	
	} else {
		API.dbg("[Mobile - PosMCDDisableBarcodeReaderInSelectedCOD] No COD is selected. TandemNbr: " + tandemNbr);
		
	}
	
	return true;
 }
 
 
 /** PosMCDSetBarcodeReaderOnActiveMode
  *
  * @brief - This function sets the barcode reader, LED and MCD Sound Player on the Active mode. As soon as these elements are set to their
  * active mode, the LED begins to blink green.
  * @param - source - Name of the Barcode Extension that should be set to the Active Mode.
  * @return - True if this operation was successfull, otherwise false.
  * @since - MOT-231 - DT Check-In Device - The scan device (reader) must be turned ON or OFF by the a workflow step
  */
 function PosMCDSetBarcodeReaderOnActiveMode(source) {
	var res;
	
	API.dbg("[Mobile - PosMCDSetBarcodeReaderOnActiveMode] Setting the barcode reader: " + source + " to its active mode");
	res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "SetActiveMode", source);
	
	API.dbg("[Mobile - PosMCDSetBarcodeReaderOnActiveMode] Setting the LED to its initial blinking state");
	lSendSetLEDBlinkingColorCommand(source, 500, 153, 255, 0);
 
	return res;
 }
 
 /** PosMCDSetBarcodeReaderOnStandByMode
  *
  * @brief - This function sets the barcode reader, LED and MCD Sound Player on the Stand By mode.
  *			 Note: None of the peripherals that are set to the Stand By Mode will respond to any commands, until they are returned to their
  * 		 Active Mode.
  *			 Note 2: Executing this command will also turn off the LED.
  * @param - source - Name of the Barcode Extension that should be set to the Stand By Mode.
  * @return - True if this operation was successfull, otherwise false.
  * @since - MOT-231 - DT Check-In Device - The scan device (reader) must be turned ON or OFF by the a workflow step
  */
 function PosMCDSetBarcodeReaderOnStandByMode(source) {
	var res;
	
	API.dbg("[Mobile - PosMCDSetBarcodeReaderOnStandByMode] Shutting down the LED");
	lSendSetLEDColorCommand(source, 0, 0, 0);
	
	API.dbg("[Mobile - PosMCDSetBarcodeReaderOnStandByMode] Setting the barcode reader: " + source + " to its stand by mode");
	res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "SetStandByMode", source);
 
	return res; 
 }
 

/********************************************************************************************************************************************
 *														LED Methods                     													*
 ********************************************************************************************************************************************/

/** lSendSetLEDColorCommand
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a steady color using the BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - source - string - Name of the Bar Code Process or Bar Code Reader adaptors that are connected to the LED, for example BCP0001 or BCR0001.
 * @param - red - string (0 - 255) - Red component of the LED color
 * @param - green - string (0 - 255) - Green component of the LED color
 * @param - blue - string (0 - 255) - Blue component of the LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function lSendSetLEDColorCommand(source, red, green, blue) {
	
	var res;
	
	if (source != undefined && source != "") {
		res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "LED_SetSteadyColor", source, red, green, blue);
	
	} else {
		res = false;
	
	}

	return res;
}

/** lSendSetLEDBlinkingColorCommand
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a blinking color using the BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - source - string - Name of the Bar Code Process or Bar Code Reader adaptors that are connected to the LED, for example BCP0001 or BCR0001.
 * @param - blinkFrequency - string (number) - Frequency in miliseconds of the blinking.
 * @param - red - string (0 - 255) - Red component of the LED color
 * @param - green - string (0 - 255) - Green component of the LED color
 * @param - blue - string (0 - 255) - Blue component of the LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function lSendSetLEDBlinkingColorCommand(source, blinkFrequency, red, green, blue) {
	
	var res;
	
	if (source != undefined && source != "") {
		res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "LED_SetBlinkingColor", source, blinkFrequency, red, green, blue);
	
	} else {
		res = false;
	
	}
	
	return res;
}

/** lSendSetLEDBlinkingColorAfterTimeoutCommand
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a blinking color and then to a steady color after the timeout using the 
 * BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - source - string - Name of the Bar Code Process or Bar Code Reader adaptors that are connected to the LED, for example BCP0001 or BCR0001.
 * @param - blinkFrequency - string (number) - Frequency in miliseconds of the blinking.
 * @param - timeout - string (number) - Timeout between the steady color and the blinking color in miliseconds.
 * @param - steadyRed - string (0 - 255) - Red component of the steady LED color
 * @param - steadyGreen - string (0 - 255) - Green component of the steady LED color
 * @param - steadyBlue - string (0 - 255) - Blue component of the steady LED color
 * @param - blinkRed - string (0 - 255) - Red component of the steady LED color
 * @param - blinkGreen - string (0 - 255) - Green component of the steady LED color
 * @param - blinkBlue - string (0 - 255) - Blue component of the steady LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function lSendSetLEDBlinkingColorAfterTimeoutCommand(source, blinkFrequency, timeout, steadyRed, steadyGreen, steadyBlue, blinkRed, blinkGreen, blinkBlue) {

	var res;
	
	if (source != undefined && source != "") {
		res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "LED_SetBlinkingColorAfterTimeout", source, blinkFrequency, timeout, steadyRed, steadyGreen, steadyBlue, blinkRed, blinkGreen, blinkBlue);
	
	} else {
		res = false;
	
	}
	
	return res;
}


/** PosMCDSetLedColorJS
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a steady color using the BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - red - string (0 - 255) - Red component of the LED color
 * @param - green - string (0 - 255) - Green component of the LED color
 * @param - blue - string (0 - 255) - Blue component of the LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function PosMCDSetLedColorJS(red, green, blue)
{	
	var ctx = new SessionContext;
	var source;
	var operation;
	
	operation = ctx.get("POD");
	
	// Determine the source of the command. If current New POS is configured as a Lobby CheckIn device.
	if (operation == "CSO") {
		source = lGetBarcodeServiceName();
	
    // If the current New POS is configured as a Drive Through device.
	} else if (operation == "DT") {
		source = ctx.get("lastBarCodeSource");
	
	// Take no action with the LED if the current New POS is not configured for neither lobby nor drive through.
	} else {
		return true;
		
	}
	
	lSendSetLEDColorCommand(source, red, green, blue);
	
	return true;
}

/** PosMCDSetLEDBlinkingColorJS
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a blinking color using the BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - blinkFrequency - string (number) - Frequency in miliseconds of the blinking.
 * @param - red - string (0 - 255) - Red component of the LED color
 * @param - green - string (0 - 255) - Green component of the LED color
 * @param - blue - string (0 - 255) - Blue component of the LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function PosMCDSetLEDBlinkingColorJS(blinkFrequency, red, green, blue) {

	var ctx = new SessionContext;
	var source;
	var operation;
	
	operation = ctx.get("POD");
	
	// Determine the source of the command. If current New POS is configured as a Lobby CheckIn device.
	if (operation == "CSO") {
		source = lGetBarcodeServiceName();
	
    // If the current New POS is configured as a Drive Through device.
	} else if (operation == "DT") {
		source = ctx.get("lastBarCodeSource");
	
	// Take no action with the LED if the current New POS is not configured for neither lobby nor drive through.
	} else {
		return true;
		
	}
	
	lSendSetLEDBlinkingColorCommand(source, blinkFrequency, red, green, blue);
	
	return true;
}

/** PosMCDSetLEDBlinkingColorAfterTimeoutJS
 * 
 * @brief - Changes the current color and state of the BlinkM LED to a blinking color and then to a steady color after the timeout using the 
 * BarCodeReaderExtension adaptor.
 * Note: The color is expressed in RGB values.
 * @param - blinkFrequency - string (number) - Frequency in miliseconds of the blinking.
 * @param - timeout - string (number) - Timeout between the steady color and the blinking color in miliseconds.
 * @param - steadyRed - string (0 - 255) - Red component of the steady LED color
 * @param - steadyGreen - string (0 - 255) - Green component of the steady LED color
 * @param - steadyBlue - string (0 - 255) - Blue component of the steady LED color
 * @param - blinkRed - string (0 - 255) - Red component of the steady LED color
 * @param - blinkGreen - string (0 - 255) - Green component of the steady LED color
 * @param - blinkBlue - string (0 - 255) - Blue component of the steady LED color
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function PosMCDSetLEDBlinkingColorAfterTimeoutJS(blinkFrequency, timeout, steadyRed, steadyGreen, steadyBlue, blinkRed, blinkGreen, blinkBlue) {

	var ctx = new SessionContext;
	var source;
	var operation;
	
	operation = ctx.get("POD");
	
	// Determine the source of the command. If current New POS is configured as a Lobby CheckIn device.
	if (operation == "CSO") {
		source = lGetBarcodeServiceName();
	
    // If the current New POS is configured as a Drive Through device.
	} else if (operation == "DT") {
		source = ctx.get("lastBarCodeSource");
	
	// Take no action with the LED if the current New POS is not configured for neither lobby nor drive through.
	} else {
		return true;
		
	}
	
	lSendSetLEDBlinkingColorAfterTimeoutCommand(source, blinkFrequency, timeout, steadyRed, steadyGreen, steadyBlue, blinkRed, blinkGreen, blinkBlue);
	
	return true;
}

/********************************************************************************************************************************************
 *														Sound Methods                    													*
 ********************************************************************************************************************************************/

/** PosMCDPlaySoundJS
 * 
 * @brief - Plays a sound using the BarCodeReaderExtension adaptor.
 * @param - soundName - string - Name of the sound that should be played. Please note that the sound file should be present inside the sound repository zip file.
 * @returns - allways true.
 * @author - Felipe Armoni
 * @since - NPM-209 DT Check-In - Support for Sounds and Scanner LED and NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
 */
function PosMCDPlaySoundJS(soundName)
{	
	var soundRepositoryPath;
	var ctx = new SessionContext;
	var source;
	var operation;
	
	operation = ctx.get("POD");
	
	// Determine the source of the command. If current New POS is configured as a Lobby CheckIn device.
	if (operation == "CSO") {
		source = lGetBarcodeServiceName();
	
    // If the current New POS is configured as a Drive Through device.
	} else if (operation == "DT") {
		source = ctx.get("lastBarCodeSource");
	
	// Take no action if the current New POS is not configured for neither lobby nor drive through.
	} else {
		return true;
		
	}
	
	soundRepositoryPath = rootStoreDB.Configurations.Configuration.(@type == "POS").Section.(@name == "CSO.UserInterface").Parameter.(@name == "soundsSource").@value;
	
	if (source != undefined && source != "") {
			var res = PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "PlaySound", source, soundRepositoryPath.toXMLString() + "|" + soundName);
	}
	
	return true;
}

/********************************************************************************************************************************************
 *														MCD - Mobile Check-in Device (DT)													*
 ********************************************************************************************************************************************/

/**PosGetTandemNbrJS
*
* @brief - This auxiliary function gets the tandem booth number
* @return - tandem booth. Zero for non-dedicated COD.
*/
function PosGetTandemNbrJS() {
	if (!PosCheckSessionProperty("POD", "DT")) {
		return 0;
	}

	if (!PosCheckSessionProperty("workingMode", "orderTaker|both")) {
		return 0;
	}

	var ctx = new SessionContext;

	if (PosCheckSessionProperty("dedicatedCOD", "false")) {
		// return selected COD if any
		var cod = Number(ctx.get("activatedCOD"));

		if(cod<0) {
			cod = (-1)*cod;
		}

		return cod;
	}

	var cod0 = ctx.get("COD 0");

	if (cod0 == null) {
		return 0;
	}

	if (cod0.length == 0) {
		return 0;
	}

	// This is a dedicated COD

	var cod1 = ctx.get("COD 1");
	if (cod1 == cod0) {
		// Primary
		return 1;
	}

	var cod2 = ctx.get("COD 2");
	if (cod2 == cod0) {
		// Secondary
		return 2;
	}

	return 0;
}


/**
 * @brief - Save barcode identification for future use
 * @param - source - Reader identification
 * @param - id - unique barcode id
 * @param - cod - cod associated with source
 * @return
 */
function PosSaveCtxBarCode(source, id, cod) {
	var ctx = new SessionContext;

	var sourceCtx = MOBILE_BASE_CTX_SOURCE + cod;
	var idCxt = MOBILE_BASE_CTX_ID + cod;

	ctx.set(sourceCtx, source);
	ctx.set(idCxt, id);
}

/**
 * @brief - Show message new barcode read and return without waiting (non modal)
 * @return
 */
function PosNewBarCodeMsg() {
	var codResult = new Array();

	var ctx = new SessionContext;
	var cod = 1;
	do {
		var sourceCtx = MOBILE_BASE_CTX_SOURCE + cod;
		var idCxt = MOBILE_BASE_CTX_ID + cod;
		var source = ctx.get(sourceCtx);
		var id = ctx.get(idCxt);
		if ( (id != 0) && (source != null) ) {
			codResult[cod-1] = true;
		} else {
			codResult[cod-1] = false;
		}
		
		cod++;
	}
	while (cod<=MOBILE_NUMBER_COD);

	// close any message box
	PosCloseNonModalMessage();

	var hlp = new BusinessObjectHelper;

	if (codResult[0] && codResult[1]) {
		var msgShow = lGetI18nMessage("MSG_MOBILE_NEW_BC_2", "1", "2");
	} else if (codResult[0]) {
		var msgShow = lGetI18nMessage("MSG_MOBILE_NEW_BC_1", "1");
	} else if (codResult[1]) {
		var msgShow = lGetI18nMessage("MSG_MOBILE_NEW_BC_1", "2");
	} else {
		API.dbg("[Mobile - PosNewBarCodeMsg] no barcode");
		return false
	}

	var msgOK = lGetI18nMessage("MSG_OK");
	PosShowNonModalMessage(0, msgShow, msgOK);
	
	return true;
}

/**
 * @brief - Called by workflow and npextension when user click on OK button
 * if in dedicated mode do a sale
 */
function PosNonModalMessageEvent() {
	var tandemNbr = PosGetTandemNbrJS();
	if (tandemNbr != 0) {
		// find witch COD for dedicated mode
		var ctx = new SessionContext;
		var cod = 1;
		do {
			var sourceCtx = MOBILE_BASE_CTX_SOURCE + cod;
			var idCxt = MOBILE_BASE_CTX_ID + cod;
			var source = ctx.get(sourceCtx);
			var id = ctx.get(idCxt);
			if ( (id != 0) && (source != null) ) {
				API.dbg("[Mobile - PosNonModalMessageEvent] tandemNbr: " + tandemNbr + ", COD " + cod);
				PosDoSaleMobile(cod);
				return;
			}

			cod++;
		}
		while (cod<=MOBILE_NUMBER_COD);
	}
}


/**
 * @brief - Check if we have a mobile barcode available. If so show message and do a sale on dedicated COD mode.
 * 		    Usually called inside a workflow after end of transaction.
 * @param
 * @return true for a new barcode and false for no barcode
 */
function PosCheckBarCode() {
	// check if we have a mobile available
	if (!PosNotATransactionInProgress(true)) {
		return true;
	}

	return PosNewBarCodeMsg();
}


/** PosBarCodeReceived
 *
 * @brief - Receive a signal from bar code reader telling that a new bar code was read on reader.
 * 			Called from a external extension
 * @param - source - Reader identification
 * @param - id - Unique identification associated to barcode
 * @param - cod - cod number
 * @return  true
 * @since 1.17
 */
function PosBarCodeReceived(source, id, cod) {

	API.dbg("[Mobile - PosBarCodeReceived] A barcode was received. Source: " + source + " Id: " + id + " COD: " + cod + " Tandem Number: " + tandemNbr);

	if(!PosCheckState("POS_OpLogged")) {
		API.dbg("[Mobile - PosBarCodeReceived] operator not logged");
		return false;
	}

	// check OT or CS
	if (!PosCheckSessionProperty("workingMode","orderTaker|both")) {
		API.dbg("[Mobile - PosBarCodeReceived] Current working mode is different from orderTaker|both");
		return false;
	}

	if ( (id == 0) || (source == null) ) {
		API.dbg("[Mobile - PosBarCodeReceived] invalid source or id parameter");
		return false;
	}

	if (PosCheckSessionProperty("isPosPaused","true")) {
		API.dbg("[Mobile - PosBarCodeReceived] Pos paused");
		return false;
	}
	
	var currentSaleStatus = lGetCurrentSaleStatus();
	
	// Check if the current sale status supports adding new products from the QR Code scanner.
	if (((currentSaleStatus != undefined) && (currentSaleStatus != "")) && ((currentSaleStatus < 0) || (currentSaleStatus > 1))) {
		API.dbg("[Mobile - PosBarCodeReceived] The current sale status: " + currentSaleStatus + " is different from START (0, \"\") or IN_PROCESS (1)");
		return false;
	}
	
	var tandemNbr = PosGetTandemNbrJS();
		
	API.dbg("[Mobile - PosBarCodeReceived] Processing the received barcode.");
	
	// If a COD is selected.
	if (tandemNbr != 0) {
		
		if (cod == tandemNbr) {
			API.dbg("[Mobile - PosBarCodeReceived] A barcode was received for this cod. Tandem: " + tandemNbr + ", cod: " + cod + ", id: " + id);
			PosSaveCtxBarCode(source, id, cod);
			PosDoSaleMobile(cod);
		
		} else {
			API.dbg("[Mobile - PosBarCodeReceived] The received barcode was not for this cod. Tandem: " + tandemNbr + ", cod: " + cod + ", id: " + id);
			
		}
	} 
	else {
		API.dbg("[Mobile - PosBarCodeReceived] No COD is selected for this POS.");
		
	}
	
	return true;
}



/**
 * @brief - Called from COD button workflow.
 * 			Check if we have a valid bar code (not read or processed)
 * 			Validate view and do a sale
 * @param - cod - cod number
 * @return true in case of sale
 */
function PosDoSaleMobile(cod) {
	// check if we have a mobile available
	var ctx = new SessionContext;
	var sourceCtx = MOBILE_BASE_CTX_SOURCE + cod;
	var idCxt = MOBILE_BASE_CTX_ID + cod;
	var source = ctx.get(sourceCtx);
	var id = ctx.get(idCxt);
	var hlp = new BusinessObjectHelper;

	API.dbg("[Mobile - PosDoSaleMobile] - Starting function");
	
	if ( (id == 0) || (source == null) ) {
		API.dbg("[Mobile - PosDoSaleMobile] no barcode for cod " + cod);
		return false;
	}

	// check if COD is busy
	// if busy ignore
	if (!PosSetCOD(0)) {
		// restore screen.
		// there is no option if crew choose a different COD
		// in any case just return to the initial screen
		PosSetSessionProperty("activatedCOD",0,"true");
		PosDisplayText("",1);
		PosShowScreen(ctx.get("baseScreenId"));
		API.dbg("[Mobile - PosDoSaleMobile] COD " + cod + "busy");
		return false;
	}

	var mobileViewStr = PosReadBarCode(source, id);

	// clear data
	PosSaveCtxBarCode(null, 0, cod);

	if (mobileViewStr == "") {
		API.dbg("[Mobile - PosDoSaleMobile] barcode " + source + " " + id + " already read");
		return false;
	}

	var mobileView = new MCDMobileView(mobileViewStr);
	
	var mobileViewXML = mobileView.getView();
	
	API.dbg("[Mobile - PosDoSaleMobile] Received barcode view: " + mobileViewXML.toXMLString());
	
	// NPM-209 DT Check-In - Support for Sounds and Scanner LED
	// Sets an evironment variable with the reader source of the barcode that was just read.
	// This source will later receive the Play Sound command when the order taker presses the Store button.
	ctx.set("lastBarCodeSource", source);

	// NPM-208 - Check-In Device (In-Store) - LED support for Scanner operations
	// Turns off the LED if the current POS is configured for drive through operation.
	PosMCDSetLedColorJS("0", "0", "0");
	
	//var productStatusXML = PosPreValidationMobileOrder(mobileViewXML);

	// Validate country.
	API.dbg("[Mobile - PosDoSaleMobile] Validating country");
	if (!mobileView.ValidateCountry()) {
		
		// if wrong country id no possible partial item sale. Just show a message
		// Orders with invalid header
		// The system shall display a popup screen to the crew to indicate that the barcode scan was invalid
		
		API.dbg("[Mobile - PosDoSaleMobile] WARNING - The current sale has an invalid country code");
		var msgText = lGetI18nMessage("MSG_MOBILE_ERROR_BARCODE");
		PosShowMessage(msgText);
		PosSaveView(mobileViewXML, false);
		return false;
	}
	
	// Validate all items.
	API.dbg("[Mobile - PosDoSaleMobile] Validating items");
	mobileView.ValidateItems();
	
	var allItemsAreValid;
	var allItemsAreInvalid = mobileView.areAllItemsInvalid();	
	
		
	if (!allItemsAreInvalid)
	{
		API.dbg("[Mobile - PosDoSaleMobile] - Checking Basic promotions ");
		mobileView.CheckAllBasicPromotions();
		
		var productNameToReplace = null;
		
		if (invalidItemsPromo.length > 0)
		{		
			msgText = "Products not in promotional time-frame: " + '\n';
			for each(var codProd in invalidItemsPromo)
			{
				productNameToReplace = lMCDGetProductName(codProd);
				if ( productNameToReplace == null 	||
					productNameToReplace == ""		||
					productNameToReplace == undefined)
				{
					productNameToReplace = codProd;
					API.dbg("[Mobile - ProcessView] - WARNING - Product name not found at names-db.xml for Code: " + codProd);				
				}			
				msgText += productNameToReplace + '\n' ;
				API.dbg("[Mobile - PosDoSaleMobile] - Invalid product: " + codProd);
			}
			PosShowMessage(msgText);								
		}else{
			API.dbg("[Mobile - PosDoSaleMobile] - One or more products are in the promotional period.");		
		}
		API.dbg("[Mobile - PosDoSaleMobile] - Basic Promotions Checking done");
		//zeroizing
		invalidItemsPromo.length = 0;
	}
	

	API.dbg("[Mobile - PosDoSaleMobile] Processing the current view.");
	
	// If all the items are invalid, show a message to the user.
	if (allItemsAreInvalid) {
		API.dbg("[Mobile - PosDoSaleMobile] All of the items in the current order are invalid.");
		
		var msgText = lGetI18nMessage("MSG_MOBILE_ERROR_INVALID_ITEMS");
		PosShowMessage(msgText);
	
	} else {
		// Process the view and sell the valid items.
		API.dbg("[Mobile - PosDoSaleMobile] Selling the valid items.");
		mobileView.ProcessView();
		
		// Check if all the items sold are indeed valid.
		allItemsAreValid = mobileView.areAllItemsValid();
		
		// If not all items are valid, generate a report to the user.
		if (!allItemsAreValid) {
			API.dbg("[Mobile - PosDoSaleMobile] Some of the items in the current order are invalid.");
			PosCreateReport("CUSTOMDATA", "receiptExceptionMessage@reportsLocal.nps", "", mobileViewXML.toString());
		
		}
	}
	
	PosShowScreen(ctx.get("baseScreenId"));

 	PosSaveView(mobileViewXML, allItemsAreValid);	

	return true;

	/**
	 * Save mobileView in a file. File name will be set by bError and count each time.
	 */
	function PosSaveView(mobileView, bError) {
		var ctx = new SessionContext;
		var path = ctx.get(MOBILE_DIR_PATH);

		if (!bError) {
			var fileNameCount = "ctr_fail.dat";
			var filePrefix = "MobileViewFail_";
		}
		else {
			var fileNameCount = "ctr_success.dat";
			var filePrefix = "np6View_";
		}

		var fileCount = PosMobileOpenCtrlFile(path, fileNameCount);
		var fileName = path + filePrefix + fileCount.toString() + ".xml";
		API.dbg("[Mobile - PosSaveView] - fileName: "+fileName);

		if (File.exists(fileName)) {
			// there is something wrong
			API.dbg("[Mobile - PosSaveView] - file "+fileName+" already exists");
			return false;
		}

		var hlp = new BusinessObjectHelper;
		var view = hlp.getCurrentView();
		if (view != null) {
			var viewXML = new XML(view);
		} else {
			var viewXML = null;
		}

		var viewFile = new File(fileName);
		if(viewFile.open("w")) {
			var strFile = "<MobTld>\n" + mobileView.toXMLString();
			if (viewXML != null) {
				strFile =  strFile + "\n" + viewXML.toXMLString();
			}
			strFile =  strFile + "\n</MobTld>";
			viewFile.write(strFile);
			viewFile.close();
		}
		else {
			API.dbg("[Mobile - PosSaveView] - error opening file: "+fileName);
			return false;
		}

		return true;


		function PosMobileOpenCtrlFile(path, fileCtrl) {
			var fileName = path + fileCtrl;
			var controlFile = new File(fileName);
			var fileNameCount = 0;

			if (File.exists(fileName)) {
				if (controlFile.open("r")) {
					fileNameCount = Number(controlFile.read());
					controlFile.close();
				}
				else {
					API.dbg("[Mobile - PosMobileOpenCtrlFile] error open for read file " + fileName);
					return 0;
				}
			} else {
				fileNameCount = -1;
			}

			fileNameCount++;
			if (controlFile.open("w")) {
				controlFile.write(fileNameCount.toString());
				controlFile.close();
			}
			else {
				API.dbg("[Mobile - PosMobileOpenCtrlFile] error open for write file " + fileName);
			}

			return fileNameCount;
		}
	}

	/**
	 * @brief - connect to reader extension to get the barcode info in mobile view format
	 * @param - source - source (reader) identification
	 * @param - id - unique barcode identification
	 * @return - mobile view
	 */
	function PosReadBarCode(source, id) {
		if (PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "Read", source, id)) {
			// get result as Encoded xml (some xml symbols are removed to be able to use getLastSuccess)
			var xmlEncode = getLastSuccess("PosNPSExtRequestCmd");

			return xmlEncode.toString();
		}

		return "";
	}
}


/** PosBarCodeReadError
 *
 * @brief - Receive a signal from bar code reader telling that a error occur when reading
 * @param - source - Reader identification
 * @param - cod - cod number
 * @return  none
 * @since 1.17
 */
function PosBarCodeReadError(source, cod) {

	if(!PosCheckState("POS_OpLogged")) {
		API.dbg("[Mobile - PosBarCodeReadError] operator not logged");
		return;
	}

	// check OT or CS
	if (!PosCheckSessionProperty("workingMode","orderTaker|both")) {
		API.dbg("[Mobile - PosBarCodeReadError] Not orderTaker");
		return;
	}

	if (PosCheckSessionProperty("isPosPaused","true")) {
		API.dbg("[Mobile - PosBarCodeReadError] Pos paused");
		return;
	}

	var tandemNbr = PosGetTandemNbrJS();
	
	// If a COD is selected.
	if (tandemNbr != 0) {
		if (cod == tandemNbr) {
			API.dbg("[Mobile - PosBarCodeReadError] An error occurred while reading the barcode for the COD: " + cod);
			
			var hlp = new BusinessObjectHelper;
			var msg = lGetI18nMessage("MSG_MOBILE_ERROR_READ", cod);
			
			PosShowMessage(msg);
		}

		else {
			API.dbg("[Mobile - PosBarCodeReadError] An error occurred while reading the barcode for the other COD: " + cod);
		}
	}	
}

/**
 * @brief - Called by npextension when some barcode was read by another POS.
 * 			Is will close the current window if open and show a new message in case there are others barcodes to read.
 * @param - source - Reader identification
 * @param - id - Unique identification associated to barcode
*/
function PosBarCodeWasRead(source, id) {
	// look for id/source on all COD

	var ctx = new SessionContext;
	var cod = 1;
	do {
		var sourceCtx = MOBILE_BASE_CTX_SOURCE + cod;
		var idCxt = MOBILE_BASE_CTX_ID + cod;
		var sourceStore = ctx.get(sourceCtx);
		var idStore = ctx.get(idCxt);
		if ( (id == idStore) && (source == sourceStore) ) {
			// found?
			// clear
			ctx.set(sourceCtx, null);
			ctx.set(idCxt, 0);
			// close message if open
			// show message for a different COD.

			return PosCheckBarCode();
		}

		cod++;
	}
	while (cod<=MOBILE_NUMBER_COD);

	PosCloseNonModalMessage();
}

/** PosShowNonModalMessage
*
* @brief - Show a non modal dialog box in front of NP window
* @param - timeOut - If zero no timeout. Otherwise the time in miliseconds before close message
* @param - message - string with message to show.
* @param - buttonMessage - string with message to be write on button.
* @return - true/false
* @since 1.17
*/
function PosShowNonModalMessage(timeOut, message, buttonMessage) {
	if (PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "ShowMessage", timeOut, message, buttonMessage)) {
		// there is no Last Success
		return true;
	}

	return false;
}


/** PosCloseNonModalMessage
*
* @brief - Close the current non modal dialog
* @return - true/false
* @since 1.17
*/
function PosCloseNonModalMessage() {
	if (PosNPSExtRequestCmd(MOBILE_BAR_CODE_PROCESS_NP_EXT, "CloseMessage")) {
		// there is no Last Success
		return true;
	}

	return false;
}

/********************************************************************************************************************************************
 *														Operation Methods          												        	*
 ********************************************************************************************************************************************/

/**PosMCDDoOperatorLogoutJS
 *
 * @brief - This BC calls PosDoOperatorLogout_CSL and, if defined, onLogoutFinalize
 * @param remote - String - Optional, "true" to indicate a remote logout (default:"false")
 * @hook <i>onLogoutFinalize()</i> -  invoked after PosDoOperatorLogout_CSL
 */
function PosMCDDoOperatorLogoutJS(remote) {
	var ret = PosDoOperatorLogout_CSL('true');
	if(typeof(onLogoutFinalize) == "function") {
		ret = onLogoutFinalize();
	}
	return ret;
}

/** PosMCDRemotelyInitCashlessJS
 *
 * @brief - This BC is responsible for initializing cashless in the Checkin Device.
 * This BC should be called via PosRemoteExecute in a remote register
 * @return - always true
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
function PosMCDRemotelyInitCashlessJS() {
	var ret = PosResetPinpad();
	API.dbg("PosMCDRemotelyInitCashlessJS - PosResetPinpad returned: "+ret);
	ret = InitCashless("false", "false", "false" );
	API.dbg("PosMCDRemotelyInitCashlessJS - InitCashless returned: "+ret);
	return true;
}

/** PosMCDRemotelyCashlessUpdateJS
 *
 * @brief - This BC is responsible for downloading cashless update in Checkin device from a remote Register.
 * This BC should be called via PosRemoteExecute in a remote register
 * @return - always true
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
 function  PosMCDRemotelyCashlessUpdateJS() {
	var ret = cashlessDownloadUpdate();
	API.dbg("PosMCDRemotelyCashlessUpdateJS - cashlessDownloadUpdate returned: "+ret);
	var xml = new StringBuffer();
	xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
	xml.append("<Event type=\"ASYNC\" name=\"DLG_SYS_CLOSE_SCREENPOPUP\">\n</Event>");
	PosSendUICmd(xml.toString());
	return true;
}

/** PosMCDRemotelySettlementDateCashlessJS
 *
 * @brief - This BC performs settlement date operation in Checkin device from a remote Register. 
 * This BC should be called via PosRemoteExecute in a remote register
 * @return - always true
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
 function  PosMCDRemotelySettlementDateCashlessJS() {
	var ret = cashlessSettlementDate("false");
	API.dbg("PosMCDRemotelySettlementDateCashlessJS - cashlessSettlementDate returned: "+ret);
	return true;
}

/** PosMCDRemotelyDayOpenJS
 *
 * @brief - This BC performs the open of a day in the Checkin device from a remote Register
 * This BC should be called via PosRemoteExecute in a remote register
 * @param - date - string - business date to be open. Must be in format yyyyMMdd
 * @return - always true
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
 function  PosMCDRemotelyDayOpenJS(date) {
	API.dbg("PosMCDRemotelyDayOpenJS - received date: "+date);
	PosSetSessionProperty("savePosReport","true");
	var ret = cPosDayOpen("offline",date);
	API.dbg("PosMCDRemotelyDayOpen - cPosDayOpen returned: "+ret);
	if(ret) {
		PosSetSessionProperty("firstSaleDone", "false", "true");
		ret = PosCreateReportJS("CASH", "reportDayOpen@reportsLocal.nps", "NOPREVIEW");
		API.dbg("PosMCDRemotelyDayOpen - PosCreateReportJS returned: "+ret);
	}
	return true;
}

/** PosMCDRemotelyDayCloseJS
 *
 * @brief - This BC performs the end of day in the Checkin Device from a remote register
 * This BC should be called via PosRemoteExecute in a remote register
 * @return - always true
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
 function  PosMCDRemotelyDayCloseJS() {
	var ret = PosEndOfDay("execute","remote");
	API.dbg("PosMCDRemotelyDayClose - PosEndOfDay returned: "+ret);
	ret = PosCreateReportJS("ALL", "reportEndOfDay@reportsLocal.nps", "NOPREVIEW");
	API.dbg("PosMCDRemotelyDayClose - PosCreateReportJS returned: "+ret);
	return true;
}
 
/**
* @brief - Performs the store wide anonymous LOGIN for all the kiosk nodes, this function should only be called by register nodes through a screen button action.
* @param - timeout:
* @param - CSONodes - List of nodes separeted by pipe. Ex.: POS0025|POS0026
* @return - true/false
* @author - Wilson
*/
function PosCSODoSWLoginJS(timeout, CSONodes) {
	nodes=CSONodes.split("|");
	for each (node in nodes) {
		var cantLogin = ""
		if (!PosDoRemoteLogin(node, timeout)) {
			cantLogin += node;
			if(cantLogin.length > 0) {
				cantLogin += "|";
			}
		}
	}
	if(cantLogin.length > 0) {
		API.dbg("CSO - Could not login in the CSO nodes[" + cantLogin + "]");
		PosShowMessage("Could not login in the CSO node ["+cantLogin+"]");
		return false;
	}
	PosShowMessage("Remote login was successfully performed for all " + nodes.length + " nodes!");
	return true;
}
/**
* @brief - This function performs the store wide LOGOUT for all the kiosk nodes, this function should only be called by register nodes through a screen button action.
* @param - timeout:
* @param - CSONodes - List of nodes separeted by pipe. Ex.: POS0025|POS0026
* @return - true/false
* @author - Wilson
*/
function PosCSODoSWLogoutJS(timeout, CSONodes) {
	nodes=CSONodes.split("|");
	var cantLogout = ""
	for each (node in nodes) {
		PosShowMessage("node["+node+"]");
		if (!PosDoRemoteDrawerChange(node, timeout)) {
			cantLogout += node;
			if(cantLogout.length > 0) {
				cantLogout += "|";
			}
			API.dbg("CSO - Could not logout in the CSO nodes[[" + cantLogout + "])");
			PosShowMessage("Could not logout in the CSO node ["+cantLogout+"]");
			return false;
		}
	}
	PosShowMessage("Remote logout was successfully performed for all " + nodes.length + " nodes!");
	return true;
}

/** PosRemoteDayOpenJS
 *
 * @brief - This BC sends a command to open the day in the Checkin Device from a Register.
 * It should be associated to a workflow that will be called in a register.
 * @param - resources - resources of destination. (it MUST be in the form POSNNNN, where NNNN is the resource name with 4 digits).
 * @return - true if the command was successfully sent to the nodes (resoureces parameter)
 * @since - NPM-40
 * @author - Raphael Almeida
 * @remarks - This BC has been created for APMEA during integration tests. See NPM-40 for more details
 */
function PosRemoteDayOpenJS(resource) {
	
	// Gets Date System
	var systemDate = new NPDate();
	var systemYear = setZerosOnLeft(systemDate.getFullYear(),4);
	var systemMonth = setZerosOnLeft(systemDate.getMonth() + 1,2);
	var SystemDay = setZerosOnLeft(systemDate.getDate(),2);
	var systemDate = systemYear + systemMonth + SystemDay;
	var formatedDate = "";
	
	var date = PosShowCalculator("MSG_BC_DAYOPENCONF","","2","0");
	if(date == null || date.length == 0) {
		return false
	}
	if(!lIsValidDate(date)) {
		API.dbg("PosRemoteDayOpenJS - invalid date entered: "+date);
		PosShowMessage("MSG_BC_INVDATE");
		return false;
	}
	
	if(!PosGetAuthorization("manager")) {
		API.dbg("PosRemoteDayOpenJS - Authorization denied");
		return false;
	}
	API.dbg("PosRemoteDayOpenJS - before PosRemoteExecute - formatedDate: "+formatedDate);
	return PosRemoteExecute(resource, "PosMCDRemotelyDayOpenJS", formatedDate);
	
	/** lIsValidDate
	 *
	 * @brief - This function checks if the date is valid. It sets the variable "formatedDate"
	 * with the date in format yyyymmaa
	 * @return - true if the date is valid. false otherwise
	 * @since - NPM-40
	 * @author - Raphael Almeida
	 * @remarks - This function has been created for APMEA during integration tests. See NPM-40 for more details
	 */
	function lIsValidDate(date) {
		if(date.length != 8) {
			return false;
		}
		
		var day = "";
		var month = "";
		var year = "";
		var dateFormat	= rootStoreDB.StoreDB.StoreProfile.Localization.DateFormat;
		var format = String(dateFormat).split("-");
		var offset = 0;
		
		for each(element in format) {
			if(element == "dd") {
				day = date.substring(offset,offset+2);
				API.dbg("lIsValidDate - day: "+day);
				offset += 2;
				continue;
			}
			if(element == "MM") {
				month = date.substring(offset,offset+2);
				API.dbg("lIsValidDate - month: "+month);
				offset += 2;
				continue;
			}
			if(element == "yyyy") {
				year = date.substring(offset,offset+4);
				API.dbg("lIsValidDate - year"+year);
				offset += 4;
				continue;
			}
		}
		
		if( (Number(day) > 0 && Number(day) <= 31) && (Number(month) > 0 && Number(month) <= 12) && (Number(year) > 0) ) {
			formatedDate = year+month+day;
			return true;
		}
		return false;
	}
}

/** lGetCurrentSaleStatus
 *
 * @brief - This function retrieves the sale status of the current sale.
 * @returns - The status of the current sale.
 * @since - MOT-231 - DT Check-In Device - The scan device (reader) must be turned ON or OFF by the a workflow step
 */
function lGetCurrentSaleStatus() {
	
	var hlp = new BusinessObjectHelper;	
	
	// Get the current sale view
	var saleView = new XML(hlp.getCurrentView());
	
	// Get the sale status
	return saleView.@saleStatus;

}

/** lIsInTimeRestriction
	 *
	 * @brief - Checks if the the product is in salable period.
	 * @param - interval - string - period when the product can be sold. The format is <from>,<to>. Where the format for <from> and <to> is
	 * hh:mm where hh is the hour (from 00 to 23) and mm is the minute (from 00 to 59). Multiple values must be concatenated using "|", 
	 * for instance "<from>,<to>| <from>,<to>| <from>,<to>".
	 * Examples:
	 *	- Product can only be sold from 10:00 to 14:00 = "10:00,14:00"
	 *	- Product can only be sold from 22:00 to 04:00 = "22:00,23:59|00:00,04:00"
	 *	- Product can be sold from 14:00 to 16:00 and  from 21:00 to 23:00="14:00,16:00|21:00,23:00"
	 * @return - true if the current time is within the period. false otherwise
	 * @author - Raphael Almeida
	 * @since - MOT-154 - FOE - Implement the product validation used in the Check-In Device into the FOE.
	 */
	function lIsInTimeRestriction(period) {
		if(period == null || period == "") {
			return true;
		}
		var timeNow = new NPDate();
		
		var intervals = String(period).split("|");
		for each(interval in intervals) {
			var timeRange = String(interval).split(",");
			var initialHour = Number(String(timeRange[0]).split(":")[0]);
			var initialMinute = Number(String(timeRange[0]).split(":")[1]);
			var finalHour = Number(String(timeRange[1]).split(":")[0]);
			var finalMinute = Number(String(timeRange[1]).split(":")[1]);
			
			var initialTime = new NPDate(timeNow.getFullYear(), timeNow.getMonth(), timeNow.getDate(), initialHour, initialMinute);
			var finalTime = new NPDate(timeNow.getFullYear(), timeNow.getMonth(), timeNow.getDate(), finalHour, finalMinute);
			if(timeNow >= initialTime && timeNow < finalTime) {
				return true;
			}
		}
		return false;
	}

/** @} END nps */

/* signed aut version 9-9076
 * authority id = coe
 * authority level = 40
 * authority name = NewPOS COE developer
 * group = npi
 * validity = 2010-04-18
 * signature type = slash_star
 * time stamp (GMT) = Wed Jan 31 01:28:45 2018
 * certificate = 393735312d373934370015329ba88a3355dd9a011710f4a161787844394e3de7c0fc25f84d0414cb435d0f4e311794fbaa2a4461ea54bed1976ac9310010
 * =================================================================================================================================
*/
